/*
 Navicat Premium Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 50736
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50736
 File Encoding         : 65001

 Date: 18/07/2022 21:33:40
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for ms_admin
-- ----------------------------
DROP TABLE IF EXISTS `ms_admin`;
CREATE TABLE `ms_admin`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_admin
-- ----------------------------
INSERT INTO `ms_admin` VALUES (1, 'admin', '$2a$10$JYvxA9.jLpVN6yie4SF48O9kn6xIGNz.y9qzrAwqIcUnv.1y5w3cC');
INSERT INTO `ms_admin` VALUES (2, 'shan', '$2a$10$JYvxA9.jLpVN6yie4SF48O9kn6xIGNz.y9qzrAwqIcUnv.1y5w3cC');

-- ----------------------------
-- Table structure for ms_admin_permission
-- ----------------------------
DROP TABLE IF EXISTS `ms_admin_permission`;
CREATE TABLE `ms_admin_permission`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `admin_id` bigint(20) NOT NULL,
  `permission_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_admin_permission
-- ----------------------------
INSERT INTO `ms_admin_permission` VALUES (1, 1, 1);
INSERT INTO `ms_admin_permission` VALUES (2, 1, 2);
INSERT INTO `ms_admin_permission` VALUES (3, 1, 3);
INSERT INTO `ms_admin_permission` VALUES (4, 1, 4);
INSERT INTO `ms_admin_permission` VALUES (5, 2, 1);

-- ----------------------------
-- Table structure for ms_permission
-- ----------------------------
DROP TABLE IF EXISTS `ms_permission`;
CREATE TABLE `ms_permission`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_permission
-- ----------------------------
INSERT INTO `ms_permission` VALUES (1, '查询权限列表', '/admin/permission/permissionList', '查询权限列表');
INSERT INTO `ms_permission` VALUES (2, '修改权限', '/admin/permission/update', '修改权限');
INSERT INTO `ms_permission` VALUES (4, '删除权限', '/admin/permission/delete', '删除权限');
INSERT INTO `ms_permission` VALUES (9, '增加权限', '/admin/permission/add', '增加权限');

-- ----------------------------
-- Table structure for ys_article
-- ----------------------------
DROP TABLE IF EXISTS `ys_article`;
CREATE TABLE `ys_article`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `comment_counts` int(11) NULL DEFAULT NULL COMMENT '评论数量',
  `create_date` bigint(20) NULL DEFAULT NULL COMMENT '创建时间',
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '简介',
  `title` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `view_counts` int(11) NULL DEFAULT NULL COMMENT '浏览数量',
  `weight` int(11) NOT NULL COMMENT '是否置顶',
  `author_id` bigint(20) NULL DEFAULT NULL COMMENT '作者id',
  `body_id` bigint(20) NULL DEFAULT NULL COMMENT '内容id',
  `category_id` int(11) NULL DEFAULT NULL COMMENT '类别id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1548946029380468739 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ys_article
-- ----------------------------
INSERT INTO `ys_article` VALUES (1548665638056673281, 0, 1646278408310, '总结vue 需要掌握的知识点', '总结vue 需要掌握的知识点', 8, 0, 1, 1548665638107004930, 1);
INSERT INTO `ys_article` VALUES (1548666154505519106, 0, 1647401738310, 'cookie、session、tooken', 'cookie、session、tooken', 4, 0, 1, 1548666154572627971, 2);
INSERT INTO `ys_article` VALUES (1548666437348409346, 0, 1648266518313, 'nginx 配置~~~本身就是一个静态资源的服务器', 'nginx 配置~~~本身就是一个静态资源的服务器', 6, 0, 1, 1548666437348409348, 6);
INSERT INTO `ys_article` VALUES (1548667513564872705, 0, 1649771318314, '云服务器的安全设置常识', '云服务器的安全设置常识', 2, 0, 1, 1548667513564872707, 6);
INSERT INTO `ys_article` VALUES (1548673409732886530, 0, 1650811718315, 'docker 映射端口穿透内置防火墙', 'docker 映射端口穿透内置防火墙', 2, 0, 1, 1548673409732886532, 2);
INSERT INTO `ys_article` VALUES (1548674022449397761, 0, 1651420538317, '设计模式之代理模式', '设计模式之代理模式', 4, 0, 1, 1548674022520700930, 2);
INSERT INTO `ys_article` VALUES (1548676806338985985, 0, 1651593038318, '关于我', '关于我', 7, 0, 1, 1548676806338985987, 7);
INSERT INTO `ys_article` VALUES (1548683933157736450, 0, 1651935038312, '设计模式之---工厂模式、建造者模式', '设计模式之---工厂模式、建造者模式', 12, 0, 1, 1548683933224845314, 2);
INSERT INTO `ys_article` VALUES (1548688984169299969, 0, 1652622698311, 'typora 基本使用和更换typora的主题样式', 'typora 基本使用和更换typora的主题样式', 1, 0, 1, 1548688984236408833, 7);
INSERT INTO `ys_article` VALUES (1548689573435457538, 0, 1653223898301, '设计模式之---单例模式', '设计模式之---单例模式', 3, 0, 1, 1548689573502566402, 2);
INSERT INTO `ys_article` VALUES (1548691213995524097, 0, 1655725898300, '学习Linux须知1.0之Linux相关概念、工具(yum、vim）、防火墙等', '学习Linux须知1.0之Linux相关概念', 2, 0, 1, 1548691214062632963, 7);
INSERT INTO `ys_article` VALUES (1548692795239743489, 0, 1656247898300, 'Docker学习重点(9)~SpringBoot微服务打包成Docker镜像', 'SpringBoot微服务打包成Docker镜像', 1, 0, 1, 1548692795306852355, 2);
INSERT INTO `ys_article` VALUES (1548693912539414529, 0, 1656431480302, '卸载应用后，删除安装根目录下的所有文件，提示已在另一进程打开，在资源管理器进程中找不到该程序的解决', '卸载应用后，删除安装根目录下的所有文件，提示已在另一进程打开', 2, 0, 1, 1548693912602329089, 7);
INSERT INTO `ys_article` VALUES (1548695365349851138, 0, 1656510680302, '自学java一路以来，心血心得整理分享', '自学java一路以来，心血心得整理分享', 5, 0, 1, 1548695365416960005, 7);
INSERT INTO `ys_article` VALUES (1548698806591733762, 0, 1656683480302, '初入编程之门的个人建议1.0', '初入编程之门的个人建议1.0', 10, 0, 1, 1548698806667231234, 7);

-- ----------------------------
-- Table structure for ys_article_body
-- ----------------------------
DROP TABLE IF EXISTS `ys_article_body`;
CREATE TABLE `ys_article_body`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `content_html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `article_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1548946029393051651 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ys_article_body
-- ----------------------------
INSERT INTO `ys_article_body` VALUES (1548665638107004930, '<br/>\n\n> 使用的开发工具是webstorm，它是默认就安装好了vuejs插件，idea要使用的话，需要安装一下该插件\n\n<br/>\n\n\n## 一、快速搭建项目vue-cli 脚手架（Vue2.0）\n\n### 1、Vue CLI使用前提 –Node、 Webpack\n\n#### (1) 安装 nodejs并通过npm 安装 cnpm：\n\nhttps://www.cnblogs.com/shan333/p/15726428.html\n\n#### (2) 安装webpack（全局安装）：\n\n```bash\n# 不写版本号，默认是安装最新的版本号\ncnpm install webpack@3.6.0 -g   或    npm install webpack@3.6.0 -g\n```\n\n#### (3) 安装vue脚手架（vue-cli 版本是3.xx）：\n\n```bash\n# 不写版本号，默认是安装最新的版本号\ncnpm install @vue/cli -g        或    npm install @vue/cli -g\n```\n\n#### ● 通过拉取模板就可以使用2.x版本(vue-cli2、vue-cli3任你选)：\n\n```\nnpm install -g @vue/cli-init 或 cnpm install -g @vue/cli-init\n```\n\n<br/>\n\n### ■ 本地安装与全局安装区别： \n\n- 本地安装：仅将webpack安装在当前项目的node_modules目录中，仅对当前项目有效。\n- 全局安装：将webpack安装在本机，对所有项目有效，全局安装会锁定一个webpack版本，该版本可能不适用某个项目。全局安装需要添加 -g 参数。\n\n\n\n<br/><br/>\n\n\n\n### 2、初始化Vue-cli2项目、Vue-cli3项目：\n\n- 初始化Vue-cli2项目：\n\n~~~bash\nvue init webpack my-project\n~~~\n\n- 初始化Vue-cli3项目：\n\n~~~bash\nvue create my-project\n~~~\n\n> #####  runtime-compiler 和 runtime-only的选择：选 runtime-only\n\n<br/>\n\n### ■ Vue-cli2项目、Vue-cli3项目区别： \n\n仅仅只是vue-cli3会把node_modules 隐藏起来。\n\n开发好项目，上传代码时node_modules 是不用上传上去的，只需要在readme提醒别人通过 <font color=red>**npm install**</font> 命令即可在目录创建node_modules。\n\n\n\n\n<br/><br/>\n\n\n### 3、启动项目：\n\n- 启动项目前先打包，再启动：\n\n~~~bash\n# 打包命令\nnpm run build\n~~~\n\n- Vue-cli2项目：\n\n~~~bash\nnpm run dev\n~~~\n\n- Vue-cli3项目：\n\n~~~bash\nnpm run serve\n~~~\n\n\n\n<br/><br/><br/>\n\n\n\n## 二、vue的浏览器调试插件 vue-devtools\n\n- 像普通插件一样安装到浏览器即可\n\n\n<br/><br/><br/>\n\n\n## 三、vue 的基本使用\n\n■ 最简单的例子：\n\n~~~vue\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    .active{\n      color: goldenrod;\n    }\n  </style>\n</head>\n<body>\n    \n<div id=\"app\" >\n  <!--插值表达式 {{ }}-->\n  {{message}}\n  <!--事件监听：监听点击事件@click-->\n  <button @click=\"btnActive\">点击</button>\n  <!--属性绑定：样式绑定--> \n  <div :class=\"getClass()\">样式</div>\n</div>\n    \n</body>\n<script type=\"text/javascript\" src=\"../js/vue.min.js\"></script>\n<script>\n  let app = new Vue({\n    el: \'#app\',\n    data: {\n      message:\'切换颜色\',\n      isActive: true,\n      active: \'active\',\n    },\n    methods: {\n      btnActive() {\n        this.isActive = !this.isActive;\n      },\n      getClass () {\n        return this.active;\n      }\n    }\n      \n  });\n</script>\n\n</body>\n</html>\n~~~\n\n<br/>\n\n### 1、插值表达式 {{ }}\n\n-  将值插入到我们模板的内容当中\n\n### 2、双向绑定绑定 v-model \n\n### 3、v-if 条件选择\n\n- v-else\n\n- v-show 适合经常切换的\n\n### 4、v-for 循环\n\n### 5、样式绑定\n\n### <font color=red>6、属性绑定</font>\n\n- v-bind 常用的是语法糖的冒号：\n\n### <font color=red>7、事件绑定</font>\n\n- v-on 常用的是语法糖的@，经常使用的也是点击事件@click\n\n- 事件修饰符\n\n### 8、计算属性\n\n- 和普通methods 属性的区别是：它具有**缓存作用**\n\n### 9、插槽slot\n\n>\n>\n>在vue中看到$:代表使用但是是vue自身的属性或者是挂载到vue上的插件(比如route)的属性，目的是为了和咱自己定义的变量做一个区分\n>\n>安装插件命令：npm install （若失败，可以使用cnpm install）\n>\n>~~~bash\n># npm install --save 插件名\n># 安装路由\n>npm install vue-router --save\n># 安装vuex\n>npm install vuex --save\n>\n># 安装element-ui\n>npm i element-ui -S\n>\n># npm install\n># 安装axios\n>npm install axios\n>~~~\n>\n>- --save-dev 的话，安装到node_modules 目录中，并在devDependencies 节点下添加上依赖，-dev是在开发时需要用的，部署不需要，一般是一些打包压缩工具和一些格式转化工具\n\n\n\n<br/><br/><br/>\n\n\n\n## <font color=red>四、组件</font>\n\n### 1、什么是组件化\n\nVue的组件化设计思想借鉴了Java的面向对象思想。Java认为万物皆对象，**在Vue中，万物皆组件。**\n\n也就是说，在实际的vue项目中，以及使用了Vue框架的项目中，**Vue的对象都会以组件的形式出现，能被反复使用。**\n\n**要想实现组件化，需要在页面中注册组件。**\n\n关于注册的方式有两种，分别是**全局注册和本地注册**。\n\n\n<br/>\n\n\n### 2、注册\n\n全局注册和本地注册区别：\n\n全局注册可以在任何Vue根实例里面使用；而本地(局部)注册只能在绑定它的父组件中使用。\n\n<font color=red>一般项目中只有一个Vue根实例(全局注册)，其他组件都是局部注册的。</font>\n\n\n\n- 全局注册：\n\n~~~vue\n<div id=\"app\">\n    <grob></grob>\n</div>\n\n\n<script>\n// 注册\nVue.component(\'grob\', {\n  template: \'<h1>自定义组件!</h1>\'\n})\n// 创建根实例Vue\nnew Vue({\n  el: \'#app\'\n})\n</script>\n~~~\n\n- 本地(局部)组件\n\n~~~vue\n<div id=\"app\">\n    <localV></localV>\n</div>\n \n \n<script>\n// 注册\nvar Child = {\n  template: \'<h1>自定义组件!</h1>\'\n}\n \n// 创建根实例\nnew Vue({\n  el: \'#app\',\n  components: {\n    // <localV> 将只在父模板可用\n    \'localV\': Child\n  }\n})\n</script>\n~~~\n\n<br/>\n\n### 3、模板占位符 template\n\n#### (1) template 用于包裹元素，template 不会被渲染到页面上\n\n> template:每个组件文件中的根template，也就是最外层的template 只能有一个根元素，可以是div，也可以是其他元素。\n>\n> 即<font color=red>**组件模板只能有一个根元素（通常是一个div）！**</font>\n>\n> <font color=red>非根template没有限制，可以有多个。</font>\n\n\n![1b2b426fa18444528144f009ea7312d7.png](https://niu.yilele.site/34c5a9fc-4c6c-4a9d-852c-674dc65b03c3.png)\n\n\n\n\ntemplate用于创建单文件组件，实际上是一种原子化的设计，可以一次定义，然后在任何地方生成dom，如果有多个子元素，就违背了这种原子设计，也就是说，一个template就只会渲染一个子组件树。\n\nvue在动态创建dom的时候，会将template中的子元素作为入口进行创建，根据这个入口，遍历以该子元素作为根节点的整个节点树，然后创建虚拟dom。\n\n如果template有多个子元素，那么vue就无法获取确切入口。\n\n<br/>\n\n#### (2) template作用：\n\n**通过template，vue文件实现了结构的分层 html视图层、css样式层、js层**\n\n- 举例 Home.vue 文件：\n\n~~~vue\n<template>\n  <div id=\"home\">\n    <el-container>\n    	<base-header :activeIndex=\"activeIndex\"></base-header>\n		<router-view class=\"me-container\"/>\n		<base-footer v-show=\"footerShow\"></base-footer>\n	</el-container>\n  </div>\n</template>\n\n<script>\nimport BaseFooter from \'@/components/BaseFooter\'\nimport BaseHeader from \'@/views/BaseHeader\'\n\nexport default {\n  name: \'Home\',\n  data (){\n  	return {\n  			activeIndex: \'/\',\n  			footerShow:true\n  	}\n  },\n  components:{\n  	\'base-header\':BaseHeader,\n  	\'base-footer\':BaseFooter\n  },\n  beforeRouteEnter (to, from, next){\n  	 next(vm => {\n    	vm.activeIndex = to.path\n  	})\n  },\n  beforeRouteUpdate (to, from, next) {\n	  if(to.path == \'/\'){\n	  	this.footerShow = true\n	  }else{\n	  	this.footerShow = false\n	  }\n	  this.activeIndex = to.path\n	  next()\n	}\n}\n</script>\n\n<style>\n.me-container{\n  margin: 100px auto 140px;\n}\n</style>\n~~~\n\n\n\n<br/><br/>\n\n\n\n### 4、组件的生命周期\n\n#### (1) 钩子函数\n\nVue中的组件是有生命周期的。每个生命阶段会有相应的生命周期钩子函数被调用。\n\n在vue中分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。\n\n<br/>\n\n#### (2) Vue生命周期函数使用场景\n\n- beforeCreate （使用频率低）\n  \\* 在实例创建以前调用\n  \\* 没有实例化，数据访问不到\n\n <br/> \n\n★ **<font color=red>created （使用频率高）</font>** <font color=blue>初始化数据</font>】\n\n> 此时状态：Vue里的**数据在内存中**已经创建完毕，但是还没有渲染到页面上。\n> 可做操作：从服务器获取一些初始化的数据，或者通过ajax向服务器发送一些数据。\n\n**<font color=red>进行ajax请求异步数据的获取(发送请求，访问后端接口拿数据)，初始化数据</font>** \n\n\\* 实例被创建完成后调用\n\n\\* 能拿到数据，能修改数据，\n\n\\* 且修改数据不会触发updated beforeUpdate钩子函数\n\n\\* 可以在这个钩子函数里发请求，访问后端接口拿数据\n\n\\* 判断是否存在el，是否存在template，如果二者都有，以template为主优先， 如果 没有template,会选择el模板。\n如果二者都没有，有$mount 也可以调用模板\n\n\n\n- beforeMount(载入前)\n\n  \\* **编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。**\n\n  \\* 真实的dom节点挂载到页面之前\n  \\* 编译模板已经结束，**虚拟dom已经存在**，\n  \\* 可以访问数据，也可以更改数据\n  \\* 且修改数据不会触发updated beforeUpdate钩子函数\n\n  \n\n★ **<font color=red> mounted（载入后）</font>** 【<font color=blue>获取dom节点、修改更新数据</font>】\n\n> 此时状态： **数据**已经渲染在了**浏览器的页面**上。\n> 可做操作：操作DOM节点\n\n**<font color=red>可以对挂载元素的dom节点进行获取，也可以访问后端接口拿数据，修改更新数据，触发更新钩子函数</font>**\n\n\\* 真实的dom节点挂载到页面以后\n\n~~~vue\n<!--this.$refs找到ref表示的节点-->\n<button id=\"firstBtn\" @click=\"testClick()\" ref=\"aa\">{{testMsg}}</button>\n\n<!--js层-->\nvar value = this.$refs.aa.innerText\n~~~\n\n\\* 可以访问和更改数据\n\\* 且修改数据会触发更新钩子函数\n\n\n\n- beforeUpdate（更新前）\n\n\\* 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。\n\n\n\n- updated（更新后）\n\n\\* 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。\n\n\\* 然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。\n\n\n\n★ <font color=red> beforeDestroy（销毁前）</font> 【<font color=blue>移除定时器或者移除事件绑定</font>】\n\n> 此时状态：奄奄一息。\n> 可做操作：移除定时器或者移除事件绑定。但是销毁的时候需要手动销毁.\n\n\n\n- destroyed（销毁后）\n\n\\* 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。\n\n\n<br/>\n \n\n#### (3) 总结 Vue 生命周期常用的构子函数以及其他常用函数\n\n★ **<font color=red>created （使用频率高）</font>** <font color=blue>初始化数据</font>】\n\n   **<font color=red>进行ajax请求异步数据的获取(发送请求，访问后端接口拿数据)，初始化数据</font>** \n\n★ **<font color=red>mounted（载入后）</font>** 【<font color=blue>获取dom节点、修改更新数据</font>】\n\n  **<font color=red>可以对挂载元素的dom节点进行获取，也可以访问后端接口拿数据，修改更新数据，触发更新钩子函数</font>**\n\n★ **updated**\n\n   任何数据的更新，如果要做统一的业务逻辑处理\n\n★ **nextTick**\n\n   针对单一事件更新数据后立即操作dom \n\n- 由于Vue的异步更新策略导致我们对数据的修改不会立马体现到都没变化上，此时如果想要立即获取更新后的dom的状态，就需要使用nextTick方法\n\n★ **watch** \n\n监听数据变化，并做相应的处理\n\n\n<br/><br/>\n\n\n### 5、父组件和子组件（组件通信）\n\n#### (1) 父组件向子组件传参---<font color=blue>通过props 声明属性</font>\n\n<font color=red>**在子组件(当前组件)中通过props声明属性，然后调用者(父组件)可以设置属性。**</font>\n\n- 子组件 Header.vue\n\n~~~vue\n<template>\n  <div>\n    <h1>{{title}}</h1>\n  </div>\n</template>\n\n<script>\n  export default {\n    name:\"Header\",\n    /* 当前组件声明的属性，调用者可以设置属性 */\n    props:[\"MyTitle\"],\n    data(){\n      return{\n        title:\'header 页面头\'\n      }\n    }\n  }\n</script>\n~~~\n\n- 父组件 App.vue\n\n~~~vue\n<template>\n  <div id=\"app\">\n    <!-- 在父组件调用子组件声明的属性(设置属性) -->\n    <Header :my-title=\"title\"/>\n  </div>\n</template>\n\n<script>\n//1、引入子组件\nimport Header from \"./components/Header\";\n  export default {\n    name:\"App\",\n    data(){\n      return{\n        title:\'这是父组件传递给子组件的属性值\'\n      }\n    }\n  }\n</script>\n~~~\n\n<br/>\n\n#### (2) 子组件向父组件传参---<font color=blue>一般是通过emit 自定义事件传参</font>\n\n> ▪ emit方式【事件传参】：是通过emit自定义了一个事件，发送事件的同时传递参数；然后父组件监听自定义事件，回调函数获取到参数\n>\n> ▪ props方式【回调传参】：是通过在props声明函数类型的属性，然后在子组件上监听事件回调传递参数，再在父组件设置属性，属性值是回调函数，此时回调函数获取到参数。\n\n<br/>\n\n##### ■ 事件传参：通过emit 自定义事件，然后在父组件监听自定义事件，然后回调函数获取参数\n\n- 子组件 Header.vue\n\n~~~vue\n<template>\n  <div>\n    <button @click=\"btnClick\">子组件</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    name:\"Header\",\n    methods:{\n      btnClick(){\n        //子组件自定义事件bClick，并传递参数 params 给父组件  \n   		this.$emit(\"bClick\", \"params\");\n      }\n    }\n  }\n</script>\n~~~\n\n- 父组件 App.vue\n\n~~~vue\n<template>\n  <div id=\"app\">\n    <!-- 在父组件监听子组件自定义的事件bClick，然后通过回调函数bbClick获取参数 -->\n    <Header @bClick=bbClick/>\n  </div>\n</template>\n\n<script>\n//1、引入子组件\nimport Header from \"./components/Header\";\n  export default {\n    name:\"App\",\n    methods:{\n      bbClick(value){\n         console.log(\'父组件监听到子组件发出的事件和接收到子组件的数据\' + value);\n      }\n    }\n  }\n</script>\n~~~\n\n<br/>\n\n##### ■ 通过props 声明属性是函数类型，然后子组件监听事件，回调传参；父组件设置属性，属性值是回调函数，在回调函数获取子组件传递的参数\n\n- 子组件 Header.vue\n\n~~~vue\n<template>\n  <div>\n    <h1>子组件</h1>\n    <!-- 子组件监听事件，回调传参 --> \n    <button @click=\"changeTitle(\'标题\')\">子组件</button> \n  </div>\n</template>\n\n<script>\n  export default {\n    name:\"Header\",\n    /* 当前组件声明的属性(函数类型)，调用者设置属性 */\n    props:[\"changeTitle\"],\n    data(){\n      return{\n        title:\'header 页面头\'\n      }\n    }\n  }\n</script>\n~~~\n\n- 父组件 App.vue\n\n~~~vue\n<template>\n  <div id=\"app\">\n    <!-- 在父组件调用子组件声明的属性(设置属性)，属性值是一个函数，在回调函数获取从子组件传递的参数 -->\n    <Header :change-title=\"myTitle\"/>\n  </div>\n</template>\n\n<script>\n//1、引入子组件\nimport Header from \"./components/Header\";\n  export default {\n    name:\"App\",\n    methods: {\n     myTitle(value){\n        console.log(value);\n      }\n    }\n  }\n</script>\n~~~\n\n<br/>\n\n> 父子组件通信(父子组件的参数传递)是属于在同一个页面的参数传递。和路由传参不同，路由传参是通过url的参数进行传参，在不同页面的参数传递。\n\n\n\n\n\n<br/><br/>\n\n\n\n> 第三方插件：vue-route、vuex、axios、element-ui 在vue中使用思路：\n>\n> 1、通过**npm istall** 插件名 命令添加到node_modules，并添加到dependencies依赖下(在package.json 可以看到)\n>\n> 2、(第三方的东西一般会创建一个文件进行封装) **创建插件对象，然后导出**\n>\n> - 通过Vue的use方法安装插件\n>\n> 3、在项目的main.js 中引入插件对象，然后挂载到vue实例对象\n>\n> > 对于element-ui 样式布局插件，不用抽离单独封装成一个文件，直接在项目的mian.js 中使用Vue的use方法安装插件，然后就可以直接使用了，不用挂载到Vue实例上。\n\n\n<br/><br/><br/>\n\n\n## 五、vue-route\n\n### 1、引入路由模块并使用\n\n- 路由对象\n\n~~~js\n// 1. 定义路由组件.\n// 也可以从其他文件导入\nconst Home = { template: \'<div>Home</div>\' }\nconst About = { template: \'<div>About</div>\' }\n\n// 2. 定义一些路由\n// 每个路由都需要映射到一个组件。\n// 我们后面再讨论嵌套路由。\nconst routes = [\n  { path: \'/\', component: Home },\n  { path: \'/about\', component: About },\n]\n\n// 3. 创建路由实例并传递 `routes` 配置\n// 你可以在这里输入更多的配置，但我们在这里\n// 暂时保持简单\nconst router = VueRouter.createRouter({\n  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。\n  history: VueRouter.createWebHashHistory(),\n  routes, // `routes: routes` 的缩写\n})\n\nexport default router\n~~~\n\n- 在main.js 中引入路由模块并使用（挂载路由）\n\n~~~js\nimport Vue from \'vue\'\nimport App from \'./App\'\n\nimport router from \'./router\'\nnew Vue({\n  el: \'#app\',\n  router,//使用路由模块\n  template: \'<App/>\',\n  components: { App }\n})\n~~~\n\n- 路由体验：<router-view/>\n\n~~~vue\n<template>\n  <div id=\"app\">\n     <!--使用 router-link 组件进行导航 -->\n   	 <!--通过传递 `to` 来指定链接 -->\n   	 <!--`<router-link>` 将呈现一个带有正确 `href` 属性的 `<a>` 标签-->\n   	 <router-link to=\"/\">Go to Home</router-link>\n   	 <router-link to=\"/about\">Go to About</router-link>\n    \n     <!-- 路由出口 -->\n 	 <!-- 路由匹配到的组件将渲染在这里 -->\n  	 <router-view></router-view>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'App\',\n}\n</script>\n~~~\n\n\n\n- 改变url，发现＜router-view＞＜／router-view＞中的内容发生改变\n\nhttp://localhost:8080/#/    显示home\n\nhttp://localhost:8080/about  显示About\n\n- 向router实例中添加mode属性：路由的两种模式 \n\n   值＂hash＂：url带＃适用于调试模式\n\n   值＂history＂：url不带＃ \n\n\n<br/>\n\n\n### 2、路由传参\n\n#### (1) 通过 params 获取参数的方式[动态路由]\n\n① 路由path中声明参数\n\n② <route-link />的to属性传参\n\n③ 在模块组件中接收参数 $route.params \n\n\n\n~~~js\n// 路由path中声明参数,用于接收route-link 中传来的参数\nconst routes = [\n  // 动态字段以冒号开始\n  { path: \'/about/:id\', component: User },\n]\n~~~\n\n~~~vue\n<!-- App.vue 父模块 -->\n\n<!-- <route-link />的to属性传参 -->\n<template>\n  <div id=\"app\">\n     <!-- 使用 router-link 的to属性传递参数 -->\n   	 <router-link to=\"/about/1\">Go to About</router-link>\n    \n     <!-- 路由出口 -->\n  	 <router-view></router-view>\n  </div>\n</template>\n~~~\n\n~~~vue\n<!-- About.vue 父模块 -->\n\n<!-- 在模块组件中接收参数 $route.params -->\n<template>\n  <div> <!--在template中直接接收参数-->  \n  	<h2>{{$route.params.id}}</h2>\n  	<h1>{{id}}</h>\n  </div>\n</template>\n<script>\n  export default {\n  name: \'About\',\n  data(){\n	return {\n    	id: this.$route.params.id //在js中接收参数    \n    }    \n}    \n</script>    \n~~~\n\n<br/>\n\n#### (2) 通过 quary 获取参数的方式\n\n① <route-link />的to属性传参\n\n② 在模块组件中接收参数 $route.query\n\n~~~vue\n<!-- App.vue 父模块 -->\n\n <!-- <route-link />的to属性传参 -->\n<template>\n  <div id=\"app\">      \n     <!-- 使用 router-link 的to属性传递参数 -->\n   	 <router-link to=\"/about?id=1\">Go to About</router-link>\n    \n     <!-- 路由出口 -->\n  	 <router-view></router-view>\n  </div>\n</template>\n~~~\n\n~~~vue\n<!-- About.vue 父模块 --> \n\n<!-- <route-link />的to属性传参 -->\n<template>\n  <div>\n     <!--在template中直接接收参数-->  \n   	<h2>{{$route.query.id}}</h2>\n  	<h1>{{id}}</h>\n  </div>\n</template>\n\n<script>\n  export default {\n  name: \'App\',\n  data(){\n	return {\n    	id: this.$route.query.id //在js中接收参数    \n    }    \n}    \n</script>  \n~~~\n\n\n<br/>\n\n\n### 3、&lt;route-link />的to属性\n\n- to可以接收一个对象，对象的属性有parmas，也有query\n\n~~~vue\n<route-link to=\"{\n		path:\'/aboout/123\', \n		query:{name:\'shan\', age:18}\n	       }\" />\n~~~\n\n<br/>\n\n##### ■ 补充一个常识，浏览器你看到地址url，其实是包括 path，和查询条件query\n\nhttp://localhost:8080/about/123?name=shan&age=18\n\npath：/about/123 \n\nquery：是指从?开始的查看条件 ?name=shan&age=18，多个查询条件使用&隔开(除了第一个查询条件使用?)\n\n\n\n<br/>\n\n### 4、总结路由传参 parmas 和 query\n\n> - 传递参数主要有两种类型: params 和 query\n\n- 主要是写法格式不同，query是传统的传参方式，以?开始，而params(path 传参方式)，其实是一种restful风格的传参方式[写法更整齐简洁]\n- 两者传参方式没有好坏之分\n- 需要注意的是params需要预定义声明参数，即**在路由配置中定义 用冒号的形式标记**\n\n\n\n\n<br/><br/><br/>\n\n\n\n\n## 六、axios\n\n### 1、axios 是什么？\n\nAxios 是一个**基于 Promise 的 HTTP 库（网络请求库）**，可以作用于浏览器和 node.js \n\n### 2、安装（npm安装方式）：\n\n```bash\nnpm install axios\n```\n\n### 3、 axios网络模块过程:\n\n(1）axios创建实例（**全局配置/基本配置**）\n\n(2) 发送请求\n\n(3) axios拦截器的使用\n\n~~~js\nimport axios from \'axios\'\n \nexport function request(config) {\n  // 1.创建axios的实例（全局配置/基本配置）\n  const service = axios.create({\n    baseURL: \'http://123.207.32.32:8000\',//还可以将baseURL的值抽取出去 baseURL: process.env.BASE_API,\n    timeout: 5000\n  })\n \n  // 2.axios的拦截器\n  // 2.1.请求拦截的作用\n  service.interceptors.request.use(config => {\n    // console.log(config);\n    // 1.比如config中的一些信息不符合服务器的要求\n \n    // 2.比如每次发送网络请求时, 都希望在界面中显示一个请求的图标\n \n    // 3.某些网络请求(比如登录(token)), 必须携带一些特殊的信息\n    return config\n  }, err => {\n    // console.log(err);\n  })\n \n  // 2.2.响应拦截\n  service.interceptors.response.use(res => {\n    // console.log(res);\n    return res.data\n  }, err => {\n    console.log(err);\n  })\n \n  // 3.发送真正的网络请求\n  return service(config)\n}\n~~~\n\n- 针对模块组件封装成具体方法发送请求：\n\n~~~js\n// article.js \nimport request from \'@/request\'\n\nexport function getHotArtices() {\n  return request({\n    url: \'/articles/hot\',\n    method: \'post\'\n  })\n}\n\nexport function viewArticle(id) {\n  return request({\n    url: `/articles/view/${id}`,\n    method: \'post\'\n  })\n}\n.....\n~~~\n\n\n\n\n<br/><br/><br/>\n\n\n\n\n## 七、Vuex状态管理\n\n- 后端对应的web是使用session管理状态\n\n~~~js\nimport Vue from \'vue\'\nimport Vuex from \'vuex\'\n\nVue.use(Vuex)\n\n// 定义状态对象state,保存数据的仓库\nconst state={\n    //组件模块调用state中的属性：this.$store.state.getUserInfo\n    userInfo:{\n        id:\'\',\n        name:\'\'\n    }\n}\n//相对于java对象的get方法\nconst getters={\n    //组件模块调用getter中的方法：this.$store.getters.getUserInfo\n    getUserInfo(state){\n        return state.userInfo;\n    }\n}\n//相当于java的set方法的mutations(同步执行)和 actions(异步执行)\nconst mutations ={\n    //组件模块调用mutations中的方法：this.$store.commit(\'updateUserInfo\', userInfo) 通过提交commit\n    updateUserInfo(state, userInfo){\n        state.userInfo = userInfo;\n    }\n}\nconst actions ={\n    //组件模块调用actions中的方法：this.$store.dispatch(\'asyncUpdateUserInfo\', userInfo) 通过分发dispatch\n    asyncUpdateUserInfo(context, userInfo){\n        context.commit(\'updateUserInfo\', userInfo);//最终还是调用同步的mutations中的方法\n    }\n}\n\nexport default new Vuex({\n    state,\n    getters,\n    mutations,\n    actions\n});\n~~~\n\n\n\n<br/><br/><br/>\n\n\n\n## 八、element-ui\n\n- element-ui 和 bootstrap类似，都是做为样式组件的\n\n<br/>\n\n### 1、引入 Element（完整引入）\n\n- 在 main.js 中写入以下内容\n\n~~~js\nimport Vue from \'vue\';\nimport ElementUI from \'element-ui\';\nimport \'element-ui/lib/theme-chalk/index.css\';\nimport App from \'./App.vue\';\n\nVue.use(ElementUI);\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App)\n});\n~~~\n\n<br/>\n\n### 2、Layout 布局\n\n- 需要什么组件就直接从官网提供的布局组件那里复制\n  - 官网地址 [组件 | Element](https://element.eleme.cn/#/zh-CN/component/layout)\n  \n  \n  \n<br/><br/>\n**如果本文对你有帮助的话记得给一乐点个赞哦，感谢！**', '<br/>\n<blockquote>\n<p>使用的开发工具是webstorm，它是默认就安装好了vuejs插件，idea要使用的话，需要安装一下该插件</p>\n</blockquote>\n<br/>\n<h2><a id=\"vuecli_Vue20_7\"></a>一、快速搭建项目vue-cli 脚手架（Vue2.0）</h2>\n<h3><a id=\"1Vue_CLI_Node_Webpack_9\"></a>1、Vue CLI使用前提 –Node、 Webpack</h3>\n<h4><a id=\"1__nodejsnpm__cnpm_11\"></a>(1) 安装 nodejs并通过npm 安装 cnpm：</h4>\n<p>https://www.cnblogs.com/shan333/p/15726428.html</p>\n<h4><a id=\"2_webpack_15\"></a>(2) 安装webpack（全局安装）：</h4>\n<pre><code class=\"lang-bash\"># 不写版本号，默认是安装最新的版本号\ncnpm install webpack@3.6.0 -g   或    npm install webpack@3.6.0 -g\n</code></pre>\n<h4><a id=\"3_vuevuecli_3xx_22\"></a>(3) 安装vue脚手架（vue-cli 版本是3.xx）：</h4>\n<pre><code class=\"lang-bash\"># 不写版本号，默认是安装最新的版本号\ncnpm install @vue/cli -g        或    npm install @vue/cli -g\n</code></pre>\n<h4><a id=\"_2xvuecli2vuecli3_29\"></a>● 通过拉取模板就可以使用2.x版本(vue-cli2、vue-cli3任你选)：</h4>\n<pre><code class=\"lang-\">npm install -g @vue/cli-init 或 cnpm install -g @vue/cli-init\n</code></pre>\n<br/>\n<h3><a id=\"__37\"></a>■ 本地安装与全局安装区别：</h3>\n<ul>\n<li>本地安装：仅将webpack安装在当前项目的node_modules目录中，仅对当前项目有效。</li>\n<li>全局安装：将webpack安装在本机，对所有项目有效，全局安装会锁定一个webpack版本，该版本可能不适用某个项目。全局安装需要添加 -g 参数。</li>\n</ul>\n<p><br/><br/></p>\n<h3><a id=\"2Vuecli2Vuecli3_48\"></a>2、初始化Vue-cli2项目、Vue-cli3项目：</h3>\n<ul>\n<li>初始化Vue-cli2项目：</li>\n</ul>\n<pre><code class=\"lang-bash\">vue init webpack my-project\n</code></pre>\n<ul>\n<li>初始化Vue-cli3项目：</li>\n</ul>\n<pre><code class=\"lang-bash\">vue create my-project\n</code></pre>\n<blockquote>\n<h5><a id=\"runtimecompiler__runtimeonly_runtimeonly_62\"></a>runtime-compiler 和 runtime-only的选择：选 runtime-only</h5>\n</blockquote>\n<br/>\n<h3><a id=\"_Vuecli2Vuecli3_66\"></a>■ Vue-cli2项目、Vue-cli3项目区别：</h3>\n<p>仅仅只是vue-cli3会把node_modules 隐藏起来。</p>\n<p>开发好项目，上传代码时node_modules 是不用上传上去的，只需要在readme提醒别人通过 <font color=red><strong>npm install</strong></font> 命令即可在目录创建node_modules。</p>\n<p><br/><br/></p>\n<h3><a id=\"3_78\"></a>3、启动项目：</h3>\n<ul>\n<li>启动项目前先打包，再启动：</li>\n</ul>\n<pre><code class=\"lang-bash\"># 打包命令\nnpm run build\n</code></pre>\n<ul>\n<li>Vue-cli2项目：</li>\n</ul>\n<pre><code class=\"lang-bash\">npm run dev\n</code></pre>\n<ul>\n<li>Vue-cli3项目：</li>\n</ul>\n<pre><code class=\"lang-bash\">npm run serve\n</code></pre>\n<p><br/><br/><br/></p>\n<h2><a id=\"vue_vuedevtools_105\"></a>二、vue的浏览器调试插件 vue-devtools</h2>\n<ul>\n<li>像普通插件一样安装到浏览器即可</li>\n</ul>\n<p><br/><br/><br/></p>\n<h2><a id=\"vue__113\"></a>三、vue 的基本使用</h2>\n<p>■ 最简单的例子：</p>\n<pre><code class=\"lang-vue\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Title&lt;/title&gt;\n  &lt;style&gt;\n    .active{\n      color: goldenrod;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    \n&lt;div id=&quot;app&quot; &gt;\n  &lt;!--插值表达式 {{ }}--&gt;\n  {{message}}\n  &lt;!--事件监听：监听点击事件@click--&gt;\n  &lt;button @click=&quot;btnActive&quot;&gt;点击&lt;/button&gt;\n  &lt;!--属性绑定：样式绑定--&gt; \n  &lt;div :class=&quot;getClass()&quot;&gt;样式&lt;/div&gt;\n&lt;/div&gt;\n    \n&lt;/body&gt;\n&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  let app = new Vue({\n    el: \'#app\',\n    data: {\n      message:\'切换颜色\',\n      isActive: true,\n      active: \'active\',\n    },\n    methods: {\n      btnActive() {\n        this.isActive = !this.isActive;\n      },\n      getClass () {\n        return this.active;\n      }\n    }\n      \n  });\n&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<br/>\n<h3><a id=\"1___168\"></a>1、插值表达式 {{ }}</h3>\n<ul>\n<li>将值插入到我们模板的内容当中</li>\n</ul>\n<h3><a id=\"2_vmodel_172\"></a>2、双向绑定绑定 v-model</h3>\n<h3><a id=\"3vif__174\"></a>3、v-if 条件选择</h3>\n<ul>\n<li>\n<p>v-else</p>\n</li>\n<li>\n<p>v-show 适合经常切换的</p>\n</li>\n</ul>\n<h3><a id=\"4vfor__180\"></a>4、v-for 循环</h3>\n<h3><a id=\"5_182\"></a>5、样式绑定</h3>\n<h3><a id=\"font_colorred6font_184\"></a><font color=red>6、属性绑定</font></h3>\n<ul>\n<li>v-bind 常用的是语法糖的冒号：</li>\n</ul>\n<h3><a id=\"font_colorred7font_188\"></a><font color=red>7、事件绑定</font></h3>\n<ul>\n<li>\n<p>v-on 常用的是语法糖的@，经常使用的也是点击事件@click</p>\n</li>\n<li>\n<p>事件修饰符</p>\n</li>\n</ul>\n<h3><a id=\"8_194\"></a>8、计算属性</h3>\n<ul>\n<li>和普通methods 属性的区别是：它具有<strong>缓存作用</strong></li>\n</ul>\n<h3><a id=\"9slot_198\"></a>9、插槽slot</h3>\n<blockquote>\n<p>在vue中看到$:代表使用但是是vue自身的属性或者是挂载到vue上的插件(比如route)的属性，目的是为了和咱自己定义的变量做一个区分</p>\n<p>安装插件命令：npm install （若失败，可以使用cnpm install）</p>\n<pre><code class=\"lang-bash\"># npm install --save 插件名\n# 安装路由\nnpm install vue-router --save\n# 安装vuex\nnpm install vuex --save\n\n# 安装element-ui\nnpm i element-ui -S\n\n# npm install\n# 安装axios\nnpm install axios\n</code></pre>\n<ul>\n<li>–save-dev 的话，安装到node_modules 目录中，并在devDependencies 节点下添加上依赖，-dev是在开发时需要用的，部署不需要，一般是一些打包压缩工具和一些格式转化工具</li>\n</ul>\n</blockquote>\n<p><br/><br/><br/></p>\n<h2><a id=\"font_colorredfont_229\"></a><font color=red>四、组件</font></h2>\n<h3><a id=\"1_231\"></a>1、什么是组件化</h3>\n<p>Vue的组件化设计思想借鉴了Java的面向对象思想。Java认为万物皆对象，<strong>在Vue中，万物皆组件。</strong></p>\n<p>也就是说，在实际的vue项目中，以及使用了Vue框架的项目中，<strong>Vue的对象都会以组件的形式出现，能被反复使用。</strong></p>\n<p><strong>要想实现组件化，需要在页面中注册组件。</strong></p>\n<p>关于注册的方式有两种，分别是<strong>全局注册和本地注册</strong>。</p>\n<br/>\n<h3><a id=\"2_245\"></a>2、注册</h3>\n<p>全局注册和本地注册区别：</p>\n<p>全局注册可以在任何Vue根实例里面使用；而本地(局部)注册只能在绑定它的父组件中使用。</p>\n<p><font color=red>一般项目中只有一个Vue根实例(全局注册)，其他组件都是局部注册的。</font></p>\n<ul>\n<li>全局注册：</li>\n</ul>\n<pre><code class=\"lang-vue\">&lt;div id=&quot;app&quot;&gt;\n    &lt;grob&gt;&lt;/grob&gt;\n&lt;/div&gt;\n\n\n&lt;script&gt;\n// 注册\nVue.component(\'grob\', {\n  template: \'&lt;h1&gt;自定义组件!&lt;/h1&gt;\'\n})\n// 创建根实例Vue\nnew Vue({\n  el: \'#app\'\n})\n&lt;/script&gt;\n</code></pre>\n<ul>\n<li>本地(局部)组件</li>\n</ul>\n<pre><code class=\"lang-vue\">&lt;div id=&quot;app&quot;&gt;\n    &lt;localV&gt;&lt;/localV&gt;\n&lt;/div&gt;\n \n \n&lt;script&gt;\n// 注册\nvar Child = {\n  template: \'&lt;h1&gt;自定义组件!&lt;/h1&gt;\'\n}\n \n// 创建根实例\nnew Vue({\n  el: \'#app\',\n  components: {\n    // &lt;localV&gt; 将只在父模板可用\n    \'localV\': Child\n  }\n})\n&lt;/script&gt;\n</code></pre>\n<br/>\n<h3><a id=\"3_template_302\"></a>3、模板占位符 template</h3>\n<h4><a id=\"1_template_template__304\"></a>(1) template 用于包裹元素，template 不会被渲染到页面上</h4>\n<blockquote>\n<p>template:每个组件文件中的根template，也就是最外层的template 只能有一个根元素，可以是div，也可以是其他元素。</p>\n<p>即<font color=red><strong>组件模板只能有一个根元素（通常是一个div）！</strong></font></p>\n<p><font color=red>非根template没有限制，可以有多个。</font></p>\n</blockquote>\n<p><img src=\"https://niu.yilele.site/34c5a9fc-4c6c-4a9d-852c-674dc65b03c3.png\" alt=\"1b2b426fa18444528144f009ea7312d7.png\" /></p>\n<p>template用于创建单文件组件，实际上是一种原子化的设计，可以一次定义，然后在任何地方生成dom，如果有多个子元素，就违背了这种原子设计，也就是说，一个template就只会渲染一个子组件树。</p>\n<p>vue在动态创建dom的时候，会将template中的子元素作为入口进行创建，根据这个入口，遍历以该子元素作为根节点的整个节点树，然后创建虚拟dom。</p>\n<p>如果template有多个子元素，那么vue就无法获取确切入口。</p>\n<br/>\n<h4><a id=\"2_template_326\"></a>(2) template作用：</h4>\n<p><strong>通过template，vue文件实现了结构的分层 html视图层、css样式层、js层</strong></p>\n<ul>\n<li>举例 Home.vue 文件：</li>\n</ul>\n<pre><code class=\"lang-vue\">&lt;template&gt;\n  &lt;div id=&quot;home&quot;&gt;\n    &lt;el-container&gt;\n    	&lt;base-header :activeIndex=&quot;activeIndex&quot;&gt;&lt;/base-header&gt;\n		&lt;router-view class=&quot;me-container&quot;/&gt;\n		&lt;base-footer v-show=&quot;footerShow&quot;&gt;&lt;/base-footer&gt;\n	&lt;/el-container&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport BaseFooter from \'@/components/BaseFooter\'\nimport BaseHeader from \'@/views/BaseHeader\'\n\nexport default {\n  name: \'Home\',\n  data (){\n  	return {\n  			activeIndex: \'/\',\n  			footerShow:true\n  	}\n  },\n  components:{\n  	\'base-header\':BaseHeader,\n  	\'base-footer\':BaseFooter\n  },\n  beforeRouteEnter (to, from, next){\n  	 next(vm =&gt; {\n    	vm.activeIndex = to.path\n  	})\n  },\n  beforeRouteUpdate (to, from, next) {\n	  if(to.path == \'/\'){\n	  	this.footerShow = true\n	  }else{\n	  	this.footerShow = false\n	  }\n	  this.activeIndex = to.path\n	  next()\n	}\n}\n&lt;/script&gt;\n\n&lt;style&gt;\n.me-container{\n  margin: 100px auto 140px;\n}\n&lt;/style&gt;\n</code></pre>\n<p><br/><br/></p>\n<h3><a id=\"4_389\"></a>4、组件的生命周期</h3>\n<h4><a id=\"1__391\"></a>(1) 钩子函数</h4>\n<p>Vue中的组件是有生命周期的。每个生命阶段会有相应的生命周期钩子函数被调用。</p>\n<p>在vue中分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。</p>\n<br/>\n<h4><a id=\"2_Vue_399\"></a>(2) Vue生命周期函数使用场景</h4>\n<ul>\n<li>beforeCreate （使用频率低）<br />\n* 在实例创建以前调用<br />\n* 没有实例化，数据访问不到</li>\n</ul>\n <br/> \n<p>★ <strong><font color=red>created （使用频率高）</font></strong> <font color=blue>初始化数据</font>】</p>\n<blockquote>\n<p>此时状态：Vue里的<strong>数据在内存中</strong>已经创建完毕，但是还没有渲染到页面上。<br />\n可做操作：从服务器获取一些初始化的数据，或者通过ajax向服务器发送一些数据。</p>\n</blockquote>\n<p><strong><font color=red>进行ajax请求异步数据的获取(发送请求，访问后端接口拿数据)，初始化数据</font></strong></p>\n<p>* 实例被创建完成后调用</p>\n<p>* 能拿到数据，能修改数据，</p>\n<p>* 且修改数据不会触发updated beforeUpdate钩子函数</p>\n<p>* 可以在这个钩子函数里发请求，访问后端接口拿数据</p>\n<p>* 判断是否存在el，是否存在template，如果二者都有，以template为主优先， 如果 没有template,会选择el模板。<br />\n如果二者都没有，有$mount 也可以调用模板</p>\n<ul>\n<li>\n<p>beforeMount(载入前)</p>\n<p>* <strong>编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</strong></p>\n<p>* 真实的dom节点挂载到页面之前<br />\n* 编译模板已经结束，<strong>虚拟dom已经存在</strong>，<br />\n* 可以访问数据，也可以更改数据<br />\n* 且修改数据不会触发updated beforeUpdate钩子函数</p>\n</li>\n</ul>\n<p>★ <strong><font color=red> mounted（载入后）</font></strong> 【<font color=blue>获取dom节点、修改更新数据</font>】</p>\n<blockquote>\n<p>此时状态： <strong>数据</strong>已经渲染在了<strong>浏览器的页面</strong>上。<br />\n可做操作：操作DOM节点</p>\n</blockquote>\n<p><strong><font color=red>可以对挂载元素的dom节点进行获取，也可以访问后端接口拿数据，修改更新数据，触发更新钩子函数</font></strong></p>\n<p>* 真实的dom节点挂载到页面以后</p>\n<pre><code class=\"lang-vue\">&lt;!--this.$refs找到ref表示的节点--&gt;\n&lt;button id=&quot;firstBtn&quot; @click=&quot;testClick()&quot; ref=&quot;aa&quot;&gt;{{testMsg}}&lt;/button&gt;\n\n&lt;!--js层--&gt;\nvar value = this.$refs.aa.innerText\n</code></pre>\n<p>* 可以访问和更改数据<br />\n* 且修改数据会触发更新钩子函数</p>\n<ul>\n<li>beforeUpdate（更新前）</li>\n</ul>\n<p>* 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</p>\n<ul>\n<li>updated（更新后）</li>\n</ul>\n<p>* 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。</p>\n<p>* 然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</p>\n<p>★ <font color=red> beforeDestroy（销毁前）</font> 【<font color=blue>移除定时器或者移除事件绑定</font>】</p>\n<blockquote>\n<p>此时状态：奄奄一息。<br />\n可做操作：移除定时器或者移除事件绑定。但是销毁的时候需要手动销毁.</p>\n</blockquote>\n<ul>\n<li>destroyed（销毁后）</li>\n</ul>\n<p>* 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p>\n<br/>\n<h4><a id=\"3__Vue__489\"></a>(3) 总结 Vue 生命周期常用的构子函数以及其他常用函数</h4>\n<p>★ <strong><font color=red>created （使用频率高）</font></strong> <font color=blue>初始化数据</font>】</p>\n<p><strong><font color=red>进行ajax请求异步数据的获取(发送请求，访问后端接口拿数据)，初始化数据</font></strong></p>\n<p>★ <strong><font color=red>mounted（载入后）</font></strong> 【<font color=blue>获取dom节点、修改更新数据</font>】</p>\n<p><strong><font color=red>可以对挂载元素的dom节点进行获取，也可以访问后端接口拿数据，修改更新数据，触发更新钩子函数</font></strong></p>\n<p>★ <strong>updated</strong></p>\n<p>任何数据的更新，如果要做统一的业务逻辑处理</p>\n<p>★ <strong>nextTick</strong></p>\n<p>针对单一事件更新数据后立即操作dom</p>\n<ul>\n<li>由于Vue的异步更新策略导致我们对数据的修改不会立马体现到都没变化上，此时如果想要立即获取更新后的dom的状态，就需要使用nextTick方法</li>\n</ul>\n<p>★ <strong>watch</strong></p>\n<p>监听数据变化，并做相应的处理</p>\n<p><br/><br/></p>\n<h3><a id=\"5_517\"></a>5、父组件和子组件（组件通信）</h3>\n<h4><a id=\"1_font_colorblueprops_font_519\"></a>(1) 父组件向子组件传参—<font color=blue>通过props 声明属性</font></h4>\n<p><font color=red><strong>在子组件(当前组件)中通过props声明属性，然后调用者(父组件)可以设置属性。</strong></font></p>\n<ul>\n<li>子组件 Header.vue</li>\n</ul>\n<pre><code class=\"lang-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;{{title}}&lt;/h1&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    name:&quot;Header&quot;,\n    /* 当前组件声明的属性，调用者可以设置属性 */\n    props:[&quot;MyTitle&quot;],\n    data(){\n      return{\n        title:\'header 页面头\'\n      }\n    }\n  }\n&lt;/script&gt;\n</code></pre>\n<ul>\n<li>父组件 App.vue</li>\n</ul>\n<pre><code class=\"lang-vue\">&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;!-- 在父组件调用子组件声明的属性(设置属性) --&gt;\n    &lt;Header :my-title=&quot;title&quot;/&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n//1、引入子组件\nimport Header from &quot;./components/Header&quot;;\n  export default {\n    name:&quot;App&quot;,\n    data(){\n      return{\n        title:\'这是父组件传递给子组件的属性值\'\n      }\n    }\n  }\n&lt;/script&gt;\n</code></pre>\n<br/>\n<h4><a id=\"2_font_colorblueemit_font_572\"></a>(2) 子组件向父组件传参—<font color=blue>一般是通过emit 自定义事件传参</font></h4>\n<blockquote>\n<p>▪ emit方式【事件传参】：是通过emit自定义了一个事件，发送事件的同时传递参数；然后父组件监听自定义事件，回调函数获取到参数</p>\n<p>▪ props方式【回调传参】：是通过在props声明函数类型的属性，然后在子组件上监听事件回调传递参数，再在父组件设置属性，属性值是回调函数，此时回调函数获取到参数。</p>\n</blockquote>\n<br/>\n<h5><a id=\"_emit__580\"></a>■ 事件传参：通过emit 自定义事件，然后在父组件监听自定义事件，然后回调函数获取参数</h5>\n<ul>\n<li>子组件 Header.vue</li>\n</ul>\n<pre><code class=\"lang-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=&quot;btnClick&quot;&gt;子组件&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    name:&quot;Header&quot;,\n    methods:{\n      btnClick(){\n        //子组件自定义事件bClick，并传递参数 params 给父组件  \n   		this.$emit(&quot;bClick&quot;, &quot;params&quot;);\n      }\n    }\n  }\n&lt;/script&gt;\n</code></pre>\n<ul>\n<li>父组件 App.vue</li>\n</ul>\n<pre><code class=\"lang-vue\">&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;!-- 在父组件监听子组件自定义的事件bClick，然后通过回调函数bbClick获取参数 --&gt;\n    &lt;Header @bClick=bbClick/&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n//1、引入子组件\nimport Header from &quot;./components/Header&quot;;\n  export default {\n    name:&quot;App&quot;,\n    methods:{\n      bbClick(value){\n         console.log(\'父组件监听到子组件发出的事件和接收到子组件的数据\' + value);\n      }\n    }\n  }\n&lt;/script&gt;\n</code></pre>\n<br/>\n<h5><a id=\"_props__630\"></a>■ 通过props 声明属性是函数类型，然后子组件监听事件，回调传参；父组件设置属性，属性值是回调函数，在回调函数获取子组件传递的参数</h5>\n<ul>\n<li>子组件 Header.vue</li>\n</ul>\n<pre><code class=\"lang-vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;子组件&lt;/h1&gt;\n    &lt;!-- 子组件监听事件，回调传参 --&gt; \n    &lt;button @click=&quot;changeTitle(\'标题\')&quot;&gt;子组件&lt;/button&gt; \n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n    name:&quot;Header&quot;,\n    /* 当前组件声明的属性(函数类型)，调用者设置属性 */\n    props:[&quot;changeTitle&quot;],\n    data(){\n      return{\n        title:\'header 页面头\'\n      }\n    }\n  }\n&lt;/script&gt;\n</code></pre>\n<ul>\n<li>父组件 App.vue</li>\n</ul>\n<pre><code class=\"lang-vue\">&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;!-- 在父组件调用子组件声明的属性(设置属性)，属性值是一个函数，在回调函数获取从子组件传递的参数 --&gt;\n    &lt;Header :change-title=&quot;myTitle&quot;/&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n//1、引入子组件\nimport Header from &quot;./components/Header&quot;;\n  export default {\n    name:&quot;App&quot;,\n    methods: {\n     myTitle(value){\n        console.log(value);\n      }\n    }\n  }\n&lt;/script&gt;\n</code></pre>\n<br/>\n<blockquote>\n<p>父子组件通信(父子组件的参数传递)是属于在同一个页面的参数传递。和路由传参不同，路由传参是通过url的参数进行传参，在不同页面的参数传递。</p>\n</blockquote>\n<p><br/><br/></p>\n<blockquote>\n<p>第三方插件：vue-route、vuex、axios、element-ui 在vue中使用思路：</p>\n<p>1、通过<strong>npm istall</strong> 插件名 命令添加到node_modules，并添加到dependencies依赖下(在package.json 可以看到)</p>\n<p>2、(第三方的东西一般会创建一个文件进行封装) <strong>创建插件对象，然后导出</strong></p>\n<ul>\n<li>通过Vue的use方法安装插件</li>\n</ul>\n<p>3、在项目的main.js 中引入插件对象，然后挂载到vue实例对象</p>\n<blockquote>\n<p>对于element-ui 样式布局插件，不用抽离单独封装成一个文件，直接在项目的mian.js 中使用Vue的use方法安装插件，然后就可以直接使用了，不用挂载到Vue实例上。</p>\n</blockquote>\n</blockquote>\n<p><br/><br/><br/></p>\n<h2><a id=\"vueroute_709\"></a>五、vue-route</h2>\n<h3><a id=\"1_711\"></a>1、引入路由模块并使用</h3>\n<ul>\n<li>路由对象</li>\n</ul>\n<pre><code class=\"lang-js\">// 1. 定义路由组件.\n// 也可以从其他文件导入\nconst Home = { template: \'&lt;div&gt;Home&lt;/div&gt;\' }\nconst About = { template: \'&lt;div&gt;About&lt;/div&gt;\' }\n\n// 2. 定义一些路由\n// 每个路由都需要映射到一个组件。\n// 我们后面再讨论嵌套路由。\nconst routes = [\n  { path: \'/\', component: Home },\n  { path: \'/about\', component: About },\n]\n\n// 3. 创建路由实例并传递 `routes` 配置\n// 你可以在这里输入更多的配置，但我们在这里\n// 暂时保持简单\nconst router = VueRouter.createRouter({\n  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。\n  history: VueRouter.createWebHashHistory(),\n  routes, // `routes: routes` 的缩写\n})\n\nexport default router\n</code></pre>\n<ul>\n<li>在main.js 中引入路由模块并使用（挂载路由）</li>\n</ul>\n<pre><code class=\"lang-js\">import Vue from \'vue\'\nimport App from \'./App\'\n\nimport router from \'./router\'\nnew Vue({\n  el: \'#app\',\n  router,//使用路由模块\n  template: \'&lt;App/&gt;\',\n  components: { App }\n})\n</code></pre>\n<ul>\n<li>路由体验：<router-view/></li>\n</ul>\n<pre><code class=\"lang-vue\">&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n     &lt;!--使用 router-link 组件进行导航 --&gt;\n   	 &lt;!--通过传递 `to` 来指定链接 --&gt;\n   	 &lt;!--`&lt;router-link&gt;` 将呈现一个带有正确 `href` 属性的 `&lt;a&gt;` 标签--&gt;\n   	 &lt;router-link to=&quot;/&quot;&gt;Go to Home&lt;/router-link&gt;\n   	 &lt;router-link to=&quot;/about&quot;&gt;Go to About&lt;/router-link&gt;\n    \n     &lt;!-- 路由出口 --&gt;\n 	 &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;\n  	 &lt;router-view&gt;&lt;/router-view&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: \'App\',\n}\n&lt;/script&gt;\n</code></pre>\n<ul>\n<li>改变url，发现＜router-view＞＜／router-view＞中的内容发生改变</li>\n</ul>\n<p>http://localhost:8080/#/    显示home</p>\n<p>http://localhost:8080/about  显示About</p>\n<ul>\n<li>\n<p>向router实例中添加mode属性：路由的两种模式</p>\n<p>值＂hash＂：url带＃适用于调试模式</p>\n<p>值＂history＂：url不带＃</p>\n</li>\n</ul>\n<br/>\n<h3><a id=\"2_798\"></a>2、路由传参</h3>\n<h4><a id=\"1__params__800\"></a>(1) 通过 params 获取参数的方式[动态路由]</h4>\n<p>① 路由path中声明参数</p>\n<p>② <route-link />的to属性传参</p>\n<p>③ 在模块组件中接收参数 $route.params</p>\n<pre><code class=\"lang-js\">// 路由path中声明参数,用于接收route-link 中传来的参数\nconst routes = [\n  // 动态字段以冒号开始\n  { path: \'/about/:id\', component: User },\n]\n</code></pre>\n<pre><code class=\"lang-vue\">&lt;!-- App.vue 父模块 --&gt;\n\n&lt;!-- &lt;route-link /&gt;的to属性传参 --&gt;\n&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n     &lt;!-- 使用 router-link 的to属性传递参数 --&gt;\n   	 &lt;router-link to=&quot;/about/1&quot;&gt;Go to About&lt;/router-link&gt;\n    \n     &lt;!-- 路由出口 --&gt;\n  	 &lt;router-view&gt;&lt;/router-view&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<pre><code class=\"lang-vue\">&lt;!-- About.vue 父模块 --&gt;\n\n&lt;!-- 在模块组件中接收参数 $route.params --&gt;\n&lt;template&gt;\n  &lt;div&gt; &lt;!--在template中直接接收参数--&gt;  \n  	&lt;h2&gt;{{$route.params.id}}&lt;/h2&gt;\n  	&lt;h1&gt;{{id}}&lt;/h&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n  name: \'About\',\n  data(){\n	return {\n    	id: this.$route.params.id //在js中接收参数    \n    }    \n}    \n&lt;/script&gt;    \n</code></pre>\n<br/>\n<h4><a id=\"2__quary__856\"></a>(2) 通过 quary 获取参数的方式</h4>\n<p>① <route-link />的to属性传参</p>\n<p>② 在模块组件中接收参数 $route.query</p>\n<pre><code class=\"lang-vue\">&lt;!-- App.vue 父模块 --&gt;\n\n &lt;!-- &lt;route-link /&gt;的to属性传参 --&gt;\n&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;      \n     &lt;!-- 使用 router-link 的to属性传递参数 --&gt;\n   	 &lt;router-link to=&quot;/about?id=1&quot;&gt;Go to About&lt;/router-link&gt;\n    \n     &lt;!-- 路由出口 --&gt;\n  	 &lt;router-view&gt;&lt;/router-view&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<pre><code class=\"lang-vue\">&lt;!-- About.vue 父模块 --&gt; \n\n&lt;!-- &lt;route-link /&gt;的to属性传参 --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n     &lt;!--在template中直接接收参数--&gt;  \n   	&lt;h2&gt;{{$route.query.id}}&lt;/h2&gt;\n  	&lt;h1&gt;{{id}}&lt;/h&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  export default {\n  name: \'App\',\n  data(){\n	return {\n    	id: this.$route.query.id //在js中接收参数    \n    }    \n}    \n&lt;/script&gt;  \n</code></pre>\n<br/>\n<h3><a id=\"3ltroutelink_to_904\"></a>3、&lt;route-link /&gt;的to属性</h3>\n<ul>\n<li>to可以接收一个对象，对象的属性有parmas，也有query</li>\n</ul>\n<pre><code class=\"lang-vue\">&lt;route-link to=&quot;{\n		path:\'/aboout/123\', \n		query:{name:\'shan\', age:18}\n	       }&quot; /&gt;\n</code></pre>\n<br/>\n<h5><a id=\"_url_pathquery_917\"></a>■ 补充一个常识，浏览器你看到地址url，其实是包括 path，和查询条件query</h5>\n<p>http://localhost:8080/about/123?name=shan&amp;age=18</p>\n<p>path：/about/123</p>\n<p>query：是指从?开始的查看条件 ?name=shan&amp;age=18，多个查询条件使用&amp;隔开(除了第一个查询条件使用?)</p>\n<br/>\n<h3><a id=\"4_parmas__query_929\"></a>4、总结路由传参 parmas 和 query</h3>\n<blockquote>\n<ul>\n<li>传递参数主要有两种类型: params 和 query</li>\n</ul>\n</blockquote>\n<ul>\n<li>主要是写法格式不同，query是传统的传参方式，以?开始，而params(path 传参方式)，其实是一种restful风格的传参方式[写法更整齐简洁]</li>\n<li>两者传参方式没有好坏之分</li>\n<li>需要注意的是params需要预定义声明参数，即<strong>在路由配置中定义 用冒号的形式标记</strong></li>\n</ul>\n<p><br/><br/><br/></p>\n<h2><a id=\"axios_945\"></a>六、axios</h2>\n<h3><a id=\"1axios__947\"></a>1、axios 是什么？</h3>\n<p>Axios 是一个<strong>基于 Promise 的 HTTP 库（网络请求库）</strong>，可以作用于浏览器和 node.js</p>\n<h3><a id=\"2npm_951\"></a>2、安装（npm安装方式）：</h3>\n<pre><code class=\"lang-bash\">npm install axios\n</code></pre>\n<h3><a id=\"3_axios_957\"></a>3、 axios网络模块过程:</h3>\n<p>(1）axios创建实例（<strong>全局配置/基本配置</strong>）</p>\n<p>(2) 发送请求</p>\n<p>(3) axios拦截器的使用</p>\n<pre><code class=\"lang-js\">import axios from \'axios\'\n \nexport function request(config) {\n  // 1.创建axios的实例（全局配置/基本配置）\n  const service = axios.create({\n    baseURL: \'http://123.207.32.32:8000\',//还可以将baseURL的值抽取出去 baseURL: process.env.BASE_API,\n    timeout: 5000\n  })\n \n  // 2.axios的拦截器\n  // 2.1.请求拦截的作用\n  service.interceptors.request.use(config =&gt; {\n    // console.log(config);\n    // 1.比如config中的一些信息不符合服务器的要求\n \n    // 2.比如每次发送网络请求时, 都希望在界面中显示一个请求的图标\n \n    // 3.某些网络请求(比如登录(token)), 必须携带一些特殊的信息\n    return config\n  }, err =&gt; {\n    // console.log(err);\n  })\n \n  // 2.2.响应拦截\n  service.interceptors.response.use(res =&gt; {\n    // console.log(res);\n    return res.data\n  }, err =&gt; {\n    console.log(err);\n  })\n \n  // 3.发送真正的网络请求\n  return service(config)\n}\n</code></pre>\n<ul>\n<li>针对模块组件封装成具体方法发送请求：</li>\n</ul>\n<pre><code class=\"lang-js\">// article.js \nimport request from \'@/request\'\n\nexport function getHotArtices() {\n  return request({\n    url: \'/articles/hot\',\n    method: \'post\'\n  })\n}\n\nexport function viewArticle(id) {\n  return request({\n    url: `/articles/view/${id}`,\n    method: \'post\'\n  })\n}\n.....\n</code></pre>\n<p><br/><br/><br/></p>\n<h2><a id=\"Vuex_1032\"></a>七、Vuex状态管理</h2>\n<ul>\n<li>后端对应的web是使用session管理状态</li>\n</ul>\n<pre><code class=\"lang-js\">import Vue from \'vue\'\nimport Vuex from \'vuex\'\n\nVue.use(Vuex)\n\n// 定义状态对象state,保存数据的仓库\nconst state={\n    //组件模块调用state中的属性：this.$store.state.getUserInfo\n    userInfo:{\n        id:\'\',\n        name:\'\'\n    }\n}\n//相对于java对象的get方法\nconst getters={\n    //组件模块调用getter中的方法：this.$store.getters.getUserInfo\n    getUserInfo(state){\n        return state.userInfo;\n    }\n}\n//相当于java的set方法的mutations(同步执行)和 actions(异步执行)\nconst mutations ={\n    //组件模块调用mutations中的方法：this.$store.commit(\'updateUserInfo\', userInfo) 通过提交commit\n    updateUserInfo(state, userInfo){\n        state.userInfo = userInfo;\n    }\n}\nconst actions ={\n    //组件模块调用actions中的方法：this.$store.dispatch(\'asyncUpdateUserInfo\', userInfo) 通过分发dispatch\n    asyncUpdateUserInfo(context, userInfo){\n        context.commit(\'updateUserInfo\', userInfo);//最终还是调用同步的mutations中的方法\n    }\n}\n\nexport default new Vuex({\n    state,\n    getters,\n    mutations,\n    actions\n});\n</code></pre>\n<p><br/><br/><br/></p>\n<h2><a id=\"elementui_1085\"></a>八、element-ui</h2>\n<ul>\n<li>element-ui 和 bootstrap类似，都是做为样式组件的</li>\n</ul>\n<br/>\n<h3><a id=\"1_Element_1091\"></a>1、引入 Element（完整引入）</h3>\n<ul>\n<li>在 main.js 中写入以下内容</li>\n</ul>\n<pre><code class=\"lang-js\">import Vue from \'vue\';\nimport ElementUI from \'element-ui\';\nimport \'element-ui/lib/theme-chalk/index.css\';\nimport App from \'./App.vue\';\n\nVue.use(ElementUI);\n\nnew Vue({\n  el: \'#app\',\n  render: h =&gt; h(App)\n});\n</code></pre>\n<br/>\n<h3><a id=\"2Layout__1111\"></a>2、Layout 布局</h3>\n<ul>\n<li>需要什么组件就直接从官网提供的布局组件那里复制\n<ul>\n<li>官网地址 <a href=\"https://element.eleme.cn/#/zh-CN/component/layout\" target=\"_blank\">组件 | Element</a></li>\n</ul>\n</li>\n</ul>\n<p><br/><br/><br />\n<strong>如果本文对你有帮助的话记得给一乐点个赞哦，感谢！</strong></p>\n', 1548665638056673281);
INSERT INTO `ys_article_body` VALUES (1548666154572627971, '\n\n<br/>\n\n## 一、cookie 的诞生\n\n> 首先需要知道**Http协议的无状态连接的**，即这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。\n>\n> 服务端，既不知道上一次请求和这一次请求的关联，也无法知道哪一个客户端来请求自己。\n>\n> 这时候，假设有一个客户请求了登录界面，然后登录成功，客户需要请求首页，由于http的无状态连接，不记得咱请求过登录，并且登录成功了，在首页就会看不到登录成功的用户信息。\n>\n> 【登录界面的用户信息无法共享给其他页面】\n\n<br/>\n\n### 1、cookie 技术---客户端技术\n\n为了解决http 无状态连接，导致无法共享数据的问题，然后像用户信息这种数据，明显就是好几个页面都需要用到的全局信息，每次请求都到数据库访问，会增大数据库的访问次数，同时导致减低访问速度；于是乎，cookie诞生了。\n\n#### <font color=red>cookie把一些共享的信息(用户信息) 存储到客户端的浏览器，它在一个域名下是一个全局的。</font>\n\n<br/>\n\n### 2、cookie的不足\n\n① cookie 存储的信息数量是有限制的，**只能存储少量信息**\n\n② cookie 存储的信息在客户端的浏览器里，对于用户而言就是**透明可见的**，因为是在自己的浏览器上，所以用户就可以随意的修改，导致**不安全**\n\n- 假设如果真的cookie存储了用户的所有信息，那么像用户的密码这种东西在浏览器透明可见，太危险了。\n\n<br/>\n\n> 将共享信息存储少量(不涉及安全问题的)信息存储到客户端浏览器，然后其他的信息(包括涉及用户安全的信息)存储到服务端，这种将共享信息(用户信息)存储到服务端的技术就是session技术。\n\n\n\n\n<br/><br/><br/>\n\n\n## 二、session 的诞生\n\n### 1、session 技术---服务端技术\n\nsession 其实也是特殊的cookie，只是信息存储的位置是在服务端。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。\n\nSession对象，保证**一个用户的所有请求操作都应该属于同一个会话**，而另一个用户的所有请求操作则应该属于另一个会话。\n\n<br/>\n\n### 2、session 原理\n\n**是存储在服务端的一组数据。有些网站是采用session机制来验证用户身份的。Session对象主要是用来存储用户会话的数据。**\n\n**SessionID需要存储在浏览器端，通常存储在 cookie 里。**\n\n浏览器发送接口请求的时候需要带着这个sessionID，服务器端就可以根据这个SessionID，找出当前请求的用户是谁了。\n\nSession一般都会配置一个过期时间，Session过期之后，用户就需要重新登录了。\n\n<br/><br/>\n\n\n\n### 3、session 的不足\n\n随着网站的用户越来越多，Session所需的空间会越来越大**，同时单机部署的** Web应用会出现性能瓶颈。[`单机 session`]\n这时候需要进行架构的优化或调整，比如扩展Web 应用节点，在应用服务器节点之前实现**负载均衡**。[`分布式 session`]\n\n负载均衡导致了session的管理出现了问题，难以保证**一个用户的所有请求操作都应该属于同一个会话**，会出现同一个用户请求应用A，在应用A的服务器上记录的用户信息[用户会话Session对象]，然后该用户请求应用B，这时候，用于用户信息保存到A服务上，无法共享数据问题。\n\n> ### 分布式会话的问题:\n>\n> 解决方式1：在负载均衡时，nginx 可以根据**\"hash_ip\"算法将同一个 IP 的请求固定到某台服务器**，这样来自于同一个 ip 的 session 请求总是请求到同样的服务器。\n>\n> 解决方式2：对session 进行剥离，把 session 数据彻底从业务服务器中剥离，单独存储在其他外部设备中(**redis服务器**--分布式缓存中间件)。且外部设备redis还可以采用主备或者主从，甚至集群的模式来达到高可用。、\n\n<br/>\n\n### 4、cookie 和 session 的区别和选择：一般在项目中结合起来时候的\n\n① cookie 数据存放在客户端上，session 数据放在服务器上。\n\n② cookie 不安全，session 比较安全\n\n③ session 保存在服务器上，当访问增多，会占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 COOKIE。\n\n<br/>\n\n> session认证需要服务端做大量的工作来保证session信息的一致性以及session的存储，所以现代的web应用在认证的解决方案上更倾向于客户端方向，cookie认证是基于客户端方式的，但是cookie缺点也很明显。把认证信息保存在客户端，关键点就是安全的验证，session是一种方式。\n>\n> 如果只是**针对用户登录这个应用场景**，session 方案并不是唯一的解决方案---**基于Token的认证**\n\n<br/><br/><br/>\n\n\n\n## 三、token 的诞生\n\n> 目前市面上能见到的认证方式分为两大种——基于Session的和基于Token的。\n>\n> **基于Session的认证**，是指在客户端存储一个Session Id。认证时，请求携带Session Id，并由服务器从Session数据存储中找到对应的Session。\n>\n> **基于Token的认证**，是指将所有认证相关的信息在服务器端编码成一个Token(token 可以认为就是个长长的字符串)，并由服务器签名，以确保不被篡改。Token本身是**明文**的。存在Token里的信息可以有比如user id、权限列表、用户昵称一类的。这样服务器只要拿着token和token的签名，就可以直接验证用户的身份是合法的。**在现实当中，基于Token的认证的主要标准是Json Web Token （JWT）**\n\n<br/>\n\n### 1、token的引入---用户身份的验证\n\nToken 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。\n\n**<font color=red>Token，直接就相当于一个身份证，给 Token 就能确定你的身份。</font>**\n\n<br/>\n\n### 2、Token 的定义：\n\nToken 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，**以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。**\n\n最简单的 token 组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由 token 的前几位 + 盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接 token 请求服务器)。\n\n> ● 当用户**第一次**使用账号密码成功进行登录后，服务器便**生成一个Token及Token失效时间**并将此返回给客户端，若成功登陆，以后客户端只需在有效时间内**`带上这个Token前来请求数据即可，无需再次带上用户名和密码`**。\n\n<br/>\n\n### 3、使用 Token 的目的：\n\nToken 的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。\n\n<br/>\n\n### 4、token验证\n\n- 每次服务器验证客户端请求里面带着的 Token，如果一开始服务端签发生成的token**存储到数据库**，那么后边的查询验证会很费时。如果不存储到数据库，应该存储到哪里呢？\n\n  ---存储到内存中(使用redis缓存)\n\n\n\n\n<br/><br/><br/>\n\n\n## 四、jwt~ 基于Token的认证的主要标准Json Web Token\n\n> 由于现在的项目大多前后分离，api 跨域需求又那么多，api鉴权用jwt(使用jwt 来验证用户身份)，因为jwt支持跨域使用,且因为有签名，所以JWT可以防止被篡改。\n\n<br/>\n\n### 1、跨域session和cookie失效问题\n\n由于跨域所以发送请求时不会带上cookie，而session是基于cookie的，所以cookie失效了session也会失效，那么怎么解决呢。\n\n<br/>\n\n### 2、解决session和cookie失效问题\n\n使用token来模拟session，将token放到请求头，前端每次请求都带上token，后端提供一个接口来给前端获取token。\n\n>token是遵从JWT规范的。\n\n<br/>\n\n### 3、jwt官网两大用场景\n\n- Authorization(授权)：这是 jwt 应用最为广泛的场景。**jwt 将数据加密存储，分发给前端，前端将其放在特定的 header 字段中**（也有放在 params 和 body 中），**服务器收到请求后，解析 jwt 判断用户身份，对用户请求进行限权。**\n- Information Exchange(数据交换): jwt 可以通过公钥和私钥对信息进行加密，双方通信后，互得数据。\n\n<br/>\n\n### 4、jwt 有三部分组成：A.B.C\n\n**A：Header，{\"type\":\"JWT\",\"alg\":\"HS256\"} 固定**\n\n**B：playload，存放信息，比如用户id，过期时间等等，可以被解密，不能存放敏感信息**\n\n**C:  签证，A和B加上秘钥 加密而成，只要秘钥不丢失，可以认为是安全的。**\n\n**jwt 验证，主要就是验证C部分 是否合法。**\n\n\n\n<br/><br/><br/>\n\n\n\n## ☺ 五、面试聊聊cookie、session、token\n\n**这三个是不同维度的东西，没有什么可比性。**\n\n### Cookie\n\n是存储在浏览器的一小段文本数据；数据大小不超过4kb。Cookie的内容，会随着http请求一起发送到服务端，即发送网络请求的时候，cookie 会在请求头里一起发送给服务器端。\n\n<br/>\n\n### Session \n\n**是存储在服务端的一组数据。有些网站是采用session机制来验证用户身份的。Session对象主要是用来存储用户会话的数据。**\n\n**SessionID需要存储在浏览器端，通常存储在 cookie 里。**\n\n浏览器发送接口请求的时候需要带着这个sessionID，服务器端就可以根据这个SessionID，找出当前请求的用户是谁了。\n\nSession一般都会配置一个过期时间，Session过期之后，用户就需要重新登录了。\n\n<br/> \n\n### Token\n\n在很多地方都会用到，是一个通用名词。通常用来表示一小段字符串。**Token可以存储在cookie里，也可以存储到服务器的内存里，也可以存储到其他地方。**Token 和session、cookie不是一个维度的东西。\n\n**目前有一种用户认证的机制，全名是json web token（jwt）。**\n\n<br/><br/>\n\n参考文章：《Token ，Cookie 和 Session 的区别》https://jqiange.github.io/Token-%EF%BC%8CCookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB/\n\n\n\n<br/><br/>\n\n**如果本文对你有帮助的话记得给一乐点个赞哦，感谢！**', '<br/>\n<h2><a id=\"cookie__4\"></a>一、cookie 的诞生</h2>\n<blockquote>\n<p>首先需要知道<strong>Http协议的无状态连接的</strong>，即这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。</p>\n<p>服务端，既不知道上一次请求和这一次请求的关联，也无法知道哪一个客户端来请求自己。</p>\n<p>这时候，假设有一个客户请求了登录界面，然后登录成功，客户需要请求首页，由于http的无状态连接，不记得咱请求过登录，并且登录成功了，在首页就会看不到登录成功的用户信息。</p>\n<p>【登录界面的用户信息无法共享给其他页面】</p>\n</blockquote>\n<br/>\n<h3><a id=\"1cookie__16\"></a>1、cookie 技术—客户端技术</h3>\n<p>为了解决http 无状态连接，导致无法共享数据的问题，然后像用户信息这种数据，明显就是好几个页面都需要用到的全局信息，每次请求都到数据库访问，会增大数据库的访问次数，同时导致减低访问速度；于是乎，cookie诞生了。</p>\n<h4><a id=\"font_colorredcookie_font_20\"></a><font color=red>cookie把一些共享的信息(用户信息) 存储到客户端的浏览器，它在一个域名下是一个全局的。</font></h4>\n<br/>\n<h3><a id=\"2cookie_24\"></a>2、cookie的不足</h3>\n<p>① cookie 存储的信息数量是有限制的，<strong>只能存储少量信息</strong></p>\n<p>② cookie 存储的信息在客户端的浏览器里，对于用户而言就是<strong>透明可见的</strong>，因为是在自己的浏览器上，所以用户就可以随意的修改，导致<strong>不安全</strong></p>\n<ul>\n<li>假设如果真的cookie存储了用户的所有信息，那么像用户的密码这种东西在浏览器透明可见，太危险了。</li>\n</ul>\n<br/>\n<blockquote>\n<p>将共享信息存储少量(不涉及安全问题的)信息存储到客户端浏览器，然后其他的信息(包括涉及用户安全的信息)存储到服务端，这种将共享信息(用户信息)存储到服务端的技术就是session技术。</p>\n</blockquote>\n<p><br/><br/><br/></p>\n<h2><a id=\"session__42\"></a>二、session 的诞生</h2>\n<h3><a id=\"1session__44\"></a>1、session 技术—服务端技术</h3>\n<p>session 其实也是特殊的cookie，只是信息存储的位置是在服务端。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。</p>\n<p>Session对象，保证<strong>一个用户的所有请求操作都应该属于同一个会话</strong>，而另一个用户的所有请求操作则应该属于另一个会话。</p>\n<br/>\n<h3><a id=\"2session__52\"></a>2、session 原理</h3>\n<p><strong>是存储在服务端的一组数据。有些网站是采用session机制来验证用户身份的。Session对象主要是用来存储用户会话的数据。</strong></p>\n<p><strong>SessionID需要存储在浏览器端，通常存储在 cookie 里。</strong></p>\n<p>浏览器发送接口请求的时候需要带着这个sessionID，服务器端就可以根据这个SessionID，找出当前请求的用户是谁了。</p>\n<p>Session一般都会配置一个过期时间，Session过期之后，用户就需要重新登录了。</p>\n<p><br/><br/></p>\n<h3><a id=\"3session__66\"></a>3、session 的不足</h3>\n<p>随着网站的用户越来越多，Session所需的空间会越来越大**，同时单机部署的** Web应用会出现性能瓶颈。[<code>单机 session</code>]<br />\n这时候需要进行架构的优化或调整，比如扩展Web 应用节点，在应用服务器节点之前实现<strong>负载均衡</strong>。[<code>分布式 session</code>]</p>\n<p>负载均衡导致了session的管理出现了问题，难以保证<strong>一个用户的所有请求操作都应该属于同一个会话</strong>，会出现同一个用户请求应用A，在应用A的服务器上记录的用户信息[用户会话Session对象]，然后该用户请求应用B，这时候，用于用户信息保存到A服务上，无法共享数据问题。</p>\n<blockquote>\n<h3><a id=\"_73\"></a>分布式会话的问题:</h3>\n<p>解决方式1：在负载均衡时，nginx 可以根据**&quot;hash_ip&quot;算法将同一个 IP 的请求固定到某台服务器**，这样来自于同一个 ip 的 session 请求总是请求到同样的服务器。</p>\n<p>解决方式2：对session 进行剥离，把 session 数据彻底从业务服务器中剥离，单独存储在其他外部设备中(<strong>redis服务器</strong>–分布式缓存中间件)。且外部设备redis还可以采用主备或者主从，甚至集群的模式来达到高可用。、</p>\n</blockquote>\n<br/>\n<h3><a id=\"4cookie__session__81\"></a>4、cookie 和 session 的区别和选择：一般在项目中结合起来时候的</h3>\n<p>① cookie 数据存放在客户端上，session 数据放在服务器上。</p>\n<p>② cookie 不安全，session 比较安全</p>\n<p>③ session 保存在服务器上，当访问增多，会占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 COOKIE。</p>\n<br/>\n<blockquote>\n<p>session认证需要服务端做大量的工作来保证session信息的一致性以及session的存储，所以现代的web应用在认证的解决方案上更倾向于客户端方向，cookie认证是基于客户端方式的，但是cookie缺点也很明显。把认证信息保存在客户端，关键点就是安全的验证，session是一种方式。</p>\n<p>如果只是<strong>针对用户登录这个应用场景</strong>，session 方案并不是唯一的解决方案—<strong>基于Token的认证</strong></p>\n</blockquote>\n<p><br/><br/><br/></p>\n<h2><a id=\"token__99\"></a>三、token 的诞生</h2>\n<blockquote>\n<p>目前市面上能见到的认证方式分为两大种——基于Session的和基于Token的。</p>\n<p><strong>基于Session的认证</strong>，是指在客户端存储一个Session Id。认证时，请求携带Session Id，并由服务器从Session数据存储中找到对应的Session。</p>\n<p><strong>基于Token的认证</strong>，是指将所有认证相关的信息在服务器端编码成一个Token(token 可以认为就是个长长的字符串)，并由服务器签名，以确保不被篡改。Token本身是<strong>明文</strong>的。存在Token里的信息可以有比如user id、权限列表、用户昵称一类的。这样服务器只要拿着token和token的签名，就可以直接验证用户的身份是合法的。<strong>在现实当中，基于Token的认证的主要标准是Json Web Token （JWT）</strong></p>\n</blockquote>\n<br/>\n<h3><a id=\"1token_109\"></a>1、token的引入—用户身份的验证</h3>\n<p>Token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。</p>\n<p><strong><font color=red>Token，直接就相当于一个身份证，给 Token 就能确定你的身份。</font></strong></p>\n<br/>\n<h3><a id=\"2Token__117\"></a>2、Token 的定义：</h3>\n<p>Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，<strong>以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。</strong></p>\n<p>最简单的 token 组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由 token 的前几位 + 盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接 token 请求服务器)。</p>\n<blockquote>\n<p>● 当用户<strong>第一次</strong>使用账号密码成功进行登录后，服务器便<strong>生成一个Token及Token失效时间</strong>并将此返回给客户端，若成功登陆，以后客户端只需在有效时间内**<code>带上这个Token前来请求数据即可，无需再次带上用户名和密码</code>**。</p>\n</blockquote>\n<br/>\n<h3><a id=\"3_Token__127\"></a>3、使用 Token 的目的：</h3>\n<p>Token 的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p>\n<br/>\n<h3><a id=\"4token_133\"></a>4、token验证</h3>\n<ul>\n<li>\n<p>每次服务器验证客户端请求里面带着的 Token，如果一开始服务端签发生成的token<strong>存储到数据库</strong>，那么后边的查询验证会很费时。如果不存储到数据库，应该存储到哪里呢？</p>\n<p>—存储到内存中(使用redis缓存)</p>\n</li>\n</ul>\n<p><br/><br/><br/></p>\n<h2><a id=\"jwt_TokenJson_Web_Token_145\"></a>四、jwt~ 基于Token的认证的主要标准Json Web Token</h2>\n<blockquote>\n<p>由于现在的项目大多前后分离，api 跨域需求又那么多，api鉴权用jwt(使用jwt 来验证用户身份)，因为jwt支持跨域使用,且因为有签名，所以JWT可以防止被篡改。</p>\n</blockquote>\n<br/>\n<h3><a id=\"1sessioncookie_151\"></a>1、跨域session和cookie失效问题</h3>\n<p>由于跨域所以发送请求时不会带上cookie，而session是基于cookie的，所以cookie失效了session也会失效，那么怎么解决呢。</p>\n<br/>\n<h3><a id=\"2sessioncookie_157\"></a>2、解决session和cookie失效问题</h3>\n<p>使用token来模拟session，将token放到请求头，前端每次请求都带上token，后端提供一个接口来给前端获取token。</p>\n<blockquote>\n<p>token是遵从JWT规范的。</p>\n</blockquote>\n<br/>\n<h3><a id=\"3jwt_165\"></a>3、jwt官网两大用场景</h3>\n<ul>\n<li>Authorization(授权)：这是 jwt 应用最为广泛的场景。<strong>jwt 将数据加密存储，分发给前端，前端将其放在特定的 header 字段中</strong>（也有放在 params 和 body 中），<strong>服务器收到请求后，解析 jwt 判断用户身份，对用户请求进行限权。</strong></li>\n<li>Information Exchange(数据交换): jwt 可以通过公钥和私钥对信息进行加密，双方通信后，互得数据。</li>\n</ul>\n<br/>\n<h3><a id=\"4jwt_ABC_172\"></a>4、jwt 有三部分组成：A.B.C</h3>\n<p><strong>A：Header，{“type”:“JWT”,“alg”:“HS256”} 固定</strong></p>\n<p><strong>B：playload，存放信息，比如用户id，过期时间等等，可以被解密，不能存放敏感信息</strong></p>\n<p><strong>C:  签证，A和B加上秘钥 加密而成，只要秘钥不丢失，可以认为是安全的。</strong></p>\n<p><strong>jwt 验证，主要就是验证C部分 是否合法。</strong></p>\n<p><br/><br/><br/></p>\n<h2><a id=\"_cookiesessiontoken_188\"></a>☺ 五、面试聊聊cookie、session、token</h2>\n<p><strong>这三个是不同维度的东西，没有什么可比性。</strong></p>\n<h3><a id=\"Cookie_192\"></a>Cookie</h3>\n<p>是存储在浏览器的一小段文本数据；数据大小不超过4kb。Cookie的内容，会随着http请求一起发送到服务端，即发送网络请求的时候，cookie 会在请求头里一起发送给服务器端。</p>\n<br/>\n<h3><a id=\"Session_198\"></a>Session</h3>\n<p><strong>是存储在服务端的一组数据。有些网站是采用session机制来验证用户身份的。Session对象主要是用来存储用户会话的数据。</strong></p>\n<p><strong>SessionID需要存储在浏览器端，通常存储在 cookie 里。</strong></p>\n<p>浏览器发送接口请求的时候需要带着这个sessionID，服务器端就可以根据这个SessionID，找出当前请求的用户是谁了。</p>\n<p>Session一般都会配置一个过期时间，Session过期之后，用户就需要重新登录了。</p>\n<br/> \n<h3><a id=\"Token_210\"></a>Token</h3>\n<p>在很多地方都会用到，是一个通用名词。通常用来表示一小段字符串。**Token可以存储在cookie里，也可以存储到服务器的内存里，也可以存储到其他地方。**Token 和session、cookie不是一个维度的东西。</p>\n<p><strong>目前有一种用户认证的机制，全名是json web token（jwt）。</strong></p>\n<p><br/><br/></p>\n<p>参考文章：《Token ，Cookie 和 Session 的区别》https://jqiange.github.io/Token-%EF%BC%8CCookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB/</p>\n<p><br/><br/></p>\n<p><strong>如果本文对你有帮助的话记得给一乐点个赞哦，感谢！</strong></p>\n', 1548666154505519106);
INSERT INTO `ys_article_body` VALUES (1548666437348409348, '<br/>\n\n\n\n## 一、nginx 作用\n\n### ★ 静态HTTP服务器\n\n### ★ HTTP服务器（动静分离）\n\n### ★ 反向代理\n\n### ★ 负载均衡\n\n\n<br/><br/><br/>\n\n\n## 二、nginx 静态HTTP服务器配置\n\n- `Nginx本身也是一个静态资源的服务器`，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现。\n\n~~~bash\n# nginx 静态资源配置--静态服务器(也是最简单的配置)\nserver {\n	listen 80; # 监听端口号\n	server_name localhost; # 主机名\n	index index.html index.htm; # 默认页名称\n	root html; # 静态资源存放目录\n	location / { # 匹配路径\n		root html; # 文件根目录\n		index index.html index.htm; # 默认页名称\n	}\n	error_page 500 502 503 504 /50x.html; # 报错编码对应页面\n	location = /50x.html {\n		root html;\n	}\n}\n~~~\n\n<br/>\n\n### ● url 和 uri:\n\n- 网址是url，url=主机:端口+uri\n- uri 是资源，是location后面的匹配规则，即 location uri\n\n<br/>\n\n### ● location uri，当规则匹配上了就到root目录找页面\n\n~~~bash\nlocation / { #匹配路径\n		root html; #文件根目录\n		index index.html index.htm; #默认页名称\n	}\n~~~\n\n<br/>\n\n### ● location 配置方法\n\n- location 配置可以有两种配置方法\n\n① 前缀 + uri（字符串/正则表达式）\n\n② @ + name\n\n- 前缀含义\n\n  =  ：精确匹配（必须全部相等）\n\n  ~  ：大小写敏感\n\n  ~* ：忽略大小写\n\n  ^~ ：只需匹配uri部分\n\n  @  ：内部服务跳转\n\n\n\n<br/><br/><br/>\n\n\n\n## 三、nginx HTTP服务器（动静分离--nginx+tomcat实现动静分离）\n\n- 静态资源：数据不变，请求不需要后台处理；动态资源：模板，jsp、templates等，数据需要后台处理后渲染到网页，动态网页。\n- Nginx可以根据一定规则把不变的资源和经常变的资源区分开，对动静资源进行拆分，实现对静态资源的做缓存，从而提高资源响应的速度。**这就是网站静态化处理的核心思路。**\n\n~~~bash\nupstream tomcat{  \n	server localhost:8080;  \n}   \nserver {  \n	listen       80;  \n	server_name  localhost;  \n	location / {  \n		root   html;  \n		index  index.html;  \n	}  \n	# 所有静态请求都由nginx处理，存放目录为html  \n	location  ~* \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {  \n		root   html;  \n	}  \n	# 所有动态请求都转发给tomcat处理  \n	location ~ *jsp$ {  \n		proxy_pass  http://tomcat; # 代理转发\n	}  \n	error_page   500 502 503 504  /50x.html;  \n	location = /50x.html {  \n		root  html;  \n	}  \n}\n~~~\n\n\n<br/><br/><br/>\n\n\n## 四、 反向代理----使用proxy_pass\n\n~~~bash\nserver {\n               listen       80;\n               server_name  blog.yilele.site;\n               index   index.html;            \n               location / {\n                        root /shan/blog/;\n                        index index.html;\n               }\n              location ~* \\.(jpg|jpeg|gif|png|swf|rar|zip|css|js|map|svg|woff|ttf|txt)$ {\n                          root /shan/blog/;\n                          index index.html;\n                          add_header Access-Control-Allow-Origin *;\n              }\n              # 反向代理\n              location /api {\n					proxy_pass http://ip地址或域名:端口号;\n               }  \n}\n~~~\n\n\n\n\n<br/><br/><br/>\n\n\n# ☺ nginx 配置springboot+vue 前后端分离项目\n\n## 1、思路：nginx 结合自身特性，`本身一个静态资源的服务器`，\n\n### (1) 通过nginx实现域名的方式访问网站，以及把对数据的请求通过nginx反向代理转发给后端容器(后端服务)，避免了接口暴露的不安全\n\n#### ① 访问网站，首先习惯上访问网站的首页，通常访问路径是/ [location /]，然后默认页面是首页;\n\n~~~bash\nlocation / {\n     root /shan/blog/;\n     index index.html;\n }\n~~~\n\n<br/>\n\n#### ② 默认页面，首页需要像css、js、图片等静态资源，才能显示出样式、动态效果等，需要通过匹配规则[location ~*\\.(jpg|jpeg|gif|png|swf|rar|zip|css|js|map|svg|woff|ttf|txt)$]，指定root 到那个目录下获取这些静态资源。\n\n~~~bash\nlocation ~* \\.(jpg|jpeg|gif|png|swf|rar|zip|css|js|map|svg|woff|ttf|txt)$ {\n    root /shan/blog/;\n    index index.html;\n    add_header Access-Control-Allow-Origin *;\n }\n~~~\n\n<br/>\n\n#### ③ 默认首页，需要有数据\n\n##### 在vue中首页实际上编写了很多个接口在请求数据，这些动态数据是来自 springboot项目(api 服务)，需要咱通过定义一个匹配接口路径的规则[location /api]，然后进行请求转发到 springboot项目(api 服务)\n\n\n<br/>\n\n\n## 2、通过dockerCompose+nginx配置实现部署spirngboot+vue前后端分离项目\n\n### (1) dockerCompose 主要内容：\n\n~~~yaml\nversion: \"3\"\nservices:\n  api:\n    image: api\n    container_name: api\n    expose:\n      - \"8888\"\n  nginx:\n    image: nginx\n    container_name: nginx\n    ports:\n      - 80:80\n      - 443:443\n    volumes:\n      - /mnt/docker/nginx/:/etc/nginx/\n      - /mnt/shan/blog:/shan/blog\n    links:\n      - api\n    depends_on:\n      - api\n~~~\n\n\n<br/><br/>\n\n\n### (2) nginx 主要配置：\n\n~~~bash\nupstream apistream{\n        server api:8888;# 通过dockerCompose编排，服务名相当于域名\n}\n\nserver {\n               listen       80;\n               server_name  blog.yilele.site;\n               index   index.html;          \n               location / {\n                        root /shan/blog/;\n                        index index.html;\n               }\n              location ~* \\.(jpg|jpeg|gif|png|swf|rar|zip|css|js|map|svg|woff|ttf|txt)$ {\n                        root /shan/blog/;\n                        index index.html;\n                        add_header Access-Control-Allow-Origin *;\n              }\n              location /api {# 请求https://blog.yilele.site/api 会代理转发到 api:8888\n					  proxy_pass http://apistream;\n              }  \n}\n~~~\n\n\n\n<br/><br/>\n\n**如果本文对你有帮助的话记得给一乐点个赞哦，感谢！**\n', '<br/>\n<h2><a id=\"nginx__4\"></a>一、nginx 作用</h2>\n<h3><a id=\"_HTTP_6\"></a>★ 静态HTTP服务器</h3>\n<h3><a id=\"_HTTP_8\"></a>★ HTTP服务器（动静分离）</h3>\n<h3><a id=\"__10\"></a>★ 反向代理</h3>\n<h3><a id=\"__12\"></a>★ 负载均衡</h3>\n<p><br/><br/><br/></p>\n<h2><a id=\"nginx_HTTP_18\"></a>二、nginx 静态HTTP服务器配置</h2>\n<ul>\n<li><code>Nginx本身也是一个静态资源的服务器</code>，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现。</li>\n</ul>\n<pre><code class=\"lang-bash\"># nginx 静态资源配置--静态服务器(也是最简单的配置)\nserver {\n	listen 80; # 监听端口号\n	server_name localhost; # 主机名\n	index index.html index.htm; # 默认页名称\n	root html; # 静态资源存放目录\n	location / { # 匹配路径\n		root html; # 文件根目录\n		index index.html index.htm; # 默认页名称\n	}\n	error_page 500 502 503 504 /50x.html; # 报错编码对应页面\n	location = /50x.html {\n		root html;\n	}\n}\n</code></pre>\n<br/>\n<h3><a id=\"_url__uri_42\"></a>● url 和 uri:</h3>\n<ul>\n<li>网址是url，url=主机:端口+uri</li>\n<li>uri 是资源，是location后面的匹配规则，即 location uri</li>\n</ul>\n<br/>\n<h3><a id=\"_location_uriroot_49\"></a>● location uri，当规则匹配上了就到root目录找页面</h3>\n<pre><code class=\"lang-bash\">location / { #匹配路径\n		root html; #文件根目录\n		index index.html index.htm; #默认页名称\n	}\n</code></pre>\n<br/>\n<h3><a id=\"_location__60\"></a>● location 配置方法</h3>\n<ul>\n<li>location 配置可以有两种配置方法</li>\n</ul>\n<p>① 前缀 + uri（字符串/正则表达式）</p>\n<p>② @ + name</p>\n<ul>\n<li>\n<p>前缀含义</p>\n<dl>\n<dt>=  ：精确匹配（必须全部相等）</dt>\n<dd>：大小写敏感</dd>\n</dl>\n<p>~* ：忽略大小写</p>\n<p>^~ ：只需匹配uri部分</p>\n<p>@  ：内部服务跳转</p>\n</li>\n</ul>\n<p><br/><br/><br/></p>\n<h2><a id=\"nginx_HTTPnginxtomcat_86\"></a>三、nginx HTTP服务器（动静分离–nginx+tomcat实现动静分离）</h2>\n<ul>\n<li>静态资源：数据不变，请求不需要后台处理；动态资源：模板，jsp、templates等，数据需要后台处理后渲染到网页，动态网页。</li>\n<li>Nginx可以根据一定规则把不变的资源和经常变的资源区分开，对动静资源进行拆分，实现对静态资源的做缓存，从而提高资源响应的速度。<strong>这就是网站静态化处理的核心思路。</strong></li>\n</ul>\n<pre><code class=\"lang-bash\">upstream tomcat{  \n	server localhost:8080;  \n}   \nserver {  \n	listen       80;  \n	server_name  localhost;  \n	location / {  \n		root   html;  \n		index  index.html;  \n	}  \n	# 所有静态请求都由nginx处理，存放目录为html  \n	location  ~* \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {  \n		root   html;  \n	}  \n	# 所有动态请求都转发给tomcat处理  \n	location ~ *jsp$ {  \n		proxy_pass  http://tomcat; # 代理转发\n	}  \n	error_page   500 502 503 504  /50x.html;  \n	location = /50x.html {  \n		root  html;  \n	}  \n}\n</code></pre>\n<p><br/><br/><br/></p>\n<h2><a id=\"_proxy_pass_121\"></a>四、 反向代理----使用proxy_pass</h2>\n<pre><code class=\"lang-bash\">server {\n               listen       80;\n               server_name  blog.yilele.site;\n               index   index.html;            \n               location / {\n                        root /shan/blog/;\n                        index index.html;\n               }\n              location ~* \\.(jpg|jpeg|gif|png|swf|rar|zip|css|js|map|svg|woff|ttf|txt)$ {\n                          root /shan/blog/;\n                          index index.html;\n                          add_header Access-Control-Allow-Origin *;\n              }\n              # 反向代理\n              location /api {\n					proxy_pass http://ip地址或域名:端口号;\n               }  \n}\n</code></pre>\n<p><br/><br/><br/></p>\n<h1><a id=\"_nginx_springbootvue__150\"></a>☺ nginx 配置springboot+vue 前后端分离项目</h1>\n<h2><a id=\"1nginx__152\"></a>1、思路：nginx 结合自身特性，<code>本身一个静态资源的服务器</code>，</h2>\n<h3><a id=\"1_nginxnginx_154\"></a>(1) 通过nginx实现域名的方式访问网站，以及把对数据的请求通过nginx反向代理转发给后端容器(后端服务)，避免了接口暴露的不安全</h3>\n<h4><a id=\"__location__156\"></a>① 访问网站，首先习惯上访问网站的首页，通常访问路径是/ [location /]，然后默认页面是首页;</h4>\n<pre><code class=\"lang-bash\">location / {\n     root /shan/blog/;\n     index index.html;\n }\n</code></pre>\n<br/>\n<h4><a id=\"_cssjslocation_jpgjpeggifpngswfrarzipcssjsmapsvgwoffttftxtroot__167\"></a>② 默认页面，首页需要像css、js、图片等静态资源，才能显示出样式、动态效果等，需要通过匹配规则[location ~*.(jpg|jpeg|gif|png|swf|rar|zip|css|js|map|svg|woff|ttf|txt)$]，指定root 到那个目录下获取这些静态资源。</h4>\n<pre><code class=\"lang-bash\">location ~* \\.(jpg|jpeg|gif|png|swf|rar|zip|css|js|map|svg|woff|ttf|txt)$ {\n    root /shan/blog/;\n    index index.html;\n    add_header Access-Control-Allow-Origin *;\n }\n</code></pre>\n<br/>\n<h4><a id=\"__179\"></a>③ 默认首页，需要有数据</h4>\n<h5><a id=\"vue_springbootapi_location_api_springbootapi__181\"></a>在vue中首页实际上编写了很多个接口在请求数据，这些动态数据是来自 springboot项目(api 服务)，需要咱通过定义一个匹配接口路径的规则[location /api]，然后进行请求转发到 springboot项目(api 服务)</h5>\n<br/>\n<h2><a id=\"2dockerComposenginxspirngbootvue_187\"></a>2、通过dockerCompose+nginx配置实现部署spirngboot+vue前后端分离项目</h2>\n<h3><a id=\"1_dockerCompose__189\"></a>(1) dockerCompose 主要内容：</h3>\n<pre><code class=\"lang-yaml\">version: &quot;3&quot;\nservices:\n  api:\n    image: api\n    container_name: api\n    expose:\n      - &quot;8888&quot;\n  nginx:\n    image: nginx\n    container_name: nginx\n    ports:\n      - 80:80\n      - 443:443\n    volumes:\n      - /mnt/docker/nginx/:/etc/nginx/\n      - /mnt/shan/blog:/shan/blog\n    links:\n      - api\n    depends_on:\n      - api\n</code></pre>\n<p><br/><br/></p>\n<h3><a id=\"2_nginx__218\"></a>(2) nginx 主要配置：</h3>\n<pre><code class=\"lang-bash\">upstream apistream{\n        server api:8888;# 通过dockerCompose编排，服务名相当于域名\n}\n\nserver {\n               listen       80;\n               server_name  blog.yilele.site;\n               index   index.html;          \n               location / {\n                        root /shan/blog/;\n                        index index.html;\n               }\n              location ~* \\.(jpg|jpeg|gif|png|swf|rar|zip|css|js|map|svg|woff|ttf|txt)$ {\n                        root /shan/blog/;\n                        index index.html;\n                        add_header Access-Control-Allow-Origin *;\n              }\n              location /api {# 请求https://blog.yilele.site/api 会代理转发到 api:8888\n					  proxy_pass http://apistream;\n              }  \n}\n</code></pre>\n<p><br/><br/></p>\n<p><strong>如果本文对你有帮助的话记得给一乐点个赞哦，感谢！</strong></p>\n', 1548666437348409346);
INSERT INTO `ys_article_body` VALUES (1548667513564872707, '<br/>\n\n\n\n## 1、服务器外置防火墙\n\n服务器安全组，有的叫安全组；有的叫防火墙\n\n<br/> <br/>\n\n## 2、外置防火墙和内置防火墙\n\n外置防火墙(安全组/防火墙)\n\n内置防火墙(iptables/firewalld)\n\n<br/> <br/>\n\n## 3、防火墙作用：\n\n防火墙就像一个门，想象一下你的钱藏到你的房间，这时候有一个小偷想要来偷你的钱，小偷需要先溜进你家大门【外置防火墙(安全组/防火墙)】，\n\n然后再溜进你的房间【内置防火墙(iptables/firewalld)】\n\n<br/> \n\n> 虽然内置防火墙和外置防火墙一起使用更加安全，但是影响了数据访问的效率了，为了速度，有时候确保安全即可，不用更加安全。\n\n \n<br/><br/>\n \n\n## 4、购买好服务器，首先设置好外置防火墙\n\n(1) 阿里云服务器：配置放行80、443、ssh端口(ssh端口建议进行修改，不使用默认的22)\n\n(2) 腾讯云服务器：配置放行80、443、ping端口、ssh端口(ssh端口建议进行修改，不使用默认的22)\n\n \n<br/>\n \n\n### ☺ 购买了腾讯云服务的老铁要注意一下：\n\n#### 创建安全组，配置规则的时候，`不要选择放行所有端口，要选择自定义`，然后放行80、443、ping、ssh端口\n\n \n<br/><br/>\n \n\n## 5、修改ssh端口号\n\n> ### ☺ 修改22端口思路：\n>\n> 先在外置防火墙放行ssh的默认端口22，然后使用xshell远程连接工具进行连接，\n>\n> 然后在配置文件添加22端口、新端口，然后配置成功后，测试新端口可以用后再注释掉配置文件中的22端口，且禁止外置防火墙的22端口\n\n### (1) 在外置防火墙放行默认端口号22\n\n\n![b2c1414ac449426bae467d98b09fc824.png](https://niu.yilele.site/e255c1bc-5304-4f1e-bfa4-205c8b0a3d38.png)\n\n\n### (2) 编辑/etc/ssh/sshd_config文件，添加端口号\n\n ~~~bash\nvim /etc/ssh/sshd_config\n ~~~\n\n- 例如：添加端口22、12345，保存后退出\n\n> 添加两个端口中保留了22端口的目的：防止可能各种权限和配置问题，可以在测试成功后再关闭22端口\n\n- 新添加的端口号范围建议：大家修改端口时候最好挑10000~65535之间的端口号，**10000以下容易被系统或一些特殊软件占用，或是以后新应用准备占用该端口的时候，却被你先占用了，导致软件无法运行**。\n\n\n![35b1e591dc2e4963a76e4a57e86288db.png](https://niu.yilele.site/184ba455-3d5e-4c9f-811b-4934568e1a3f.png)\n\n\n\n<br/>\n\n\n###  (3) 重启sshd\n\n- CentOS 7.x 以上系统，执行命令\n\n~~~bash\nsystemctl restart sshd.service\n~~~\n\n- CentOS 6.x 以下系统，执行命令\n\n~~~bash\n/etc/init.d/sshd restart\n~~~\n\n\n<br/>\n\n\n###  (4) 添加防火墙规则，放行端口修改后的端口\n\n- 若是centos7 系统：\n\n~~~bash\n举例开放12345端口：\n★ 开启端口12345: firewall-cmd --zone=public --add-port=12345/tcp --permanent\n● 关闭端口12345: firewall-cmd --zone=public --remove-port=12345/tcp --permanent\n★ 重新加载：让规则生效： firewall-cmd --reload\n★ 查看 zone=public的端口的信息：firewall-cmd --list-ports --zone=public\n~~~\n\n- 若是centos6 系统：\n\n~~~bash\n# iptables配置文件位置/etc/sysconfig/iptables\n# 添加12345端口规则\niptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 12345 -j ACCEPT\n# 保存规则\nservice iptables save\n# 重启服务\nservice iptables restart\n~~~\n\n<br/>\n\n### (5) 外置防火墙禁止22端口，添加新配置的端口\n\n\n![da767d4c316e49d7b709c47da2d1b498.png](https://niu.yilele.site/2c43c211-2a06-4969-ae04-8943e02ec3ef.png)\n\n\n<br/>\n\n\n\n### (6) 修改xshell的属性中端口号，测试连接成功后，将ssh配置文件的22端口注释掉\n\n- 修改xshell的属性中端口号，测试连接:\n\n\n![e8eebf0788784620b47ff2d2f9c2b99e.png](https://niu.yilele.site/4b4440cb-503e-4bae-8cc9-ac70e43a6845.png)\n\n\n\n- 测试连接成功后，将ssh配置文件的22端口注释掉:\n\n~~~bash\nvim /etc/ssh/sshd_config\n~~~\n\n\n![c4a5c2a1a7c24fa18f673263e0314cc6.png](https://niu.yilele.site/e59853bd-b44d-471d-92dd-aea79578fedd.png)\n\n\n\n\n<br/><br/>\n\n## 6、开启防火墙只放行需要的端口的意义\n\n不需要随便向外暴露端口，不然会有安全隐患，总有一大堆机器扫描你的端口，尝试接入你的服务。\n\n尤其像redis端口，有可能会导致你中挖矿病毒；还有ssh端口22，公网中每时每刻都有人通过密码字典暴力破解试图登陆你的服务器。\n\n \n\n <br/><br/>\n\n \n\n## 7、总结使用服务器的安全常识\n\n★ **尽量少的对外暴露端口，且尽量修改默认端口号，尽量设置复杂的密码**\n\n**★ 不使用和不安装来源不明的软件**\n\n**★ 及时修复系统提示的漏洞以及软件已知的漏洞**\n\n**★ 定期检查日志**\n\n**★ 安装防病毒软件：** 卡巴斯基免费版能抵抗勒索病毒；安装banip软件，错误5次密码，拒绝24小时，防止暴力破解密码；\n\n<br/> \n\n### ☺ **尽量少的对外暴露端口**\n\n**首先暴露必须的端口 http(80)、https(443)、ssh端口(不使用默认的)、ping(腾讯服务器需要)；其他需要放行的端口，可以考虑使用nginx 进行代理转发**\n\n<br/> \n\n### ☺ 修改默认的端口：\n\n比如mysql 默认端口号是3306，需要使用mysql暴露在外的话，建议修改为mysql的配置文件改为其他端口号；\n\n同理，redis 要在公网使用的话，也是建议修改redis配置文件中端口号为其他端口号，不用默认的6379\n\n<br/> \n\n### ☺ 设置复杂密码：\n\n可以设置密码的都设置上，且密码不要设置太简单。\n\n比如mysql设置过于弱的密码，也能通过myql织入木马程序；又比如redis放行默认端口6379，然后又不设置redis密码，有可能被植入挖矿程序。\n\n\n \n<br/><br/>\n\n**如果本文对你有帮助的话记得给一乐点个赞哦，感谢！**\n \n\n \n\n \n\n ', '<br/>\n<h2><a id=\"1_4\"></a>1、服务器外置防火墙</h2>\n<p>服务器安全组，有的叫安全组；有的叫防火墙</p>\n<p><br/> <br/></p>\n<h2><a id=\"2_10\"></a>2、外置防火墙和内置防火墙</h2>\n<p>外置防火墙(安全组/防火墙)</p>\n<p>内置防火墙(iptables/firewalld)</p>\n<p><br/> <br/></p>\n<h2><a id=\"3_18\"></a>3、防火墙作用：</h2>\n<p>防火墙就像一个门，想象一下你的钱藏到你的房间，这时候有一个小偷想要来偷你的钱，小偷需要先溜进你家大门【外置防火墙(安全组/防火墙)】，</p>\n<p>然后再溜进你的房间【内置防火墙(iptables/firewalld)】</p>\n<br/> \n<blockquote>\n<p>虽然内置防火墙和外置防火墙一起使用更加安全，但是影响了数据访问的效率了，为了速度，有时候确保安全即可，不用更加安全。</p>\n</blockquote>\n<p><br/><br/></p>\n<h2><a id=\"4_32\"></a>4、购买好服务器，首先设置好外置防火墙</h2>\n<p>(1) 阿里云服务器：配置放行80、443、ssh端口(ssh端口建议进行修改，不使用默认的22)</p>\n<p>(2) 腾讯云服务器：配置放行80、443、ping端口、ssh端口(ssh端口建议进行修改，不使用默认的22)</p>\n<br/>\n<h3><a id=\"__42\"></a>☺ 购买了腾讯云服务的老铁要注意一下：</h3>\n<h4><a id=\"80443pingssh_44\"></a>创建安全组，配置规则的时候，<code>不要选择放行所有端口，要选择自定义</code>，然后放行80、443、ping、ssh端口</h4>\n<p><br/><br/></p>\n<h2><a id=\"5ssh_50\"></a>5、修改ssh端口号</h2>\n<blockquote>\n<h3><a id=\"_22_52\"></a>☺ 修改22端口思路：</h3>\n<p>先在外置防火墙放行ssh的默认端口22，然后使用xshell远程连接工具进行连接，</p>\n<p>然后在配置文件添加22端口、新端口，然后配置成功后，测试新端口可以用后再注释掉配置文件中的22端口，且禁止外置防火墙的22端口</p>\n</blockquote>\n<h3><a id=\"1_22_58\"></a>(1) 在外置防火墙放行默认端口号22</h3>\n<p><img src=\"https://niu.yilele.site/e255c1bc-5304-4f1e-bfa4-205c8b0a3d38.png\" alt=\"b2c1414ac449426bae467d98b09fc824.png\" /></p>\n<h3><a id=\"2_etcsshsshd_config_64\"></a>(2) 编辑/etc/ssh/sshd_config文件，添加端口号</h3>\n<pre><code class=\"lang-bash\">vim /etc/ssh/sshd_config\n</code></pre>\n<ul>\n<li>例如：添加端口22、12345，保存后退出</li>\n</ul>\n<blockquote>\n<p>添加两个端口中保留了22端口的目的：防止可能各种权限和配置问题，可以在测试成功后再关闭22端口</p>\n</blockquote>\n<ul>\n<li>新添加的端口号范围建议：大家修改端口时候最好挑10000~65535之间的端口号，<strong>10000以下容易被系统或一些特殊软件占用，或是以后新应用准备占用该端口的时候，却被你先占用了，导致软件无法运行</strong>。</li>\n</ul>\n<p><img src=\"https://niu.yilele.site/184ba455-3d5e-4c9f-811b-4934568e1a3f.png\" alt=\"35b1e591dc2e4963a76e4a57e86288db.png\" /></p>\n<br/>\n<h3><a id=\"3_sshd_84\"></a>(3) 重启sshd</h3>\n<ul>\n<li>CentOS 7.x 以上系统，执行命令</li>\n</ul>\n<pre><code class=\"lang-bash\">systemctl restart sshd.service\n</code></pre>\n<ul>\n<li>CentOS 6.x 以下系统，执行命令</li>\n</ul>\n<pre><code class=\"lang-bash\">/etc/init.d/sshd restart\n</code></pre>\n<br/>\n<h3><a id=\"4__102\"></a>(4) 添加防火墙规则，放行端口修改后的端口</h3>\n<ul>\n<li>若是centos7 系统：</li>\n</ul>\n<pre><code class=\"lang-bash\">举例开放12345端口：\n★ 开启端口12345: firewall-cmd --zone=public --add-port=12345/tcp --permanent\n● 关闭端口12345: firewall-cmd --zone=public --remove-port=12345/tcp --permanent\n★ 重新加载：让规则生效： firewall-cmd --reload\n★ 查看 zone=public的端口的信息：firewall-cmd --list-ports --zone=public\n</code></pre>\n<ul>\n<li>若是centos6 系统：</li>\n</ul>\n<pre><code class=\"lang-bash\"># iptables配置文件位置/etc/sysconfig/iptables\n# 添加12345端口规则\niptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 12345 -j ACCEPT\n# 保存规则\nservice iptables save\n# 重启服务\nservice iptables restart\n</code></pre>\n<br/>\n<h3><a id=\"5_22_128\"></a>(5) 外置防火墙禁止22端口，添加新配置的端口</h3>\n<p><img src=\"https://niu.yilele.site/2c43c211-2a06-4969-ae04-8943e02ec3ef.png\" alt=\"da767d4c316e49d7b709c47da2d1b498.png\" /></p>\n<br/>\n<h3><a id=\"6_xshellssh22_138\"></a>(6) 修改xshell的属性中端口号，测试连接成功后，将ssh配置文件的22端口注释掉</h3>\n<ul>\n<li>修改xshell的属性中端口号，测试连接:</li>\n</ul>\n<p><img src=\"https://niu.yilele.site/4b4440cb-503e-4bae-8cc9-ac70e43a6845.png\" alt=\"e8eebf0788784620b47ff2d2f9c2b99e.png\" /></p>\n<ul>\n<li>测试连接成功后，将ssh配置文件的22端口注释掉:</li>\n</ul>\n<pre><code class=\"lang-bash\">vim /etc/ssh/sshd_config\n</code></pre>\n<p><img src=\"https://niu.yilele.site/e59853bd-b44d-471d-92dd-aea79578fedd.png\" alt=\"c4a5c2a1a7c24fa18f673263e0314cc6.png\" /></p>\n<p><br/><br/></p>\n<h2><a id=\"6_161\"></a>6、开启防火墙只放行需要的端口的意义</h2>\n<p>不需要随便向外暴露端口，不然会有安全隐患，总有一大堆机器扫描你的端口，尝试接入你的服务。</p>\n<p>尤其像redis端口，有可能会导致你中挖矿病毒；还有ssh端口22，公网中每时每刻都有人通过密码字典暴力破解试图登陆你的服务器。</p>\n<p><br/><br/></p>\n<h2><a id=\"7_173\"></a>7、总结使用服务器的安全常识</h2>\n<p>★ <strong>尽量少的对外暴露端口，且尽量修改默认端口号，尽量设置复杂的密码</strong></p>\n<p><strong>★ 不使用和不安装来源不明的软件</strong></p>\n<p><strong>★ 及时修复系统提示的漏洞以及软件已知的漏洞</strong></p>\n<p><strong>★ 定期检查日志</strong></p>\n<p><strong>★ 安装防病毒软件：</strong> 卡巴斯基免费版能抵抗勒索病毒；安装banip软件，错误5次密码，拒绝24小时，防止暴力破解密码；</p>\n<br/> \n<h3><a id=\"__187\"></a>☺ <strong>尽量少的对外暴露端口</strong></h3>\n<p><strong>首先暴露必须的端口 http(80)、https(443)、ssh端口(不使用默认的)、ping(腾讯服务器需要)；其他需要放行的端口，可以考虑使用nginx 进行代理转发</strong></p>\n<br/> \n<h3><a id=\"__193\"></a>☺ 修改默认的端口：</h3>\n<p>比如mysql 默认端口号是3306，需要使用mysql暴露在外的话，建议修改为mysql的配置文件改为其他端口号；</p>\n<p>同理，redis 要在公网使用的话，也是建议修改redis配置文件中端口号为其他端口号，不用默认的6379</p>\n<br/> \n<h3><a id=\"__201\"></a>☺ 设置复杂密码：</h3>\n<p>可以设置密码的都设置上，且密码不要设置太简单。</p>\n<p>比如mysql设置过于弱的密码，也能通过myql织入木马程序；又比如redis放行默认端口6379，然后又不设置redis密码，有可能被植入挖矿程序。</p>\n<p><br/><br/></p>\n<p><strong>如果本文对你有帮助的话记得给一乐点个赞哦，感谢！</strong></p>\n', 1548667513564872705);
INSERT INTO `ys_article_body` VALUES (1548673409732886532, '<br/>\n\n\n\n## 一、问题现象\n\n### 1、现象举例：\n\n~~~bash\n# 自制的springboot项目的dockerfile\n# springboot 其实就是一个简单的hello-world程序，写了一个HelloController 做测试\n# dockerfile内容：\nFROM java:8 \nMAINTAINER shan <test@qq2363581677@163.com> \nADD ./demo.jar /demo.jar\nEXPOSE 8848\nCMD java -jar /demo.jar\n\n\n# 构建镜像\ndocker build -f ./dockerfile -t demo .\n\n# 创建、映射端口、运行容器\ndocker run -d --name=demo -p 8838:8848 demo\n~~~\n\n> 在阿里云服务器上外置的防火墙或安全组放行端口 8838 后，在浏览器发现可以直接访问到数据\n>\n> ----问题在于咱还没有开启内置的防火墙firewalld，却出现了端口可以直接被访问的情况\n\n<br/>\n\n### 2、使用centos7 的防火墙firewalld查看放行端口情况\n\n\n![5713be4bbf73433eac0b0f56638a696d.png](https://niu.yilele.site/22a71066-9338-4f72-8778-953e48044036.png)\n\n\n![8456b380d2934a079ada22fbac549299.png](https://niu.yilele.site/d898e5d2-9a46-4119-931f-2622f1ad0b50.png)\n\n\n> 使用 docker 来部署项目，发现直接使用 -p 映射端口，会出现问题：\n>\n> 导致docker直接透过系统本机的防火墙，不用开端口可以直接外网访问 8838 端口。\n\n\n\n<br/><br/><br/>\n\n\n\n## 二、问题原因\n\n### 1、docker无视防火墙firewalld 的原因：其实docker并不是绕过了防火墙，<font color=red>只是因为它往iptables里写了规则，你在firewalld里看不到而已。</font>(centos7系统既有iptables，也有firewalld)\n\n### `在docker安装完后，会接管iptables，只要你docker run的时候加入参数，他会自动向iptables里面添加规则。`所以使用 -p 容器端口:主机端口，最终会在iptables中添加上容器的端口。\n\n\n<br/><br/>\n\n\n### ☺ 防火墙 iptables 和 firewalld 的关系\n\nIptables：**是centos6自带的防火墙工具**，对服务器自身、网络通信流量进行控制，用于过滤数据包，属于网络层防火墙。\n\nFirewallD：**是centos7自带的防火墙工具**，但是也同样支持iptables。能够允许哪些服务可用，哪些端口可用，属于更高一层的防火墙。\n\n> **iptables 与 firewalld 都不是真正的防火墙， 它们都只是用来定义防火墙策略的防火墙管理工具。**\n\n### ● 对于 centos7 系统既有iptables，也有firewalld\n\n\n<br/><br/>\n\n\n### 2、使用 iptables的命令可以查看到docker 容器的端口\n\n~~~bash\niptables -L DOCKER\n~~~\n\n\n![067e63219cb14d0ca5477bc7e60dd042.png](https://niu.yilele.site/4ee4f40a-5ad2-4218-adb4-75fdd93b621b.png)\n\n\n\n\n\n<br/><br/><br/>\n\n\n\n\n## 三、问题的解决\n\n### 1、依靠阿里云服务器提供的外置防火墙（`推荐`）\n\n- 有的服务器叫防火墙，有的服务器叫安全组，都是一个东西，都是系统的外置防火墙。\n\n- 防火墙就像一个门，想象一下你的钱藏到你的房间，这时候有一个小偷想要来偷你的钱，小偷需要先溜进你家大门【外置防火墙(安全组/防火墙)】，然后再溜进你的房间【内置防火墙(iptables/firewalld)】。\n\n### 解决方式1：依靠阿里云服务器提供的外置防火墙放行需要暴露给外界的端口\n\n- 相当于关闭了你家大门\n\n> 虽然内置防火墙和外置防火墙一起使用更加安全，但是影响了数据访问的效率了，为了速度，有时候确保安全即可，不用更加安全。\n\n<br/>\n\n#### ☺ 购买了腾讯云服务的老铁要注意一下：\n\n配置安全组的时候，不要选择放行所有端口，要选择自定义，然后放行80、443、ping、ssh端口(ssh端口建议进行修改，不使用默认的22)\n\n\n\n<br/><br/>\n\n\n\n### 2、端口映射时指定监听地址为本机\n\n> 对于那些只需要在本地访问，不需要向外暴露端口的服务，在进行端口映射的时候指定监听地址为127.0.0.1。\n\n~~~bash\n# 创建、映射端口、运行容器\ndocker run -d --name=demo -p 127.0.0.1:8838:8848 demo\n~~~\n\n- 这时候，外界(通过浏览器)就无法访问了到8838 端口了，即使在外置防火墙放行了端口。\n\n\n<br/><br/>\n\n\n\n\n### 3、禁用 docker 的 iptables 规则\n\n- 原因就是docker 在iptables 加入规则，才导致内置防火墙放行了docker容器的端口，现在咱就根治它，在docker配置文件禁止修改iptables 规则。\n\n① docker 配置修改，禁止 iptables 规则\n\n```\n# 编辑/lib/systemd/system/docker.service文件\n\n# 在ExecStart后添加 --iptables=false \n```\n\n② 重载 docker 配置 & 重启 docker 服务\n\n```\nsystemctl daemon-reload\nsystemctl restart docker\n```\n\n完成上述两步以及可以采用系统 firewall 控制端口访问，但会**出现 docker 容器间无法访问，而且容器内也无法访问外部网络**。\n\n③ 使用类似 NAT 网络方式使得 docker 可以访问外部网络\n\n```\nfirewall-cmd --permanent --zone=public --add-masquerade\n```\n\n- 使用该方法解决 docker 无视系统防火墙问题所带来的缺点：**容器内无法获取得到客户端的真实 IP**，由于是类似 NAT 网络，常常 nginx 日志上记录的是 docker0 网络的子网 IP，对于一些业务无法获取真实 IP 可能不能容忍，看个人的取舍吧。\n\n\n\n\n<br/><br/>\n\n\n### 4、使用 expose 方式暴露端口，然后采用 nginx 代理转发(`推荐`)\n\n#### (1) 使用dockerCompose 编排+nginx代理转发\n\n##### ① dockerCompose 中编排内容：\n\n~~~yaml\nversion: \"3\"\nservices:\n  app:\n    image: app\n    container_name: app\n    build: ..\n    expose:\n     - \"8888\"\n    depends_on:\n      - mysql\n      - redis\n  nginx:\n    image: nginx\n    container_name: nginx\n    ports:\n      - 80:80\n      - 443:443\n    volumes:\n      - /mnt/docker/nginx/:/etc/nginx/\n    links:\n      - app\n    depends_on:\n      - app\n~~~\n\n##### ② nginx 中的配置：\n\n~~~bash\nupstream appstream{\n        server app:8888; #dockerCompose编排之后，app服务名相当于域名，可以通过app找到对应的ip地址\n}\n\nserver{\n        listen 80;\n        server_name blog.yilele.site; \n        location /api {\n			proxy_pass http://appstream;#nginx代理转发\n        }\n}\n~~~\n\n<br/>\n\n### (2) 上面例子的demo容器(使用dockerfile)+ nginx\n\n~~~bash\nserver{\n        listen 80;\n        server_name blog.yilele.site; \n        location /hello {# 启动docker的demo容器后，可以通过命令：docker inspect demo 找到demo对应的ip地址\n			proxy_pass http://demo的ip地址:8888;   # nginx代理转发\n        }\n}\n~~~\n\n\n\n<br/><br/>\n\n\n\n#### ☺ ports 和 expose 区别：\n\n- ports: 暴露容器端口到主机的任意端口或指定端口。不管是否指定主机端口，使用ports都会将端口暴露给**主机和其他容器**。\n\n  ~~~bash\n   - \"9000:8080\"     # 绑定容器的8080端口到主机的9000端口\n    - \"443\"          # 绑定容器的443端口到主机的任意端口，容器启动时随机分配绑定的主机端口号\n  ~~~\n\n- expose: 暴露容器给`link`到当前容器的容器。即暴露给处于同一个networks的容器。搭配link 进行使用。\n\n  ~~~bash\n  expose:\n    - \"8000\"\n  ~~~\n\n\n\n<br/><br/>\n\n\n\n参考文章：《docker无视防火墙问题总结》 https://icharle.com/dockeriptables.html\n\n\n<br/><br/>\n\n**如果本文对你有帮助的话记得给一乐点个赞哦，感谢！**', '<br/>\n<h2><a id=\"_4\"></a>一、问题现象</h2>\n<h3><a id=\"1_6\"></a>1、现象举例：</h3>\n<pre><code class=\"lang-bash\"># 自制的springboot项目的dockerfile\n# springboot 其实就是一个简单的hello-world程序，写了一个HelloController 做测试\n# dockerfile内容：\nFROM java:8 \nMAINTAINER shan &lt;test@qq2363581677@163.com&gt; \nADD ./demo.jar /demo.jar\nEXPOSE 8848\nCMD java -jar /demo.jar\n\n\n# 构建镜像\ndocker build -f ./dockerfile -t demo .\n\n# 创建、映射端口、运行容器\ndocker run -d --name=demo -p 8838:8848 demo\n</code></pre>\n<blockquote>\n<p>在阿里云服务器上外置的防火墙或安全组放行端口 8838 后，在浏览器发现可以直接访问到数据</p>\n<p>----问题在于咱还没有开启内置的防火墙firewalld，却出现了端口可以直接被访问的情况</p>\n</blockquote>\n<br/>\n<h3><a id=\"2centos7_firewalld_32\"></a>2、使用centos7 的防火墙firewalld查看放行端口情况</h3>\n<p><img src=\"https://niu.yilele.site/22a71066-9338-4f72-8778-953e48044036.png\" alt=\"5713be4bbf73433eac0b0f56638a696d.png\" /></p>\n<p><img src=\"https://niu.yilele.site/d898e5d2-9a46-4119-931f-2622f1ad0b50.png\" alt=\"8456b380d2934a079ada22fbac549299.png\" /></p>\n<blockquote>\n<p>使用 docker 来部署项目，发现直接使用 -p 映射端口，会出现问题：</p>\n<p>导致docker直接透过系统本机的防火墙，不用开端口可以直接外网访问 8838 端口。</p>\n</blockquote>\n<p><br/><br/><br/></p>\n<h2><a id=\"_51\"></a>二、问题原因</h2>\n<h3><a id=\"1dockerfirewalld_dockerfont_colorrediptablesfirewalldfontcentos7iptablesfirewalld_53\"></a>1、docker无视防火墙firewalld 的原因：其实docker并不是绕过了防火墙，<font color=red>只是因为它往iptables里写了规则，你在firewalld里看不到而已。</font>(centos7系统既有iptables，也有firewalld)</h3>\n<h3><a id=\"dockeriptablesdocker_runiptables_p_iptables_55\"></a><code>在docker安装完后，会接管iptables，只要你docker run的时候加入参数，他会自动向iptables里面添加规则。</code>所以使用 -p 容器端口:主机端口，最终会在iptables中添加上容器的端口。</h3>\n<p><br/><br/></p>\n<h3><a id=\"__iptables__firewalld__61\"></a>☺ 防火墙 iptables 和 firewalld 的关系</h3>\n<p>Iptables：<strong>是centos6自带的防火墙工具</strong>，对服务器自身、网络通信流量进行控制，用于过滤数据包，属于网络层防火墙。</p>\n<p>FirewallD：<strong>是centos7自带的防火墙工具</strong>，但是也同样支持iptables。能够允许哪些服务可用，哪些端口可用，属于更高一层的防火墙。</p>\n<blockquote>\n<p><strong>iptables 与 firewalld 都不是真正的防火墙， 它们都只是用来定义防火墙策略的防火墙管理工具。</strong></p>\n</blockquote>\n<h3><a id=\"__centos7_iptablesfirewalld_69\"></a>● 对于 centos7 系统既有iptables，也有firewalld</h3>\n<p><br/><br/></p>\n<h3><a id=\"2_iptablesdocker__75\"></a>2、使用 iptables的命令可以查看到docker 容器的端口</h3>\n<pre><code class=\"lang-bash\">iptables -L DOCKER\n</code></pre>\n<p><img src=\"https://niu.yilele.site/4ee4f40a-5ad2-4218-adb4-75fdd93b621b.png\" alt=\"067e63219cb14d0ca5477bc7e60dd042.png\" /></p>\n<p><br/><br/><br/></p>\n<h2><a id=\"_93\"></a>三、问题的解决</h2>\n<h3><a id=\"1_95\"></a>1、依靠阿里云服务器提供的外置防火墙（<code>推荐</code>）</h3>\n<ul>\n<li>\n<p>有的服务器叫防火墙，有的服务器叫安全组，都是一个东西，都是系统的外置防火墙。</p>\n</li>\n<li>\n<p>防火墙就像一个门，想象一下你的钱藏到你的房间，这时候有一个小偷想要来偷你的钱，小偷需要先溜进你家大门【外置防火墙(安全组/防火墙)】，然后再溜进你的房间【内置防火墙(iptables/firewalld)】。</p>\n</li>\n</ul>\n<h3><a id=\"1_101\"></a>解决方式1：依靠阿里云服务器提供的外置防火墙放行需要暴露给外界的端口</h3>\n<ul>\n<li>相当于关闭了你家大门</li>\n</ul>\n<blockquote>\n<p>虽然内置防火墙和外置防火墙一起使用更加安全，但是影响了数据访问的效率了，为了速度，有时候确保安全即可，不用更加安全。</p>\n</blockquote>\n<br/>\n<h4><a id=\"__109\"></a>☺ 购买了腾讯云服务的老铁要注意一下：</h4>\n<p>配置安全组的时候，不要选择放行所有端口，要选择自定义，然后放行80、443、ping、ssh端口(ssh端口建议进行修改，不使用默认的22)</p>\n<p><br/><br/></p>\n<h3><a id=\"2_119\"></a>2、端口映射时指定监听地址为本机</h3>\n<blockquote>\n<p>对于那些只需要在本地访问，不需要向外暴露端口的服务，在进行端口映射的时候指定监听地址为127.0.0.1。</p>\n</blockquote>\n<pre><code class=\"lang-bash\"># 创建、映射端口、运行容器\ndocker run -d --name=demo -p 127.0.0.1:8838:8848 demo\n</code></pre>\n<ul>\n<li>这时候，外界(通过浏览器)就无法访问了到8838 端口了，即使在外置防火墙放行了端口。</li>\n</ul>\n<p><br/><br/></p>\n<h3><a id=\"3_docker__iptables__136\"></a>3、禁用 docker 的 iptables 规则</h3>\n<ul>\n<li>原因就是docker 在iptables 加入规则，才导致内置防火墙放行了docker容器的端口，现在咱就根治它，在docker配置文件禁止修改iptables 规则。</li>\n</ul>\n<p>① docker 配置修改，禁止 iptables 规则</p>\n<pre><code class=\"lang-\"># 编辑/lib/systemd/system/docker.service文件\n\n# 在ExecStart后添加 --iptables=false \n</code></pre>\n<p>② 重载 docker 配置 &amp; 重启 docker 服务</p>\n<pre><code class=\"lang-\">systemctl daemon-reload\nsystemctl restart docker\n</code></pre>\n<p>完成上述两步以及可以采用系统 firewall 控制端口访问，但会<strong>出现 docker 容器间无法访问，而且容器内也无法访问外部网络</strong>。</p>\n<p>③ 使用类似 NAT 网络方式使得 docker 可以访问外部网络</p>\n<pre><code class=\"lang-\">firewall-cmd --permanent --zone=public --add-masquerade\n</code></pre>\n<ul>\n<li>使用该方法解决 docker 无视系统防火墙问题所带来的缺点：<strong>容器内无法获取得到客户端的真实 IP</strong>，由于是类似 NAT 网络，常常 nginx 日志上记录的是 docker0 网络的子网 IP，对于一些业务无法获取真实 IP 可能不能容忍，看个人的取舍吧。</li>\n</ul>\n<p><br/><br/></p>\n<h3><a id=\"4_expose__nginx__171\"></a>4、使用 expose 方式暴露端口，然后采用 nginx 代理转发(<code>推荐</code>)</h3>\n<h4><a id=\"1_dockerCompose_nginx_173\"></a>(1) 使用dockerCompose 编排+nginx代理转发</h4>\n<h5><a id=\"_dockerCompose__175\"></a>① dockerCompose 中编排内容：</h5>\n<pre><code class=\"lang-yaml\">version: &quot;3&quot;\nservices:\n  app:\n    image: app\n    container_name: app\n    build: ..\n    expose:\n     - &quot;8888&quot;\n    depends_on:\n      - mysql\n      - redis\n  nginx:\n    image: nginx\n    container_name: nginx\n    ports:\n      - 80:80\n      - 443:443\n    volumes:\n      - /mnt/docker/nginx/:/etc/nginx/\n    links:\n      - app\n    depends_on:\n      - app\n</code></pre>\n<h5><a id=\"_nginx__203\"></a>② nginx 中的配置：</h5>\n<pre><code class=\"lang-bash\">upstream appstream{\n        server app:8888; #dockerCompose编排之后，app服务名相当于域名，可以通过app找到对应的ip地址\n}\n\nserver{\n        listen 80;\n        server_name blog.yilele.site; \n        location /api {\n			proxy_pass http://appstream;#nginx代理转发\n        }\n}\n</code></pre>\n<br/>\n<h3><a id=\"2_demodockerfile_nginx_221\"></a>(2) 上面例子的demo容器(使用dockerfile)+ nginx</h3>\n<pre><code class=\"lang-bash\">server{\n        listen 80;\n        server_name blog.yilele.site; \n        location /hello {# 启动docker的demo容器后，可以通过命令：docker inspect demo 找到demo对应的ip地址\n			proxy_pass http://demo的ip地址:8888;   # nginx代理转发\n        }\n}\n</code></pre>\n<p><br/><br/></p>\n<h4><a id=\"_ports__expose__239\"></a>☺ ports 和 expose 区别：</h4>\n<ul>\n<li>\n<p>ports: 暴露容器端口到主机的任意端口或指定端口。不管是否指定主机端口，使用ports都会将端口暴露给<strong>主机和其他容器</strong>。</p>\n<pre><code class=\"lang-bash\"> - &quot;9000:8080&quot;     # 绑定容器的8080端口到主机的9000端口\n  - &quot;443&quot;          # 绑定容器的443端口到主机的任意端口，容器启动时随机分配绑定的主机端口号\n</code></pre>\n</li>\n<li>\n<p>expose: 暴露容器给<code>link</code>到当前容器的容器。即暴露给处于同一个networks的容器。搭配link 进行使用。</p>\n<pre><code class=\"lang-bash\">expose:\n  - &quot;8000&quot;\n</code></pre>\n</li>\n</ul>\n<p><br/><br/></p>\n<p>参考文章：《docker无视防火墙问题总结》 https://icharle.com/dockeriptables.html</p>\n<p><br/><br/></p>\n<p><strong>如果本文对你有帮助的话记得给一乐点个赞哦，感谢！</strong></p>\n', 1548673409732886530);
INSERT INTO `ys_article_body` VALUES (1548674022520700930, '<br/>\n\n\n\n\n\n# 一、代理模式基本介绍\n\n### 1、什么是代理模式\n\n为一个对象**`提供一个替身`**，**以控制对这个对象的访问**。即**通过代理对象访问目标对象**.\n\n客户端直接使用的都是`代理对象`，**并不知道真实对象是谁**，此时代理对象可以在客户端和真实对象之间起到**`中介作用`.**\n\n<br/>\n\n### 2、代理模式的作用\n\n**(1) 中介作用：代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。**\n\n**(2) 职责清晰作用: 可以使真实角色的操作更加纯粹,不用去关注一些公共的业务。公共也就交给代理角色,实现了业务的分工。**\n\n<br/>\n\n### 3、代理模式的组成(角色分析)：\n\n- **抽象角色**: 一般使用接口或抽象类\n- **真实角色**: 被代理的角色[目标对象]\n- **代理角色**: 代理真实角色,代理真实角色后,我们一般会做一些附属操作[代理对象]\n\n<br/>\n\n### 4、代理模式分类：\n\n- **静态代理**\n- **动态代理(jdk代理、cglib代理)**\n\n\n<br/><br/>\n\n\n## 二、静态代理\n\n### 1、静态代理实现过程：\n\n静态代理在使用时，需要定义接口或者父类[抽象角色],**被代理对象[真实角色]与代理对象[代理角色]一起实现相同的接口或者是继承相同父类**。\n\n<br/>\n\n### 2、静态代理代码：\n\n(1) **通过接口聚合的方式，`维护一个目标对象`**\n\n(2) **通过构造器，对目标对象进行初始化**\n\n~~~java\n//代理对象,静态代理\npublic class TeacherDaoProxy implements ITeacherDao{\n	\n	private ITeacherDao target; // 目标对象，通过接口来聚合\n	\n	\n	//构造器\n	public TeacherDaoProxy(ITeacherDao target) {\n		this.target = target;\n	}\n\n\n\n	@Override\n	public void teach() {\n		// TODO Auto-generated method stub\n		System.out.println(\"开始代理  完成某些操作。。。。。 \");//方法\n		target.teach();\n		System.out.println(\"提交。。。。。\");//方法\n	}\n\n}\n~~~\n\n<br/>\n\n### 3、静态代理优缺点：\n\n> 优点\n\n**在不修改目标对象的功能前提下**, **能通过代理对象对目标功能扩展**\n\n> 缺点\n\n- 因为代理对象需要与目标对象**实现一样的接口**,所以**会有很多代理类**\n- 一旦**接口增加方法,目标对象与代理对象都要维护**\n\n\n<br/>\n\n\n###  4、静态代理和动态代理的区别：\n\n##### (1) 简单说，就是代理对象是否是动态生成的，静态代理不是，动态代理是。\n\n##### (2) 详细说，考虑代理类的字节码的编译运行情况，考虑在程序运行前是否就已经存在代理类的字节码文件，静态代理是已经存在，动态代理不是，是等到程序运行时由jvm通过反射等机制动态生成的。\n\n> #####  ■ 静态代理：（经历了**`编译`**和运行）\n>\n> `在程序运行前就已经存在代理类的字节码文件`(因为通过了编译阶段)，`代理对象和真实对象的关系在运行前就确定了`(因为通过了编译阶段)。\n>\n> #####  ■ 动态代理：(`只经历了运行`，咱通过某种手段(例如反射等)得到的字节码【遵循字节码格式和结构】）\n>\n> 动态代理类是在程序运行期间由jvm通过反射等机制动态生成的，所以**`不存在代理类的字节码文件`**(因为没有经历编译阶段)，`代理对象和真实对象的关系是在程序运行期间才确定的`。\n\n\n\n\n<br/><br/>\n\n\n\n\n## 三、动态代理之jdk代理\n\n> 动态代理包括：jdk代理和cglib代理\n\n### 1、动态代理jdk 和 cglib 区别：\n\n**目标对象是否需要实现接口，jdk需要，cglib不需要。jdk代理的代理对象是利用反射机制动态生成，而cglib的代理对象是利用拦截机制动态生成。**\n\n<br/>\n\n### 2、jdk代理基本介绍\n\n- 代理对象, 不需要实现接口，但是目标对象要实现接口，否则不能用动态代理 \n- **代理对象的生成，是利用JDK的API(利用反射机制)，动态的在内存中构建代理对象**\n- **JDK代理也叫做接口代理**\n\n<br/>\n\n### 3、JDK中生成代理对象的API\n\n 1) 代理类所在包:java.lang.**reflect.Proxy** \n\n 2) JDK实现代理只需要**使用newProxyInstance方法**,但是该方法需要接收三个参数,\n\n完整的写法是:  static Object newProxyInstance(ClassLoader loader, Class[]  interfaces,InvocationHandler h )\n\n~~~java\n//1. ClassLoader loader： 指定当前目标对象使用的类加载器, 获取加载器的方法固定\n//2. Class<?>[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型\n//3. InvocationHandler h: 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传\n~~~\n\n<br/>\n\n### 4、jdk代理的代码\n\n~~~java\n//jdk代理，代理工厂，生成代理对象\npublic class ProxyFactory {\n\n	//维护一个目标对象 , Object\n	private Object target;\n\n	//构造器 ， 对target 进行初始化\n	public ProxyFactory(Object target) {\n		\n		this.target = target;\n	} \n	\n	//给目标对象 生成一个代理对象\n	public Object getProxyInstance() {\n		\n		//说明\n		/*\n		 *  public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n                                          \n            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定\n            //2. Class<?>[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型\n            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入\n		 */\n		return Proxy.newProxyInstance(target.getClass().getClassLoader(), \n				target.getClass().getInterfaces(), \n				new InvocationHandler() {\n					\n					@Override\n					public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n						// TODO Auto-generated method stub\n						System.out.println(\"JDK代理开始~~\");\n						//反射机制调用目标对象的方法\n						Object returnVal = method.invoke(target, args);\n						System.out.println(\"JDK代理提交\");\n						return returnVal;\n					}\n				}); \n	}\n	\n}\n~~~\n\n\n\n\n\n<br/><br/>\n\n\n\n## 四、动态代理之cglib代理\n\n> 动态代理包括：jdk代理和cglib代理\n\n### 1、动态代理jdk 和 cglib 区别：\n\n**目标对象是否需要实现接口，jdk需要，cglib不需要。jdk代理的代理对象是利用反射机制动态生成，而cglib的代理对象是利用拦截机制动态生成。**\n\n<br/>\n\n### 2、cglib代理基本介绍\n\n**Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展。**\n\n<br/>\n\n### 3、在AOP编程中如何选择代理模式：\n\n(1) 目标对象需要实现接口，用JDK代理\n\n(2) 目标对象不需要实现接口，用Cglib代理\n\n\n\n<br/>\n\n### 4、cglib 代理的代码：\n\n~~~java\npublic class ProxyFactory implements MethodInterceptor {\n\n	//维护一个目标对象\n	private Object target;\n	\n	//构造器，传入一个被代理的对象\n	public ProxyFactory(Object target) {\n		this.target = target;\n	}\n\n	//返回一个代理对象:  是 target 对象的代理对象\n	public Object getProxyInstance() {\n		//1. 创建一个工具类\n		Enhancer enhancer = new Enhancer();\n		//2. 设置父类\n		enhancer.setSuperclass(target.getClass());\n		//3. 设置回调函数\n		enhancer.setCallback(this);\n		//4. 创建子类对象，即代理对象\n		return enhancer.create();\n		\n	}\n	\n\n	//重写  intercept 方法，会调用目标对象的方法\n	@Override\n	public Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable {\n		// TODO Auto-generated method stub\n		System.out.println(\"Cglib代理模式 ~~ 开始\");\n		Object returnVal = method.invoke(target, args);\n		System.out.println(\"Cglib代理模式 ~~ 提交\");\n		return returnVal;\n	}\n\n}\n~~~\n\n\n\n<br/><br/>\n\n\n\n## 五、扩展---代理模式(Proxy)的变体\n\n### 1、几种常见的代理模式介绍— 几种变体\n\n(1) **防火墙代理**: 内网通过代理穿透防火墙，实现对公网的访问。\n\n(2) **缓存代理**: 比如当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok,如果取不到资源，再到公网或者数据库取，然后缓存。\n\n(3) **远程代理**: 远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和 真正的远程对象沟通信息。\n\n(4) **同步代理**：主要使用在多线程编程中，完成多线程间同步工作。\n\n\n<br/><br/>\n\n参考内容来源：《尚硅谷Java设计模式（图解+框架源码剖析）》 https://www.bilibili.com/video/BV1G4411c7N4\n\n\n\n<br/><br/>\n\n**如果本文对你有帮助的话记得给一乐点个赞哦，感谢！**', '<br/>\n<h1><a id=\"_6\"></a>一、代理模式基本介绍</h1>\n<h3><a id=\"1_8\"></a>1、什么是代理模式</h3>\n<p>为一个对象**<code>提供一个替身</code><strong>，<strong>以控制对这个对象的访问</strong>。即</strong>通过代理对象访问目标对象**.</p>\n<p>客户端直接使用的都是<code>代理对象</code>，<strong>并不知道真实对象是谁</strong>，此时代理对象可以在客户端和真实对象之间起到**<code>中介作用</code>.**</p>\n<br/>\n<h3><a id=\"2_16\"></a>2、代理模式的作用</h3>\n<p><strong>(1) 中介作用：代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。</strong></p>\n<p><strong>(2) 职责清晰作用: 可以使真实角色的操作更加纯粹,不用去关注一些公共的业务。公共也就交给代理角色,实现了业务的分工。</strong></p>\n<br/>\n<h3><a id=\"3_24\"></a>3、代理模式的组成(角色分析)：</h3>\n<ul>\n<li><strong>抽象角色</strong>: 一般使用接口或抽象类</li>\n<li><strong>真实角色</strong>: 被代理的角色[目标对象]</li>\n<li><strong>代理角色</strong>: 代理真实角色,代理真实角色后,我们一般会做一些附属操作[代理对象]</li>\n</ul>\n<br/>\n<h3><a id=\"4_32\"></a>4、代理模式分类：</h3>\n<ul>\n<li><strong>静态代理</strong></li>\n<li><strong>动态代理(jdk代理、cglib代理)</strong></li>\n</ul>\n<p><br/><br/></p>\n<h2><a id=\"_41\"></a>二、静态代理</h2>\n<h3><a id=\"1_43\"></a>1、静态代理实现过程：</h3>\n<p>静态代理在使用时，需要定义接口或者父类[抽象角色],<strong>被代理对象[真实角色]与代理对象[代理角色]一起实现相同的接口或者是继承相同父类</strong>。</p>\n<br/>\n<h3><a id=\"2_49\"></a>2、静态代理代码：</h3>\n<p>(1) <strong>通过接口聚合的方式，<code>维护一个目标对象</code></strong></p>\n<p>(2) <strong>通过构造器，对目标对象进行初始化</strong></p>\n<pre><code class=\"lang-java\">//代理对象,静态代理\npublic class TeacherDaoProxy implements ITeacherDao{\n	\n	private ITeacherDao target; // 目标对象，通过接口来聚合\n	\n	\n	//构造器\n	public TeacherDaoProxy(ITeacherDao target) {\n		this.target = target;\n	}\n\n\n\n	@Override\n	public void teach() {\n		// TODO Auto-generated method stub\n		System.out.println(&quot;开始代理  完成某些操作。。。。。 &quot;);//方法\n		target.teach();\n		System.out.println(&quot;提交。。。。。&quot;);//方法\n	}\n\n}\n</code></pre>\n<br/>\n<h3><a id=\"3_82\"></a>3、静态代理优缺点：</h3>\n<blockquote>\n<p>优点</p>\n</blockquote>\n<p><strong>在不修改目标对象的功能前提下</strong>, <strong>能通过代理对象对目标功能扩展</strong></p>\n<blockquote>\n<p>缺点</p>\n</blockquote>\n<ul>\n<li>因为代理对象需要与目标对象<strong>实现一样的接口</strong>,所以<strong>会有很多代理类</strong></li>\n<li>一旦<strong>接口增加方法,目标对象与代理对象都要维护</strong></li>\n</ul>\n<br/>\n<h3><a id=\"4_97\"></a>4、静态代理和动态代理的区别：</h3>\n<h5><a id=\"1__99\"></a>(1) 简单说，就是代理对象是否是动态生成的，静态代理不是，动态代理是。</h5>\n<h5><a id=\"2_jvm_101\"></a>(2) 详细说，考虑代理类的字节码的编译运行情况，考虑在程序运行前是否就已经存在代理类的字节码文件，静态代理是已经存在，动态代理不是，是等到程序运行时由jvm通过反射等机制动态生成的。</h5>\n<blockquote>\n<h5><a id=\"__103\"></a>■ 静态代理：（经历了**<code>编译</code>**和运行）</h5>\n<p><code>在程序运行前就已经存在代理类的字节码文件</code>(因为通过了编译阶段)，<code>代理对象和真实对象的关系在运行前就确定了</code>(因为通过了编译阶段)。</p>\n<h5><a id=\"__107\"></a>■ 动态代理：(<code>只经历了运行</code>，咱通过某种手段(例如反射等)得到的字节码【遵循字节码格式和结构】）</h5>\n<p>动态代理类是在程序运行期间由jvm通过反射等机制动态生成的，所以**<code>不存在代理类的字节码文件</code>**(因为没有经历编译阶段)，<code>代理对象和真实对象的关系是在程序运行期间才确定的</code>。</p>\n</blockquote>\n<p><br/><br/></p>\n<h2><a id=\"jdk_119\"></a>三、动态代理之jdk代理</h2>\n<blockquote>\n<p>动态代理包括：jdk代理和cglib代理</p>\n</blockquote>\n<h3><a id=\"1jdk__cglib__123\"></a>1、动态代理jdk 和 cglib 区别：</h3>\n<p><strong>目标对象是否需要实现接口，jdk需要，cglib不需要。jdk代理的代理对象是利用反射机制动态生成，而cglib的代理对象是利用拦截机制动态生成。</strong></p>\n<br/>\n<h3><a id=\"2jdk_129\"></a>2、jdk代理基本介绍</h3>\n<ul>\n<li>代理对象, 不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li>\n<li><strong>代理对象的生成，是利用JDK的API(利用反射机制)，动态的在内存中构建代理对象</strong></li>\n<li><strong>JDK代理也叫做接口代理</strong></li>\n</ul>\n<br/>\n<h3><a id=\"3JDKAPI_137\"></a>3、JDK中生成代理对象的API</h3>\n<ol>\n<li>\n<p>代理类所在包:java.lang.<strong>reflect.Proxy</strong></p>\n</li>\n<li>\n<p>JDK实现代理只需要<strong>使用newProxyInstance方法</strong>,但是该方法需要接收三个参数,</p>\n</li>\n</ol>\n<p>完整的写法是:  static Object newProxyInstance(ClassLoader loader, Class[]  interfaces,InvocationHandler h )</p>\n<pre><code class=\"lang-java\">//1. ClassLoader loader： 指定当前目标对象使用的类加载器, 获取加载器的方法固定\n//2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型\n//3. InvocationHandler h: 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传\n</code></pre>\n<br/>\n<h3><a id=\"4jdk_153\"></a>4、jdk代理的代码</h3>\n<pre><code class=\"lang-java\">//jdk代理，代理工厂，生成代理对象\npublic class ProxyFactory {\n\n	//维护一个目标对象 , Object\n	private Object target;\n\n	//构造器 ， 对target 进行初始化\n	public ProxyFactory(Object target) {\n		\n		this.target = target;\n	} \n	\n	//给目标对象 生成一个代理对象\n	public Object getProxyInstance() {\n		\n		//说明\n		/*\n		 *  public static Object newProxyInstance(ClassLoader loader,\n                                          Class&lt;?&gt;[] interfaces,\n                                          InvocationHandler h)\n                                          \n            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定\n            //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型\n            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入\n		 */\n		return Proxy.newProxyInstance(target.getClass().getClassLoader(), \n				target.getClass().getInterfaces(), \n				new InvocationHandler() {\n					\n					@Override\n					public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n						// TODO Auto-generated method stub\n						System.out.println(&quot;JDK代理开始~~&quot;);\n						//反射机制调用目标对象的方法\n						Object returnVal = method.invoke(target, args);\n						System.out.println(&quot;JDK代理提交&quot;);\n						return returnVal;\n					}\n				}); \n	}\n	\n}\n</code></pre>\n<p><br/><br/></p>\n<h2><a id=\"cglib_208\"></a>四、动态代理之cglib代理</h2>\n<blockquote>\n<p>动态代理包括：jdk代理和cglib代理</p>\n</blockquote>\n<h3><a id=\"1jdk__cglib__212\"></a>1、动态代理jdk 和 cglib 区别：</h3>\n<p><strong>目标对象是否需要实现接口，jdk需要，cglib不需要。jdk代理的代理对象是利用反射机制动态生成，而cglib的代理对象是利用拦截机制动态生成。</strong></p>\n<br/>\n<h3><a id=\"2cglib_218\"></a>2、cglib代理基本介绍</h3>\n<p><strong>Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展。</strong></p>\n<br/>\n<h3><a id=\"3AOP_224\"></a>3、在AOP编程中如何选择代理模式：</h3>\n<p>(1) 目标对象需要实现接口，用JDK代理</p>\n<p>(2) 目标对象不需要实现接口，用Cglib代理</p>\n<br/>\n<h3><a id=\"4cglib__234\"></a>4、cglib 代理的代码：</h3>\n<pre><code class=\"lang-java\">public class ProxyFactory implements MethodInterceptor {\n\n	//维护一个目标对象\n	private Object target;\n	\n	//构造器，传入一个被代理的对象\n	public ProxyFactory(Object target) {\n		this.target = target;\n	}\n\n	//返回一个代理对象:  是 target 对象的代理对象\n	public Object getProxyInstance() {\n		//1. 创建一个工具类\n		Enhancer enhancer = new Enhancer();\n		//2. 设置父类\n		enhancer.setSuperclass(target.getClass());\n		//3. 设置回调函数\n		enhancer.setCallback(this);\n		//4. 创建子类对象，即代理对象\n		return enhancer.create();\n		\n	}\n	\n\n	//重写  intercept 方法，会调用目标对象的方法\n	@Override\n	public Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable {\n		// TODO Auto-generated method stub\n		System.out.println(&quot;Cglib代理模式 ~~ 开始&quot;);\n		Object returnVal = method.invoke(target, args);\n		System.out.println(&quot;Cglib代理模式 ~~ 提交&quot;);\n		return returnVal;\n	}\n\n}\n</code></pre>\n<p><br/><br/></p>\n<h2><a id=\"Proxy_280\"></a>五、扩展—代理模式(Proxy)的变体</h2>\n<h3><a id=\"1__282\"></a>1、几种常见的代理模式介绍— 几种变体</h3>\n<p>(1) <strong>防火墙代理</strong>: 内网通过代理穿透防火墙，实现对公网的访问。</p>\n<p>(2) <strong>缓存代理</strong>: 比如当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok,如果取不到资源，再到公网或者数据库取，然后缓存。</p>\n<p>(3) <strong>远程代理</strong>: 远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和 真正的远程对象沟通信息。</p>\n<p>(4) <strong>同步代理</strong>：主要使用在多线程编程中，完成多线程间同步工作。</p>\n<p><br/><br/></p>\n<p>参考内容来源：《尚硅谷Java设计模式（图解+框架源码剖析）》 https://www.bilibili.com/video/BV1G4411c7N4</p>\n<p><br/><br/></p>\n<p><strong>如果本文对你有帮助的话记得给一乐点个赞哦，感谢！</strong></p>\n', 1548674022449397761);
INSERT INTO `ys_article_body` VALUES (1548676806338985987, '## 个人介绍\n- M E：目前是一名计科大三的学生，对新奇的知识有求知的欲望，愿意尝试各种未知\n- 目标：找到合适的工作\n- 爱好：敲代码、阅读、写作\n\n<br/><br/><br/>\n\n\n## 一乐博客\n- 个人博客系统，基于vue+springboot框架构建。\n- 做个人博客系统的初心是因为自己经常在csdn、博客园写文章，于是萌发了想模仿博客园，做一个简单的博客系统。\n- 学习过程中参考了很多大佬的博客。目前博客系统相对简单，具备博客系统的常规功能，已经部署上线了，后期会逐渐增加更多的功能。\n- 本博客项目已在gitee上开源，项目地址：https://github.com/shan-star/shanBlog，欢迎访问。\n\n<br/><br/><br/>\n\n\n\n## 学习心得分享\n\n### ☺ 带着目的去学习了解一个新事物\n\n**`学习态度应该是放在这个东西的使用目的上`**\n\n- 它存在的目的是为了解决什么问题\n- 它具备什么特性从而解决了什么问题\n- 它是由什么组成的，才具备上某些特性\n- 它具备什么特性，常常在哪些场合下使用\n\n<br/>\n\n### ☺ 保持好奇，多问为什么\n\n**`通过为什么，你会不断的自行到百度或谷歌搜索,从而锻炼了自己的动手解决问题的能力，积累更多的编程经验。`**\n\n- 这个功能是靠什么快捷键、怎么实现的？\n\n- 为什么结果是这样的？\n\n- 为什么会出现这个bug?\n\n- 为什么需要这么设计？\n\n- 为什么使用某某技术？\n\n- 这个技术点，还有其他有应用的地方吗？\n\n\n<br/>\n\n### ☺ 遇到bug，不要依赖别人给你解决答案，要自己动手分析解决\n\n   **不同场景，即使问题相同，解决方式也会因为版本问题而不同，当百度或谷歌搜索不到解决途径时，重新思考一下，更换一下关键词再次搜索，搜索的解决方法都无效的时候，请静下来......**\n\n**`学会自我分析问题，思考发生问题前执行了什么操作，查看一下日志记录的信息，思考一下是不是跟版本有关，代码问题还可以自己动手debug.......`**\n\n\n> 日积月累，不断地思考，不断地动手去尝试，不断地提升解决bug的能力，经验越多，越值钱~\n\n\n\n<br/>\n\n### ☺ 动手实践：\n\n**`对于练习，不应该是机械重复，而是有效练习。`**\n\n#### 建议你动手的场景:\n\n- **动手测试观察**：例如好奇前端的某个样式，你想不起来它的效果是什么，眼见为实，你建一个小Demo，总比你去各大平台苦苦等待别人的回答好\n\n- **动手解决bug**：搜索的方法都没能解决，若是代码问题，你动手调试一下呀，不要害怕调试能力差，这不是就给你机会练习了吗？\n\n  还有记得查看日志记录，再搜索一下问题。\n  还不行，静下来分析出错前干了什么，回退到正常情况，验证一下是不是某一步骤的影响导致错误或警告……', '<h2><a id=\"_0\"></a>个人介绍</h2>\n<ul>\n<li>M E：目前是一名计科大三的学生，对新奇的知识有求知的欲望，愿意尝试各种未知</li>\n<li>目标：找到合适的工作</li>\n<li>爱好：敲代码、阅读、写作</li>\n</ul>\n<p><br/><br/><br/></p>\n<h2><a id=\"_8\"></a>一乐博客</h2>\n<ul>\n<li>个人博客系统，基于vue+springboot框架构建。</li>\n<li>做个人博客系统的初心是因为自己经常在csdn、博客园写文章，于是萌发了想模仿博客园，做一个简单的博客系统。</li>\n<li>学习过程中参考了很多大佬的博客。目前博客系统相对简单，具备博客系统的常规功能，已经部署上线了，后期会逐渐增加更多的功能。</li>\n<li>本博客项目已在gitee上开源，项目地址：https://github.com/shan-star/shanBlog，欢迎访问。</li>\n</ul>\n<p><br/><br/><br/></p>\n<h2><a id=\"_18\"></a>学习心得分享</h2>\n<h3><a id=\"__20\"></a>☺ 带着目的去学习了解一个新事物</h3>\n<p><strong><code>学习态度应该是放在这个东西的使用目的上</code></strong></p>\n<ul>\n<li>它存在的目的是为了解决什么问题</li>\n<li>它具备什么特性从而解决了什么问题</li>\n<li>它是由什么组成的，才具备上某些特性</li>\n<li>它具备什么特性，常常在哪些场合下使用</li>\n</ul>\n<br/>\n<h3><a id=\"__31\"></a>☺ 保持好奇，多问为什么</h3>\n<p><strong><code>通过为什么，你会不断的自行到百度或谷歌搜索,从而锻炼了自己的动手解决问题的能力，积累更多的编程经验。</code></strong></p>\n<ul>\n<li>\n<p>这个功能是靠什么快捷键、怎么实现的？</p>\n</li>\n<li>\n<p>为什么结果是这样的？</p>\n</li>\n<li>\n<p>为什么会出现这个bug?</p>\n</li>\n<li>\n<p>为什么需要这么设计？</p>\n</li>\n<li>\n<p>为什么使用某某技术？</p>\n</li>\n<li>\n<p>这个技术点，还有其他有应用的地方吗？</p>\n</li>\n</ul>\n<br/>\n<h3><a id=\"_bug_50\"></a>☺ 遇到bug，不要依赖别人给你解决答案，要自己动手分析解决</h3>\n<p><strong>不同场景，即使问题相同，解决方式也会因为版本问题而不同，当百度或谷歌搜索不到解决途径时，重新思考一下，更换一下关键词再次搜索，搜索的解决方法都无效的时候，请静下来…</strong></p>\n<p><strong><code>学会自我分析问题，思考发生问题前执行了什么操作，查看一下日志记录的信息，思考一下是不是跟版本有关，代码问题还可以自己动手debug.......</code></strong></p>\n<blockquote>\n<p>日积月累，不断地思考，不断地动手去尝试，不断地提升解决bug的能力，经验越多，越值钱~</p>\n</blockquote>\n<br/>\n<h3><a id=\"__63\"></a>☺ 动手实践：</h3>\n<p><strong><code>对于练习，不应该是机械重复，而是有效练习。</code></strong></p>\n<h4><a id=\"_67\"></a>建议你动手的场景:</h4>\n<ul>\n<li>\n<p><strong>动手测试观察</strong>：例如好奇前端的某个样式，你想不起来它的效果是什么，眼见为实，你建一个小Demo，总比你去各大平台苦苦等待别人的回答好</p>\n</li>\n<li>\n<p><strong>动手解决bug</strong>：搜索的方法都没能解决，若是代码问题，你动手调试一下呀，不要害怕调试能力差，这不是就给你机会练习了吗？</p>\n<p>还有记得查看日志记录，再搜索一下问题。<br />\n还不行，静下来分析出错前干了什么，回退到正常情况，验证一下是不是某一步骤的影响导致错误或警告……</p>\n</li>\n</ul>\n', 1548676806338985985);
INSERT INTO `ys_article_body` VALUES (1548683933224845314, '<br/>\n\n\n\n# ☺ 对于工厂模式，个人学习需要掌握\n\n- 注意答案的重点标黑了。对于工厂模式、建造者模式，掌握，我下面这几点就很棒棒。\n\n> ## 一、工厂模式\n>\n> ## 1、什么是工厂模式：【关键字`factory`】\n>\n> 答：**创建对象时，不直接new，而是交由一个工厂类/工厂接口的`工厂方法`负责创建。**\n>\n> \n>\n> ## 2、工厂模式的意义\n>\n> 答：将**实例化对象的代码提取出来，放到一个类(工厂类)中统一管理和维护；实现了创建者和调用者的分离**，达到和主项目的依赖关系的解耦。从而提高项目的**扩展和维护**性。\n>\n> \n>\n> ## 3、工厂模式包括哪三种\n>\n> 答：简单工厂模式、工厂方法模式、抽象工厂模式\n>\n> \n>\n> ## 4、工厂模式的使用对比[简单工厂模式和工厂方法模式对比]：\n>\n> 答：**简单工厂模式：虽然某种程度上不符合设计原则，但实际使用最多**；**工厂方法模式：不修改已有类的前提下，通过增加新的工厂类实现扩展**；抽象工厂模式：不可以增加产品，可以增加产品族。\n>\n> > ★ 虽然简单工厂模式不符合理论中的开闭原则，但是工厂方法模式定义的大量子类工厂实现类，管理也非常麻烦，`实际开发中使用的最多是简单工厂模式`.\n>\n> \n>\n> # 5、抽象工厂是什么\n>\n> 答：**是工厂的工厂，超级工厂。适合生产一个稳定的产品族**，**采用`抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可`**。\n>\n> \n>\n> ## 6、工厂模式的应用场景：\n>\n> - jdk中calendar的getInstance方法----简单工厂模式\n> - JDBC中的Connection对象的获取\n> - Spring中的IOC容器创建管理bean对象\n> - 反射中Class对象的newInstance方法\n>\n> -----\n>\n> \n>\n> ## 二、建造者模式\n>\n> ## 1、什么是建造者模式：【关键字`builder`】\n>\n> 答：**又叫生成器模式**，是一种对象构建模式。**将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示**。\n>\n> \n>\n> ## 2、四种角色是什么\n>\n> 答：\n>\n> （1) Product(**产品角色**)：一**个具体的产品对象**。\n>\n> （2) Builder(**抽象建造者**): **创建一个产品对象的各个部件的`接口/抽象类`**。 \n>\n> （3) ConcreteBuilder(**具体建造者**): 实现或继承抽象建造者接口，**具体地构建和装配各个部件**。 \n>\n> （4) Director(**指挥者**): 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。负责指挥构建一个工程，决定了工程如何构建，按照什么顺序构建。\n>\n> > #### 举例：建造房子:\n> >\n> > 需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都 需要经历这些过程，下面我们使用建造者模式(Builder Pattern)来完成.\n> >\n> > **1、产品角色：Product-房子，定义了房子的属性**\n> >\n> > **2、`抽象建造者`：Builder-抽象的工人，定义了一些建造房子组件的方法和接口**\n> >\n> > **3、`具体建造者`：ConcreteBuilder-具体的工人，实现了建造房子组件**\n> >\n> > **4、`指挥者：Director-房子的指挥设计者，：负责指挥构建一个工程，决定了工程如何构建，按照什么顺序构建`**\n>\n> #### \n>\n> \n>\n> ## 3、建造者模式在JDK的应用和源码分析 (java.lang.StringBuilder中的建造者模式)\n>\n> 答：源码中建造者模式角色分析： \n>\n> (1) **Appendable接口**，**是抽象建造者, 定义了抽象方法**，定义了多个append方法(抽象方法)\n>\n> (2) **AbstractStringBuilder抽象类，实现了 Appendable接口方法**，**AbstractStringBuilder 是建造者，只是不能实例化** \n>\n> (3)**StringBuilder 继承了AbstractStringBuilder，即充当了指挥者角色，同时充当了具体的建造者**，建造方法的实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了 AbstractStringBuilder\n>\n> \n>\n> ## 4、建造者模式的优缺点：\n>\n> 答：优点：(1) **产品的建造和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部组成的细节**; \n>\n> ​        (2) **用户使用不同的具体建造者即可得到不同的产品对象**;\n>\n> ​        (3) **增加新的具体建造者无需修改原有类库代码，符合“开闭原则”**\n>\n>    缺点：**`建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式`**\n>\n> \n>\n> \n>\n> ## 5、抽象工厂模式VS建造者模式\n>\n> 答：**抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品**，**采用`抽象工厂模式不需要关心构建过程，只关心什么产品 由什么工厂生产即可`**。而**建造者模式则是要求按照`指定的蓝图建造产品`，它的主要目的是通过组装零配件而产生一个新产品。**\n\n\n\n\n\n\n\n<br/><br/>\n\n\n\n\n\n## 一、工厂设计模式\n\n### 1、作用和意义：`实现了创建者和调用者的分离`。\n\n### ★ 工厂模式的意义：`将实例化对象的代码提取出来，放到一个类(工厂类)中统一管理和维护`，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。\n\n<br/>\n\n### 2、三种工厂模式：\n\n#### 简单工厂模式、工厂方法模式、抽象工厂模式\n\n\n<br/>\n\n### 3、 设计模式的依赖抽象原则：\n\n  创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。\n\n  不要让类继承具体类，而是继承抽象类或者是实现interface(接口) \n\n  不要覆盖基类中已经实现的方法\n\n<br/>\n\n### 4、核心本质：\n\n**实例化对象不使用new，用工厂方法代替 factory**\n将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦\n\n\n<br/><br/>\n\n\n### ■ 简单工厂模式（静态工厂模式）\n\n用来生产同一等级结构中的任意产品（对于增加新的产品，需要扩展已有代码）\n\n> ### ★ 对于简单工厂模式的举例：消费者买车\n>\n> 情况一：在没有使用简单工厂模式下，消费者(Consumer类)要买车，需要自己 new来构建一辆自己想要买的车。【`需要消费者自己制作车` (**new 构建 车对象**)，则**消费者是需要车的内部细节**，才能new出车对象】\n>\n> 情况二：使用简单工厂模式下，消费者只需要调用汽车工厂（CarFactory类）的获取车的方法，就可以买车了，不用关系车的创建的各种细节。而汽车工厂（CarFactory类）作用就是来制作车 (**new 构建 车对象**)的，并为外界提供获取车对象的方法。\n\n~~~java\npublic class Consumer {\n    public static void main(String[] args) {\n        // 1、没有使用简单工厂模式的情况：\n        // Car car = new WuLing();\n        // Car car1 = new Tesla();\n\n        // 2、使用工厂创建\n        Car car = CarFactory.getCar(\"wuling\");\n        Car car1 = CarFactory.getCar(\"tesila\");\n\n        car.name();\n        car1.name();\n    }\n}\n\n\npublic interface Car {\n    void name();\n}\n\npublic class WuLing implements Car{\n\n    @Override\n    public void name() {\n        System.out.println(\"五菱宏光\");\n    }\n}\n\npublic class Tesla implements Car{\n\n    @Override\n    public void name() {\n        System.out.println(\"特斯拉\");\n    }\n}\n\n// 静态工厂模式\n// 开闭原则\npublic class CarFactory {\n\n    // 方法一： 不满足开闭原则\n    public static Car getCar(String car){\n        if(car.equals(\"wuling\")){\n            return new WuLing();\n        }else if(car.equals(\"tesila\")){\n            return new Tesla();\n        }else {\n            return null;\n        }\n    }\n\n    // 方法二：\n    public static Car geyWuling(){\n        return new WuLing();\n    }\n    public static Car geyTesla(){\n        return new Tesla();\n    }\n\n\n}\n~~~\n\n\n![](https://files.mdnice.com/user/18969/c7803cb0-9c05-467f-b615-7e0e6367c968.png)\n\n\n#### □ 弊端：增加一个新的产品，做不到不修改代码。\n\n> 例如：扩展一个大众的汽车，则需要修改工厂类(CarFactory)的Car(String car)方法的代码，不符合开闭原则【**对扩展开发，对修改关闭**】。\n\n- 解决：工厂方法模式\n\n\n<br/>\n\n\n### ■  工厂方法模式：\n\n用来生产同一等级结构中的固定产品（支持增加任意产品）\n\n~~~java\npublic class Consumer {\n    public static void main(String[] args) {\n        Car car = new WulingFactory().getCar();\n        Car car1 = new TeslaFactory().getCar();\n\n        car.name();\n        car1.name();\n\n        Car car2 = new MoBaiFactory().getCar();\n        car2.name();\n    }\n}\n\n\n\npublic interface Car {\n    void name();\n}\n\npublic class WuLing implements Car {\n\n    @Override\n    public void name() {\n        System.out.println(\"五菱宏光\");\n    }\n}\n\npublic class Tesla implements Car {\n\n    @Override\n    public void name() {\n        System.out.println(\"特斯拉\");\n    }\n}\n\n// 工厂方法模式\npublic interface CarFactory {\n    Car getCar();\n}\n\npublic class WulingFactory implements CarFactory{\n    @Override\n    public Car getCar() {\n        return new WuLing();\n    }\n}\n\npublic class TeslaFactory implements CarFactory{\n    @Override\n    public Car getCar() {\n        return new Tesla();\n    }\n}\n\n~~~\n\n\n![](https://files.mdnice.com/user/18969/e89d9370-0c5e-48a6-826e-58f0ffafe896.png)\n\n\n<br/>\n\n> #### ■ 工厂方法模式：通过将简单工厂模式原先的工厂类抽象成接口，然后根据车的种类，决定了抽象工厂接口的子类工厂实现类，并在子类工厂实现类内创建对应车种类的对象。\n>\n> - 举例：现在多了一个车的品牌，叫宝马，相应的车工厂就有宝马工厂(实现工厂接口)，在宝马车工厂实现了制作宝马车的方法。\n\n<br/>\n\n### 3、理论和实际应用对比【对比简单工厂模式和工厂方法模式】\n\n1、结构复杂度：simple>method\n\n2、代码复杂度：simple>method\n\n3、编程复杂度：simple>method\n\n4、管理上的复杂度：simple>method\n\n> ### ★ 虽然简单工厂模式不符合理论中的开闭原则，但是工厂方法模式定义的大量子类工厂实现类，管理也非常麻烦，`实际开发中使用的最多是简单工厂模式`\n\n\n\n\n<br/><br/>\n\n\n\n\n### 4、抽象工厂模式：\"工厂的工厂，超级工厂。适合生产一个稳定的产品族\"\n\n围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂\n\n#### (1) 定义：\n\n抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，无需指定他们的具体的类（针对整个产品族，产品等级数量相对固定的产品族）\n\n#### (2) 适用场景：\n\n- 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节\n- 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码\n- 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体实现\n\n\n![c7803cb09c05467fb6157e0e6367c968.png](https://niu.yilele.site/3c75c2f9-3783-4406-9eab-3cbad42aaa0b.png)\n\n> ### ■ 抽象工厂模式-其实就是工厂方法模式的抽象，体现在将原先的工厂定义为超级工厂接口，且包含的属性成员也是接口。\n>\n> 1、定义一个超级工厂接口IProductFactory：包含两个产品接口(接口属性成员)-手机产品接口IphoneProduct、路由器产品接口IRouterProduct 【**产品族**】\n>\n> 2、然后超级工厂接口有具体的实现子类-小米工厂XiaomiFactory、华为工厂HuaweiFactory\n>\n> 3、对于超级工厂接口定义的接口属性成员有对应的实现子类\n>\n> - 然后手机产品接口IphoneProduct有具体的实现子类-小米手机实现子类XiaomiPhone、华为手机实现子类HuaweiPhone\n>\n> - 同样路由器产品接口IRouterProduct 也有具体的实现子类-小米路由实现子类XiaomiRouter、华为路由实现子类HuaweiRouter\n>\n>  \n\n~~~java\n// 手机产品接口\npublic interface IphoneProduct {\n\n    void start();\n    void shutdown();\n    void callup();\n    void sendSMS();\n}\n\n// 小米手机\npublic class XiaomiPhone implements IphoneProduct{\n    @Override\n    public void start() {\n        System.out.println(\"开启小米手机\");\n    }\n\n    @Override\n    public void shutdown() {\n        System.out.println(\"关闭小米手机\");\n    }\n\n    @Override\n    public void callup() {\n        System.out.println(\"小米手机打电话\");\n    }\n\n    @Override\n    public void sendSMS() {\n        System.out.println(\"小米手机发短信\");\n    }\n}\n\n\n// 华为手机\npublic class HuaweiPhone implements IphoneProduct{\n    @Override\n    public void start() {\n        System.out.println(\"开启华为手机\");\n    }\n\n    @Override\n    public void shutdown() {\n        System.out.println(\"关闭华为手机\");\n    }\n\n    @Override\n    public void callup() {\n        System.out.println(\"华为手机打电话\");\n    }\n\n    @Override\n    public void sendSMS() {\n        System.out.println(\"华为手机发短信\");\n    }\n}\n\n// 路由器产品接口\npublic interface IRouterProduct {\n\n    void start();\n    void shutdown();\n    void openWifi();\n    void setting();\n}\n\n// 小米路由器\npublic class XiaomiRouter implements IRouterProduct{\n    @Override\n    public void start() {\n        System.out.println(\"启动小米路由器\");\n    }\n\n    @Override\n    public void shutdown() {\n        System.out.println(\"关闭小米路由器\");\n    }\n\n    @Override\n    public void openWifi() {\n        System.out.println(\"打开小米Wi-Fi\");\n    }\n\n    @Override\n    public void setting() {\n        System.out.println(\"小米设置\");\n    }\n}\n\n// 华为路由器\npublic class HuaweiRouter implements IRouterProduct{\n    @Override\n    public void start() {\n        System.out.println(\"启动华为路由器\");\n    }\n\n    @Override\n    public void shutdown() {\n        System.out.println(\"关闭华为路由器\");\n    }\n\n    @Override\n    public void openWifi() {\n        System.out.println(\"打开华为Wi-Fi\");\n    }\n\n    @Override\n    public void setting() {\n        System.out.println(\"华为设置\");\n    }\n}\n\n// 抽象产品工厂\npublic interface IProductFactory {\n\n    // 生产手机\n    IphoneProduct iphoneProduct();\n\n    // 生产路由器\n    IRouterProduct irouterProduct();\n\n}\n\npublic class XiaomiFactory implements IProductFactory{\n    @Override\n    public IphoneProduct iphoneProduct() {\n        return new XiaomiPhone();\n    }\n\n    @Override\n    public IRouterProduct irouterProduct() {\n        return new XiaomiRouter();\n    }\n}\n\npublic class HuaweiFactory implements IProductFactory{\n    @Override\n    public IphoneProduct iphoneProduct() {\n        return new HuaweiPhone();\n    }\n\n    @Override\n    public IRouterProduct irouterProduct() {\n        return new HuaweiRouter();\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        System.out.println(\"小米系列产品--------------------\");\n        // 小米工厂\n        XiaomiFactory xiaomiFactory = new XiaomiFactory();\n\n        IphoneProduct iphoneProduct = xiaomiFactory.iphoneProduct();\n        iphoneProduct.callup();\n        iphoneProduct.sendSMS();\n\n        IRouterProduct iRouterProduct = xiaomiFactory.irouterProduct();\n        iRouterProduct.openWifi();\n\n        System.out.println(\"华为系列产品--------------------\");\n        // 小米工厂\n        HuaweiFactory huaweiFactory = new HuaweiFactory();\n\n        iphoneProduct = huaweiFactory.iphoneProduct();\n        iphoneProduct.callup();\n        iphoneProduct.sendSMS();\n\n        iRouterProduct = huaweiFactory.irouterProduct();\n        iRouterProduct.openWifi();\n    }\n}\n~~~\n\n<br/>\n\n#### (3) 抽象工厂模式优缺点：\n\n> #### 优点\n\n- 具体产品在应用层的代码隔离，无需关心创建的细节\n\n- 将一个系列的产品统一到一起创建\n\n> #### 缺点：\n\n- **`规定了所有可能被创建的产品集合，产品族中扩展新的产品困难`；**\n\n- 增加了系统的抽象性和理解难度\n\n\n\n<br/>\n\n### 5、工厂模式小结：\n\n- 简单工厂模式：虽然某种程度上不符合设计原则，但实际使用最多\n\n- 工厂方法模式：不修改已有类的前提下，通过增加新的工厂类实现扩展\n\n- 抽象工厂模式：不可以增加产品，可以增加产品族\n\n\n<br/>\n\n\n### 6、工厂模式的应用场景：\n\n- jdk中calendar的getInstance方法----简单工厂模式\n\n- JDBC中的Connection对象的获取\n\n- Spring中的IOC容器创建管理bean对象\n\n- 反射中Class对象的newInstance方法\n\n  \n\n\n<br/><br/><br/>\n\n\n\n\n\n\n\n\n# 二、建造者模式\n\n它提供了一种创建对象的最佳方式\n\n<br/>\n\n### 1、定义：\n\n将一个复杂**对象的构建与它的表示分离**，使得同样的构建过程可以创建不同的表示。\n\n建造者模式（Builder Pattern） **又叫生成器模式**，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。\n\n<br/>\n\n### 2、主要作用：\n\n在用户不知道 对象的建造过程和细节的情况下就可以直接创建复杂的对象。\n\n用户只需要给出指定复杂对象的类型和内容，建造者牧师负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）\n\n\n\n<br/>\n\n### 3、四种角色[★ 结合第四点的建造房子理解]\n\n#### 1) Product(产品角色)：一个具体的产品对象。\n\n#### 2) Builder(抽象建造者): 创建一个Product对象的各个部件指定的 `接口/抽象类`。 \n\n#### 3) ConcreteBuilder(具体建造者): 实现接口，构建和装配各个部件。 \n\n#### 4) Director(指挥者): 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。\n\n#### 它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。\n\n\n\n<br/>\n\n### 4、举例：建造房子\n\n> 需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都 需要经历这些过程，下面我们使用建造者模式(Builder Pattern)来完成.\n>\n> **1、产品角色：Product-房子，定义了房子的属性**\n>\n> **2、`抽象建造者`：Builder-抽象的工人，定义了一些建造房子组件的方法和接口**\n>\n> **3、`具体建造者`：ConcreteBuilder-具体的工人，实现了建造房子组件**\n>\n> **4、`指挥者：Director-房子的指挥设计者，：核心负责指挥构建一个工程，决定了工程如何构建，按照什么顺序构建`**\n\n~~~java\n// 产品：房子[定义了房子的属性]\npublic class Product {\n\n    private String buildA;\n    private String buildB;\n    private String buildC;\n    private String buildD;\n\n    public String getBuildA() {\n        return buildA;\n    }\n\n    public void setBuildA(String buildA) {\n        this.buildA = buildA;\n    }\n\n    public String getBuildB() {\n        return buildB;\n    }\n\n    public void setBuildB(String buildB) {\n        this.buildB = buildB;\n    }\n\n    public String getBuildC() {\n        return buildC;\n    }\n\n    public void setBuildC(String buildC) {\n        this.buildC = buildC;\n    }\n\n    public String getBuildD() {\n        return buildD;\n    }\n\n    public void setBuildD(String buildD) {\n        this.buildD = buildD;\n    }\n\n    @Override\n    public String toString() {\n        return \"Product{\" +\n                \"buildA=\'\" + buildA + \'\\\'\' +\n                \", buildB=\'\" + buildB + \'\\\'\' +\n                \", buildC=\'\" + buildC + \'\\\'\' +\n                \", buildD=\'\" + buildD + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n// 抽象的建造者[抽象的工人]：只是定义一些方法和接口\npublic abstract class Builder {\n    abstract void buildA(); // 地基\n    abstract void buildB(); // 钢筋工程\n    abstract void buildC(); // 铺电线\n    abstract void buildD(); // 粉刷\n\n    // 完工：得到产品\n    abstract Product getProduct();\n}\n\n\n\n// 具体的建造者[工人]:\npublic class Worker extends Builder {\n\n    private Product product;\n\n    public Worker() {\n         product = new Product();// 工人负责创建产品\n    }\n\n    @Override\n    void buildA() {\n        product.setBuildA(\"地基\");\n        System.out.println(\"地基\");\n    }\n\n    @Override\n    void buildB() {\n        product.setBuildB(\"钢筋工程\");\n        System.out.println(\"钢筋工程\");\n    }\n\n    @Override\n    void buildC() {\n        product.setBuildC(\"铺电线\");\n        System.out.println(\"铺电线\");\n    }\n\n    @Override\n    void buildD() {\n        product.setBuildD(\"粉刷\");\n        System.out.println(\"粉刷\");\n    }\n\n    @Override\n    Product getProduct() {\n        return product;\n    }\n}\n\n\n// 指挥者：核心负责指挥构建一个工程，工程如何构建，按照什么顺序构建，由他决定\npublic class Director {\n\n    // 指挥工人按照顺序建房子\n    public Product build(Builder builder){\n        builder.buildA();\n        builder.buildB();\n        builder.buildC();\n        builder.buildD();\n        return builder.getProduct();\n    }\n}\n\n\n\npublic class Test {\n    public static void main(String[] args) {\n        // 指挥\n        Director director = new Director();\n        // 指挥 具体的工人 完成产品\n        Product build = director.build(new Worker());\n        System.out.println(build.toString());\n    }\n}\n~~~\n\n<br/>\n\n### 5、建造者模式在JDK的应用和源码分析 (java.lang.StringBuilder中的建造者模式)\n\n#### ■ 源码中建造者模式角色分析 \n\n **Appendable接口**，**是抽象建造者, 定义了抽象方法**，定义了多个append方法(抽象方法)\n\n **AbstractStringBuilder抽象类，实现了 Appendable接口方法**，**AbstractStringBuilder 是建造者，只是不能实例化** \n\n **StringBuilder 继承了AbstractStringBuilder，即充当了指挥者角色，同时充当了具体的建造者**，建造方法的实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了 AbstractStringBuilder\n\n\n<br/>\n\n\n### 6、建造者模式的优缺点\n\n> ### 优点：\n\n- **产品的建造和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部组成的细节**\n- **用户使用不同的具体建造者即可得到不同的产品对象**\n- 将复杂产品的创建步骤分解在不同的方法中，是得创建过程更加清晰\n- 具体的建造者之间是相互独立的，这有利于系统的扩展。**增加新的具体建造者无需修改原有类库代码，符合“开闭原则”**\n\n> ### 缺点：\n\n- **`建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式`**，因此其使用范围受到一定的限制\n- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变的很庞大\n\n\n<br/>\n\n\n### 7、抽象工厂模式VS建造者模式\n\n**抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品**：具有不同分类维度的产品组合，**采用`抽象工厂模式不需要关心构建过程，只关心什么产品 由什么工厂生产即可`**。\n\n而**建造者模式则是要求按照`指定的蓝图建造产品`，它的主要目的是通过组装零配件而产生一个新产品。**\n\n\n<br/><br/>\n\n参考内容来源：《尚硅谷Java设计模式（图解+框架源码剖析）》 https://www.bilibili.com/video/BV1G4411c7N4\n《【狂神说Java】通俗易懂的23种设计模式教学（停更）》https://www.bilibili.com/video/BV1mc411h719?p=5\n\n\n<br/><br/>\n\n**如果本文对你有帮助的话记得给一乐点个赞哦，感谢！**', '<br/>\n<h1><a id=\"__4\"></a>☺ 对于工厂模式，个人学习需要掌握</h1>\n<ul>\n<li>注意答案的重点标黑了。对于工厂模式、建造者模式，掌握，我下面这几点就很棒棒。</li>\n</ul>\n<blockquote>\n<h2><a id=\"_8\"></a>一、工厂模式</h2>\n<h2><a id=\"1factory_10\"></a>1、什么是工厂模式：【关键字<code>factory</code>】</h2>\n<p>答：<strong>创建对象时，不直接new，而是交由一个工厂类/工厂接口的<code>工厂方法</code>负责创建。</strong></p>\n<h2><a id=\"2_16\"></a>2、工厂模式的意义</h2>\n<p>答：将<strong>实例化对象的代码提取出来，放到一个类(工厂类)中统一管理和维护；实现了创建者和调用者的分离</strong>，达到和主项目的依赖关系的解耦。从而提高项目的<strong>扩展和维护</strong>性。</p>\n<h2><a id=\"3_22\"></a>3、工厂模式包括哪三种</h2>\n<p>答：简单工厂模式、工厂方法模式、抽象工厂模式</p>\n<h2><a id=\"4_28\"></a>4、工厂模式的使用对比[简单工厂模式和工厂方法模式对比]：</h2>\n<p>答：<strong>简单工厂模式：虽然某种程度上不符合设计原则，但实际使用最多</strong>；<strong>工厂方法模式：不修改已有类的前提下，通过增加新的工厂类实现扩展</strong>；抽象工厂模式：不可以增加产品，可以增加产品族。</p>\n<blockquote>\n<p>★ 虽然简单工厂模式不符合理论中的开闭原则，但是工厂方法模式定义的大量子类工厂实现类，管理也非常麻烦，<code>实际开发中使用的最多是简单工厂模式</code>.</p>\n</blockquote>\n<h1><a id=\"5_36\"></a>5、抽象工厂是什么</h1>\n<p>答：<strong>是工厂的工厂，超级工厂。适合生产一个稳定的产品族</strong>，<strong>采用<code>抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可</code></strong>。</p>\n<h2><a id=\"6_42\"></a>6、工厂模式的应用场景：</h2>\n<ul>\n<li>jdk中calendar的getInstance方法----简单工厂模式</li>\n<li>JDBC中的Connection对象的获取</li>\n<li>Spring中的IOC容器创建管理bean对象</li>\n<li>反射中Class对象的newInstance方法</li>\n</ul>\n<hr />\n<h2><a id=\"_53\"></a>二、建造者模式</h2>\n<h2><a id=\"1builder_55\"></a>1、什么是建造者模式：【关键字<code>builder</code>】</h2>\n<p>答：<strong>又叫生成器模式</strong>，是一种对象构建模式。<strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</strong>。</p>\n<h2><a id=\"2_61\"></a>2、四种角色是什么</h2>\n<p>答：</p>\n<p>（1) Product(<strong>产品角色</strong>)：一<strong>个具体的产品对象</strong>。</p>\n<p>（2) Builder(<strong>抽象建造者</strong>): <strong>创建一个产品对象的各个部件的<code>接口/抽象类</code></strong>。</p>\n<p>（3) ConcreteBuilder(<strong>具体建造者</strong>): 实现或继承抽象建造者接口，<strong>具体地构建和装配各个部件</strong>。</p>\n<p>（4) Director(<strong>指挥者</strong>): 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。负责指挥构建一个工程，决定了工程如何构建，按照什么顺序构建。</p>\n<blockquote>\n<h4><a id=\"_73\"></a>举例：建造房子:</h4>\n<p>需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都 需要经历这些过程，下面我们使用建造者模式(Builder Pattern)来完成.</p>\n<p><strong>1、产品角色：Product-房子，定义了房子的属性</strong></p>\n<p><strong>2、<code>抽象建造者</code>：Builder-抽象的工人，定义了一些建造房子组件的方法和接口</strong></p>\n<p><strong>3、<code>具体建造者</code>：ConcreteBuilder-具体的工人，实现了建造房子组件</strong></p>\n<p><strong>4、<code>指挥者：Director-房子的指挥设计者，：负责指挥构建一个工程，决定了工程如何构建，按照什么顺序构建</code></strong></p>\n</blockquote>\n<h4><a id=\"_85\"></a></h4>\n<h2><a id=\"3JDK_javalangStringBuilder_89\"></a>3、建造者模式在JDK的应用和源码分析 (java.lang.StringBuilder中的建造者模式)</h2>\n<p>答：源码中建造者模式角色分析：</p>\n<p>(1) <strong>Appendable接口</strong>，<strong>是抽象建造者, 定义了抽象方法</strong>，定义了多个append方法(抽象方法)</p>\n<p>(2) <strong>AbstractStringBuilder抽象类，实现了 Appendable接口方法</strong>，<strong>AbstractStringBuilder 是建造者，只是不能实例化</strong></p>\n<p>(3)<strong>StringBuilder 继承了AbstractStringBuilder，即充当了指挥者角色，同时充当了具体的建造者</strong>，建造方法的实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了 AbstractStringBuilder</p>\n<h2><a id=\"4_101\"></a>4、建造者模式的优缺点：</h2>\n<p>答：优点：(1) <strong>产品的建造和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部组成的细节</strong>;</p>\n<p>​        (2) <strong>用户使用不同的具体建造者即可得到不同的产品对象</strong>;</p>\n<p>​        (3) <strong>增加新的具体建造者无需修改原有类库代码，符合“开闭原则”</strong></p>\n<p>缺点：<strong><code>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式</code></strong></p>\n<h2><a id=\"5VS_115\"></a>5、抽象工厂模式VS建造者模式</h2>\n<p>答：<strong>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品</strong>，<strong>采用<code>抽象工厂模式不需要关心构建过程，只关心什么产品 由什么工厂生产即可</code></strong>。而<strong>建造者模式则是要求按照<code>指定的蓝图建造产品</code>，它的主要目的是通过组装零配件而产生一个新产品。</strong></p>\n</blockquote>\n<p><br/><br/></p>\n<h2><a id=\"_131\"></a>一、工厂设计模式</h2>\n<h3><a id=\"1_133\"></a>1、作用和意义：<code>实现了创建者和调用者的分离</code>。</h3>\n<h3><a id=\"__135\"></a>★ 工厂模式的意义：<code>将实例化对象的代码提取出来，放到一个类(工厂类)中统一管理和维护</code>，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。</h3>\n<br/>\n<h3><a id=\"2_139\"></a>2、三种工厂模式：</h3>\n<h4><a id=\"_141\"></a>简单工厂模式、工厂方法模式、抽象工厂模式</h4>\n<br/>\n<h3><a id=\"3__146\"></a>3、 设计模式的依赖抽象原则：</h3>\n<p> 创建对象实例时，不要直接 new 类, 而是把这个new 类的动作放在一个工厂的方法中，并返回。</p>\n<p> 不要让类继承具体类，而是继承抽象类或者是实现interface(接口)</p>\n<p> 不要覆盖基类中已经实现的方法</p>\n<br/>\n<h3><a id=\"4_156\"></a>4、核心本质：</h3>\n<p><strong>实例化对象不使用new，用工厂方法代替 factory</strong><br />\n将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦</p>\n<p><br/><br/></p>\n<h3><a id=\"__165\"></a>■ 简单工厂模式（静态工厂模式）</h3>\n<p>用来生产同一等级结构中的任意产品（对于增加新的产品，需要扩展已有代码）</p>\n<blockquote>\n<h3><a id=\"__169\"></a>★ 对于简单工厂模式的举例：消费者买车</h3>\n<p>情况一：在没有使用简单工厂模式下，消费者(Consumer类)要买车，需要自己 new来构建一辆自己想要买的车。【<code>需要消费者自己制作车</code> (<strong>new 构建 车对象</strong>)，则<strong>消费者是需要车的内部细节</strong>，才能new出车对象】</p>\n<p>情况二：使用简单工厂模式下，消费者只需要调用汽车工厂（CarFactory类）的获取车的方法，就可以买车了，不用关系车的创建的各种细节。而汽车工厂（CarFactory类）作用就是来制作车 (<strong>new 构建 车对象</strong>)的，并为外界提供获取车对象的方法。</p>\n</blockquote>\n<pre><code class=\"lang-java\">public class Consumer {\n    public static void main(String[] args) {\n        // 1、没有使用简单工厂模式的情况：\n        // Car car = new WuLing();\n        // Car car1 = new Tesla();\n\n        // 2、使用工厂创建\n        Car car = CarFactory.getCar(&quot;wuling&quot;);\n        Car car1 = CarFactory.getCar(&quot;tesila&quot;);\n\n        car.name();\n        car1.name();\n    }\n}\n\n\npublic interface Car {\n    void name();\n}\n\npublic class WuLing implements Car{\n\n    @Override\n    public void name() {\n        System.out.println(&quot;五菱宏光&quot;);\n    }\n}\n\npublic class Tesla implements Car{\n\n    @Override\n    public void name() {\n        System.out.println(&quot;特斯拉&quot;);\n    }\n}\n\n// 静态工厂模式\n// 开闭原则\npublic class CarFactory {\n\n    // 方法一： 不满足开闭原则\n    public static Car getCar(String car){\n        if(car.equals(&quot;wuling&quot;)){\n            return new WuLing();\n        }else if(car.equals(&quot;tesila&quot;)){\n            return new Tesla();\n        }else {\n            return null;\n        }\n    }\n\n    // 方法二：\n    public static Car geyWuling(){\n        return new WuLing();\n    }\n    public static Car geyTesla(){\n        return new Tesla();\n    }\n\n\n}\n</code></pre>\n<p><img src=\"https://files.mdnice.com/user/18969/c7803cb0-9c05-467f-b615-7e0e6367c968.png\" alt=\"\" /></p>\n<h4><a id=\"__243\"></a>□ 弊端：增加一个新的产品，做不到不修改代码。</h4>\n<blockquote>\n<p>例如：扩展一个大众的汽车，则需要修改工厂类(CarFactory)的Car(String car)方法的代码，不符合开闭原则【<strong>对扩展开发，对修改关闭</strong>】。</p>\n</blockquote>\n<ul>\n<li>解决：工厂方法模式</li>\n</ul>\n<br/>\n<h3><a id=\"___253\"></a>■  工厂方法模式：</h3>\n<p>用来生产同一等级结构中的固定产品（支持增加任意产品）</p>\n<pre><code class=\"lang-java\">public class Consumer {\n    public static void main(String[] args) {\n        Car car = new WulingFactory().getCar();\n        Car car1 = new TeslaFactory().getCar();\n\n        car.name();\n        car1.name();\n\n        Car car2 = new MoBaiFactory().getCar();\n        car2.name();\n    }\n}\n\n\n\npublic interface Car {\n    void name();\n}\n\npublic class WuLing implements Car {\n\n    @Override\n    public void name() {\n        System.out.println(&quot;五菱宏光&quot;);\n    }\n}\n\npublic class Tesla implements Car {\n\n    @Override\n    public void name() {\n        System.out.println(&quot;特斯拉&quot;);\n    }\n}\n\n// 工厂方法模式\npublic interface CarFactory {\n    Car getCar();\n}\n\npublic class WulingFactory implements CarFactory{\n    @Override\n    public Car getCar() {\n        return new WuLing();\n    }\n}\n\npublic class TeslaFactory implements CarFactory{\n    @Override\n    public Car getCar() {\n        return new Tesla();\n    }\n}\n\n</code></pre>\n<p><img src=\"https://files.mdnice.com/user/18969/e89d9370-0c5e-48a6-826e-58f0ffafe896.png\" alt=\"\" /></p>\n<br/>\n<blockquote>\n<h4><a id=\"__320\"></a>■ 工厂方法模式：通过将简单工厂模式原先的工厂类抽象成接口，然后根据车的种类，决定了抽象工厂接口的子类工厂实现类，并在子类工厂实现类内创建对应车种类的对象。</h4>\n<ul>\n<li>举例：现在多了一个车的品牌，叫宝马，相应的车工厂就有宝马工厂(实现工厂接口)，在宝马车工厂实现了制作宝马车的方法。</li>\n</ul>\n</blockquote>\n<br/>\n<h3><a id=\"3_326\"></a>3、理论和实际应用对比【对比简单工厂模式和工厂方法模式】</h3>\n<p>1、结构复杂度：simple&gt;method</p>\n<p>2、代码复杂度：simple&gt;method</p>\n<p>3、编程复杂度：simple&gt;method</p>\n<p>4、管理上的复杂度：simple&gt;method</p>\n<blockquote>\n<h3><a id=\"__336\"></a>★ 虽然简单工厂模式不符合理论中的开闭原则，但是工厂方法模式定义的大量子类工厂实现类，管理也非常麻烦，<code>实际开发中使用的最多是简单工厂模式</code></h3>\n</blockquote>\n<p><br/><br/></p>\n<h3><a id=\"4_346\"></a>4、抽象工厂模式：“工厂的工厂，超级工厂。适合生产一个稳定的产品族”</h3>\n<p>围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂</p>\n<h4><a id=\"1__350\"></a>(1) 定义：</h4>\n<p>抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，无需指定他们的具体的类（针对整个产品族，产品等级数量相对固定的产品族）</p>\n<h4><a id=\"2__354\"></a>(2) 适用场景：</h4>\n<ul>\n<li>客户端（应用层）不依赖于产品类实例如何被创建、实现等细节</li>\n<li>强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码</li>\n<li>提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体实现</li>\n</ul>\n<p><img src=\"https://niu.yilele.site/3c75c2f9-3783-4406-9eab-3cbad42aaa0b.png\" alt=\"c7803cb09c05467fb6157e0e6367c968.png\" /></p>\n<blockquote>\n<h3><a id=\"__363\"></a>■ 抽象工厂模式-其实就是工厂方法模式的抽象，体现在将原先的工厂定义为超级工厂接口，且包含的属性成员也是接口。</h3>\n<p>1、定义一个超级工厂接口IProductFactory：包含两个产品接口(接口属性成员)-手机产品接口IphoneProduct、路由器产品接口IRouterProduct 【<strong>产品族</strong>】</p>\n<p>2、然后超级工厂接口有具体的实现子类-小米工厂XiaomiFactory、华为工厂HuaweiFactory</p>\n<p>3、对于超级工厂接口定义的接口属性成员有对应的实现子类</p>\n<ul>\n<li>\n<p>然后手机产品接口IphoneProduct有具体的实现子类-小米手机实现子类XiaomiPhone、华为手机实现子类HuaweiPhone</p>\n</li>\n<li>\n<p>同样路由器产品接口IRouterProduct 也有具体的实现子类-小米路由实现子类XiaomiRouter、华为路由实现子类HuaweiRouter</p>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"lang-java\">// 手机产品接口\npublic interface IphoneProduct {\n\n    void start();\n    void shutdown();\n    void callup();\n    void sendSMS();\n}\n\n// 小米手机\npublic class XiaomiPhone implements IphoneProduct{\n    @Override\n    public void start() {\n        System.out.println(&quot;开启小米手机&quot;);\n    }\n\n    @Override\n    public void shutdown() {\n        System.out.println(&quot;关闭小米手机&quot;);\n    }\n\n    @Override\n    public void callup() {\n        System.out.println(&quot;小米手机打电话&quot;);\n    }\n\n    @Override\n    public void sendSMS() {\n        System.out.println(&quot;小米手机发短信&quot;);\n    }\n}\n\n\n// 华为手机\npublic class HuaweiPhone implements IphoneProduct{\n    @Override\n    public void start() {\n        System.out.println(&quot;开启华为手机&quot;);\n    }\n\n    @Override\n    public void shutdown() {\n        System.out.println(&quot;关闭华为手机&quot;);\n    }\n\n    @Override\n    public void callup() {\n        System.out.println(&quot;华为手机打电话&quot;);\n    }\n\n    @Override\n    public void sendSMS() {\n        System.out.println(&quot;华为手机发短信&quot;);\n    }\n}\n\n// 路由器产品接口\npublic interface IRouterProduct {\n\n    void start();\n    void shutdown();\n    void openWifi();\n    void setting();\n}\n\n// 小米路由器\npublic class XiaomiRouter implements IRouterProduct{\n    @Override\n    public void start() {\n        System.out.println(&quot;启动小米路由器&quot;);\n    }\n\n    @Override\n    public void shutdown() {\n        System.out.println(&quot;关闭小米路由器&quot;);\n    }\n\n    @Override\n    public void openWifi() {\n        System.out.println(&quot;打开小米Wi-Fi&quot;);\n    }\n\n    @Override\n    public void setting() {\n        System.out.println(&quot;小米设置&quot;);\n    }\n}\n\n// 华为路由器\npublic class HuaweiRouter implements IRouterProduct{\n    @Override\n    public void start() {\n        System.out.println(&quot;启动华为路由器&quot;);\n    }\n\n    @Override\n    public void shutdown() {\n        System.out.println(&quot;关闭华为路由器&quot;);\n    }\n\n    @Override\n    public void openWifi() {\n        System.out.println(&quot;打开华为Wi-Fi&quot;);\n    }\n\n    @Override\n    public void setting() {\n        System.out.println(&quot;华为设置&quot;);\n    }\n}\n\n// 抽象产品工厂\npublic interface IProductFactory {\n\n    // 生产手机\n    IphoneProduct iphoneProduct();\n\n    // 生产路由器\n    IRouterProduct irouterProduct();\n\n}\n\npublic class XiaomiFactory implements IProductFactory{\n    @Override\n    public IphoneProduct iphoneProduct() {\n        return new XiaomiPhone();\n    }\n\n    @Override\n    public IRouterProduct irouterProduct() {\n        return new XiaomiRouter();\n    }\n}\n\npublic class HuaweiFactory implements IProductFactory{\n    @Override\n    public IphoneProduct iphoneProduct() {\n        return new HuaweiPhone();\n    }\n\n    @Override\n    public IRouterProduct irouterProduct() {\n        return new HuaweiRouter();\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        System.out.println(&quot;小米系列产品--------------------&quot;);\n        // 小米工厂\n        XiaomiFactory xiaomiFactory = new XiaomiFactory();\n\n        IphoneProduct iphoneProduct = xiaomiFactory.iphoneProduct();\n        iphoneProduct.callup();\n        iphoneProduct.sendSMS();\n\n        IRouterProduct iRouterProduct = xiaomiFactory.irouterProduct();\n        iRouterProduct.openWifi();\n\n        System.out.println(&quot;华为系列产品--------------------&quot;);\n        // 小米工厂\n        HuaweiFactory huaweiFactory = new HuaweiFactory();\n\n        iphoneProduct = huaweiFactory.iphoneProduct();\n        iphoneProduct.callup();\n        iphoneProduct.sendSMS();\n\n        iRouterProduct = huaweiFactory.irouterProduct();\n        iRouterProduct.openWifi();\n    }\n}\n</code></pre>\n<br/>\n<h4><a id=\"3__553\"></a>(3) 抽象工厂模式优缺点：</h4>\n<blockquote>\n<h4><a id=\"_555\"></a>优点</h4>\n</blockquote>\n<ul>\n<li>\n<p>具体产品在应用层的代码隔离，无需关心创建的细节</p>\n</li>\n<li>\n<p>将一个系列的产品统一到一起创建</p>\n</li>\n</ul>\n<blockquote>\n<h4><a id=\"_561\"></a>缺点：</h4>\n</blockquote>\n<ul>\n<li>\n<p><strong><code>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难</code>；</strong></p>\n</li>\n<li>\n<p>增加了系统的抽象性和理解难度</p>\n</li>\n</ul>\n<br/>\n<h3><a id=\"5_571\"></a>5、工厂模式小结：</h3>\n<ul>\n<li>\n<p>简单工厂模式：虽然某种程度上不符合设计原则，但实际使用最多</p>\n</li>\n<li>\n<p>工厂方法模式：不修改已有类的前提下，通过增加新的工厂类实现扩展</p>\n</li>\n<li>\n<p>抽象工厂模式：不可以增加产品，可以增加产品族</p>\n</li>\n</ul>\n<br/>\n<h3><a id=\"6_583\"></a>6、工厂模式的应用场景：</h3>\n<ul>\n<li>\n<p>jdk中calendar的getInstance方法----简单工厂模式</p>\n</li>\n<li>\n<p>JDBC中的Connection对象的获取</p>\n</li>\n<li>\n<p>Spring中的IOC容器创建管理bean对象</p>\n</li>\n<li>\n<p>反射中Class对象的newInstance方法</p>\n</li>\n</ul>\n<p><br/><br/><br/></p>\n<h1><a id=\"_605\"></a>二、建造者模式</h1>\n<p>它提供了一种创建对象的最佳方式</p>\n<br/>\n<h3><a id=\"1_611\"></a>1、定义：</h3>\n<p>将一个复杂<strong>对象的构建与它的表示分离</strong>，使得同样的构建过程可以创建不同的表示。</p>\n<p>建造者模式（Builder Pattern） <strong>又叫生成器模式</strong>，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p>\n<br/>\n<h3><a id=\"2_619\"></a>2、主要作用：</h3>\n<p>在用户不知道 对象的建造过程和细节的情况下就可以直接创建复杂的对象。</p>\n<p>用户只需要给出指定复杂对象的类型和内容，建造者牧师负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来）</p>\n<br/>\n<h3><a id=\"3__629\"></a>3、四种角色[★ 结合第四点的建造房子理解]</h3>\n<h4><a id=\"1_Product_631\"></a>1) Product(产品角色)：一个具体的产品对象。</h4>\n<h4><a id=\"2_Builder_Product__633\"></a>2) Builder(抽象建造者): 创建一个Product对象的各个部件指定的 <code>接口/抽象类</code>。</h4>\n<h4><a id=\"3_ConcreteBuilder__635\"></a>3) ConcreteBuilder(具体建造者): 实现接口，构建和装配各个部件。</h4>\n<h4><a id=\"4_Director_Builder_637\"></a>4) Director(指挥者): 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。</h4>\n<h4><a id=\"_639\"></a>它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</h4>\n<br/>\n<h3><a id=\"4_645\"></a>4、举例：建造房子</h3>\n<blockquote>\n<p>需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都 需要经历这些过程，下面我们使用建造者模式(Builder Pattern)来完成.</p>\n<p><strong>1、产品角色：Product-房子，定义了房子的属性</strong></p>\n<p><strong>2、<code>抽象建造者</code>：Builder-抽象的工人，定义了一些建造房子组件的方法和接口</strong></p>\n<p><strong>3、<code>具体建造者</code>：ConcreteBuilder-具体的工人，实现了建造房子组件</strong></p>\n<p><strong>4、<code>指挥者：Director-房子的指挥设计者，：核心负责指挥构建一个工程，决定了工程如何构建，按照什么顺序构建</code></strong></p>\n</blockquote>\n<pre><code class=\"lang-java\">// 产品：房子[定义了房子的属性]\npublic class Product {\n\n    private String buildA;\n    private String buildB;\n    private String buildC;\n    private String buildD;\n\n    public String getBuildA() {\n        return buildA;\n    }\n\n    public void setBuildA(String buildA) {\n        this.buildA = buildA;\n    }\n\n    public String getBuildB() {\n        return buildB;\n    }\n\n    public void setBuildB(String buildB) {\n        this.buildB = buildB;\n    }\n\n    public String getBuildC() {\n        return buildC;\n    }\n\n    public void setBuildC(String buildC) {\n        this.buildC = buildC;\n    }\n\n    public String getBuildD() {\n        return buildD;\n    }\n\n    public void setBuildD(String buildD) {\n        this.buildD = buildD;\n    }\n\n    @Override\n    public String toString() {\n        return &quot;Product{&quot; +\n                &quot;buildA=\'&quot; + buildA + \'\\\'\' +\n                &quot;, buildB=\'&quot; + buildB + \'\\\'\' +\n                &quot;, buildC=\'&quot; + buildC + \'\\\'\' +\n                &quot;, buildD=\'&quot; + buildD + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n// 抽象的建造者[抽象的工人]：只是定义一些方法和接口\npublic abstract class Builder {\n    abstract void buildA(); // 地基\n    abstract void buildB(); // 钢筋工程\n    abstract void buildC(); // 铺电线\n    abstract void buildD(); // 粉刷\n\n    // 完工：得到产品\n    abstract Product getProduct();\n}\n\n\n\n// 具体的建造者[工人]:\npublic class Worker extends Builder {\n\n    private Product product;\n\n    public Worker() {\n         product = new Product();// 工人负责创建产品\n    }\n\n    @Override\n    void buildA() {\n        product.setBuildA(&quot;地基&quot;);\n        System.out.println(&quot;地基&quot;);\n    }\n\n    @Override\n    void buildB() {\n        product.setBuildB(&quot;钢筋工程&quot;);\n        System.out.println(&quot;钢筋工程&quot;);\n    }\n\n    @Override\n    void buildC() {\n        product.setBuildC(&quot;铺电线&quot;);\n        System.out.println(&quot;铺电线&quot;);\n    }\n\n    @Override\n    void buildD() {\n        product.setBuildD(&quot;粉刷&quot;);\n        System.out.println(&quot;粉刷&quot;);\n    }\n\n    @Override\n    Product getProduct() {\n        return product;\n    }\n}\n\n\n// 指挥者：核心负责指挥构建一个工程，工程如何构建，按照什么顺序构建，由他决定\npublic class Director {\n\n    // 指挥工人按照顺序建房子\n    public Product build(Builder builder){\n        builder.buildA();\n        builder.buildB();\n        builder.buildC();\n        builder.buildD();\n        return builder.getProduct();\n    }\n}\n\n\n\npublic class Test {\n    public static void main(String[] args) {\n        // 指挥\n        Director director = new Director();\n        // 指挥 具体的工人 完成产品\n        Product build = director.build(new Worker());\n        System.out.println(build.toString());\n    }\n}\n</code></pre>\n<br/>\n<h3><a id=\"5JDK_javalangStringBuilder_791\"></a>5、建造者模式在JDK的应用和源码分析 (java.lang.StringBuilder中的建造者模式)</h3>\n<h4><a id=\"__793\"></a>■ 源码中建造者模式角色分析</h4>\n<p> <strong>Appendable接口</strong>，<strong>是抽象建造者, 定义了抽象方法</strong>，定义了多个append方法(抽象方法)</p>\n<p> <strong>AbstractStringBuilder抽象类，实现了 Appendable接口方法</strong>，<strong>AbstractStringBuilder 是建造者，只是不能实例化</strong></p>\n<p> <strong>StringBuilder 继承了AbstractStringBuilder，即充当了指挥者角色，同时充当了具体的建造者</strong>，建造方法的实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了 AbstractStringBuilder</p>\n<br/>\n<h3><a id=\"6_805\"></a>6、建造者模式的优缺点</h3>\n<blockquote>\n<h3><a id=\"_807\"></a>优点：</h3>\n</blockquote>\n<ul>\n<li><strong>产品的建造和表示分离，实现了解耦。使用建造者模式可以使客户端不必知道产品内部组成的细节</strong></li>\n<li><strong>用户使用不同的具体建造者即可得到不同的产品对象</strong></li>\n<li>将复杂产品的创建步骤分解在不同的方法中，是得创建过程更加清晰</li>\n<li>具体的建造者之间是相互独立的，这有利于系统的扩展。<strong>增加新的具体建造者无需修改原有类库代码，符合“开闭原则”</strong></li>\n</ul>\n<blockquote>\n<h3><a id=\"_814\"></a>缺点：</h3>\n</blockquote>\n<ul>\n<li><strong><code>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式</code></strong>，因此其使用范围受到一定的限制</li>\n<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变的很庞大</li>\n</ul>\n<br/>\n<h3><a id=\"7VS_823\"></a>7、抽象工厂模式VS建造者模式</h3>\n<p><strong>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品</strong>：具有不同分类维度的产品组合，<strong>采用<code>抽象工厂模式不需要关心构建过程，只关心什么产品 由什么工厂生产即可</code></strong>。</p>\n<p>而<strong>建造者模式则是要求按照<code>指定的蓝图建造产品</code>，它的主要目的是通过组装零配件而产生一个新产品。</strong></p>\n<p><br/><br/></p>\n<p>参考内容来源：《尚硅谷Java设计模式（图解+框架源码剖析）》 https://www.bilibili.com/video/BV1G4411c7N4<br />\n《【狂神说Java】通俗易懂的23种设计模式教学（停更）》https://www.bilibili.com/video/BV1mc411h719?p=5</p>\n<p><br/><br/></p>\n<p><strong>如果本文对你有帮助的话记得给一乐点个赞哦，感谢！</strong></p>\n', 1548683933157736450);
INSERT INTO `ys_article_body` VALUES (1548688984236408833, '<br/>\n\n## 一、typora 基本使用\n\nps：文字排版，使用markdown nice 可以一键复制到公众号、知乎：https://editor.mdnice.com/\n\n\n#### `注意细节：标识符的激活，就是靠空格`\n\n（1）快捷键：1-6个#（或ctr+1-6） 分别是1-6级标题:\n\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n\n##### 五级标题\n\n###### 六级标题\n\n(2) 快捷键： ctr+ b **加粗**    ctr + i *倾斜*    反斜杆的标记作用:  `标记`  \n\n(3) 链接：[ 链接标题](放链接地址)      中括号[ ]+小括号()      [百度](http:www.com)\n\n(4）区块引用和区块嵌套：>     区块嵌套 > >\n\n> *区块引用*\n>\n> > **区块嵌套**\n\n(5) 无序列表 -\n ●\n\n(6) **快速插入代码块**：~~~（三个或三个以上的~）回车\n\n~~~java\n// FileName: HelloWorld.java\npublic class HelloWorld {\n  // Java 入口程序，程序从此入口\n  public static void main(String[] args) {\n    System.out.println(\"Hello,World!\"); // 向控制台打印一条语句\n  }\n}\n~~~\n\n\n\n(7)**分割线**: --- （三个-或以上） 回车\n\n---\n\n<br/><br/><br/>\n\n## 二、更换typora 的样式\n\n### 1、准备好漂亮的css主题：\n> 小细节：哈哈哈，**我提供的百度网盘的my_drake.css，对应下文的drake.css样式哈** <br/>\n  链接：https://pan.baidu.com/s/1Dy1MiC7mth4Qo43h0ujLcA \n  提取码：yile\n<br/>\n\n### 2、更换的具体步骤：\n(1) 先拷贝一下漂亮的css主题文件，等下要粘贴它到某个目录下\n(2) 打开typora -》`文件` -》 `偏好设置` -》 `外观` -》`打开主题文件` -》\n(3) 粘贴刚才copy的的漂亮的css主题文件到当前目录\n\n![2282448202112271007576161169907144.png](https://niu.yilele.site/beb19f8a-8bb9-4ee2-a624-7a52eb3a182b.png)\n\n\n![2282448202112271008022331815492957.png](https://niu.yilele.site/7bff6a81-a6d3-413b-ab83-ccfefec8db0b.png)\n\n![228244820211227100810602370145023.png](https://niu.yilele.site/ecb11751-55dd-479f-a9bf-0f88c8ed3fb9.png)\n\n<br/><br/>\n\n\n**如果本文对你有帮助的话记得给一乐点个赞哦，感谢！**', '<br/>\n<h2><a id=\"typora__2\"></a>一、typora 基本使用</h2>\n<p>ps：文字排版，使用markdown nice 可以一键复制到公众号、知乎：https://editor.mdnice.com/</p>\n<h4><a id=\"_7\"></a><code>注意细节：标识符的激活，就是靠空格</code></h4>\n<p>（1）快捷键：1-6个#（或ctr+1-6） 分别是1-6级标题:</p>\n<h1><a id=\"_11\"></a>一级标题</h1>\n<h2><a id=\"_13\"></a>二级标题</h2>\n<h3><a id=\"_15\"></a>三级标题</h3>\n<h4><a id=\"_17\"></a>四级标题</h4>\n<h5><a id=\"_19\"></a>五级标题</h5>\n<h6><a id=\"_21\"></a>六级标题</h6>\n<p>(2) 快捷键： ctr+ b <strong>加粗</strong>    ctr + i <em>倾斜</em>    反斜杆的标记作用:  <code>标记</code></p>\n<p>(3) 链接：<a href=\"%E6%94%BE%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80\" target=\"_blank\"> 链接标题</a>      中括号[ ]+小括号()      <a href=\"http:www.com\" target=\"_blank\">百度</a></p>\n<p>(4）区块引用和区块嵌套：&gt;     区块嵌套 &gt; &gt;</p>\n<blockquote>\n<p><em>区块引用</em></p>\n<blockquote>\n<p><strong>区块嵌套</strong></p>\n</blockquote>\n</blockquote>\n<p>(5) 无序列表 -<br />\n●</p>\n<p>(6) <strong>快速插入代码块</strong>：~~~（三个或三个以上的~）回车</p>\n<pre><code class=\"lang-java\">// FileName: HelloWorld.java\npublic class HelloWorld {\n  // Java 入口程序，程序从此入口\n  public static void main(String[] args) {\n    System.out.println(&quot;Hello,World!&quot;); // 向控制台打印一条语句\n  }\n}\n</code></pre>\n<p>(7)<strong>分割线</strong>: — （三个-或以上） 回车</p>\n<hr />\n<p><br/><br/><br/></p>\n<h2><a id=\"typora__56\"></a>二、更换typora 的样式</h2>\n<h3><a id=\"1css_58\"></a>1、准备好漂亮的css主题：</h3>\n<blockquote>\n<p>小细节：哈哈哈，<strong>我提供的百度网盘的my_drake.css，对应下文的drake.css样式哈</strong> <br/><br />\n链接：https://pan.baidu.com/s/1Dy1MiC7mth4Qo43h0ujLcA<br />\n提取码：yile<br />\n<br/></p>\n</blockquote>\n<h3><a id=\"2_64\"></a>2、更换的具体步骤：</h3>\n<p>(1) 先拷贝一下漂亮的css主题文件，等下要粘贴它到某个目录下<br />\n(2) 打开typora -》<code>文件</code> -》 <code>偏好设置</code> -》 <code>外观</code> -》<code>打开主题文件</code> -》<br />\n(3) 粘贴刚才copy的的漂亮的css主题文件到当前目录</p>\n<p><img src=\"https://niu.yilele.site/beb19f8a-8bb9-4ee2-a624-7a52eb3a182b.png\" alt=\"2282448202112271007576161169907144.png\" /></p>\n<p><img src=\"https://niu.yilele.site/7bff6a81-a6d3-413b-ab83-ccfefec8db0b.png\" alt=\"2282448202112271008022331815492957.png\" /></p>\n<p><img src=\"https://niu.yilele.site/ecb11751-55dd-479f-a9bf-0f88c8ed3fb9.png\" alt=\"228244820211227100810602370145023.png\" /></p>\n<p><br/><br/></p>\n<p><strong>如果本文对你有帮助的话记得给一乐点个赞哦，感谢！</strong></p>\n', 1548688984169299969);
INSERT INTO `ys_article_body` VALUES (1548689573502566402, ' \n<br/>\n\n\n# ☺ 对于单例模式，个人学习需要掌握\n\n- 注意答案的重点标黑了。对于单例模式，掌握，我下面这几点就很棒棒。\n\n>## 1、知道什么是单例：\n>\n>答：**一个类有且仅有一个实例**，[`单例`]，单例模式保证了**系统内存中该类只存在一个对象，节省了系统资源**，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。**实例化对象的时候**，是通过相应的方法，而**不是直接new** \n>\n>\n>\n>## 2、单例模式的意义：节省系统资源\n>\n>答：[一个类仅仅有一个唯一的对象，并且提供一个全局的访问点]，节省系统资源。具体场景：例如公共的全局配置。\n>\n>公共的全局配置在系统运行时候，就需要加载一些配置和属性，这些配置和属性是一定存在了，又是公共的，同时需要在整个生命周期中都存在，所以只需要一份就行，使用单例模式实现。\n>\n>\n>\n>## 3、单例模式的使用场景\n>\n>答：**需要频繁的进行创建和销毁的对象**、经常用到的重量级对象(创建对象时耗时很多或耗费资源很多)、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等）\n>\n>\n>\n>## 4、单例模式的方式\n>\n>- 个人需要掌握：**很简单的饿汉式**(静态常量/静态代码块)、**懒汉式(双重检查**)、**静态内部类**\n>- **了解开发中推荐使用的模式**是**饿汉式**(静态常量/静态代码块)、**双重检查** (懒汉式的改良实用版)、 **静态内部类**、 **枚举方式**\n>- **在掌握双重检查的时候，可以先了解一下不推荐在开发使用的懒汉式的三种情况**(线程不安全、线程安全[同步方法]、线程安全[同步代码块])\n>- **面试写单例模式[饿汉、懒汉]**的话，就写写**饿汉式(静态常量/静态代码块)**、**懒汉式**(**双重检查**[懒汉式的改良实用版])\n>\n>\n>\n>## 5、单例模式利用了jvm的特点[在静态内部类的模式中]\n>\n>### ■ 静态内部类优缺点:(利用了jvm的两个特点，起到了懒加载、线程安全的作用)\n>\n>- 懒加载：利用了jvm**装载**的特点：当外部类加载的时候，内部静态类不会被加载，从而保证了懒加载。\n>- 线程安全：当类在进行**初始化**的时候，**别的线程是无法进入的**。通过类的静态属性只会在第一次加载类的时候初始化，**保证了线程安全**。\n\n\n\n\n\n\n\n\n\n<br/><br/>\n\n\n\n\n\n## 一、什么是单例模式：\n\n在java中的定义是：**一个类有且仅有一个实例**，[`单例`]，并且自行实例化向整个系统提供。\n\n> (1) 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能 \n>\n> (2) 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new\n\n\n\n## 二、实现单例的步骤：\n\n### 1、<font color=red>构造器私有化</font>，`防止new，导致多个实例`，而是在类内部创建对象\n\n### 2、<font color=red>向外暴露一个静态的公共方法</font>  getInstance\n\n\n<br/><br/>\n\n\n\n\n## 三、单例的方式\n\n### ■ 单例模式有八种方式：\n\n  饿汉式(静态常量/静态代码块) \n\n  懒汉式(线程不安全/线程安全，同步方法/线程安全，同步代码块) \n\n  双重检查 \n\n  静态内部类 \n\n  枚举\n\n<br/>\n\n### ★ 饿汉式和懒汉式区别：\n\n饿汉式：在类内部一开始初始化时就创建好实例，而懒汉式是需要用的时候才去创建实例\n\n\n<br/><br/>\n\n\n### ■ 饿汉式(静态常量/静态代码块) \n\n> **`在开发中推荐使用，尤其是该类的实例会用到，避免了造成内存的浪费`**，如果该类的实例不用，则会造成内存的浪费。\n\n~~~java\n/**\n* 饿汉式(静态常量)\n*/\npublic class Singleton{\n    private static final Singleton singleton  = new Singleton();//饿汉式，初始化时就创建好了实例[使用了final常量-->饿汉式(静态常量)]\n    \n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    \n    public static Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        return singleton;\n    }\n}\n~~~\n\n~~~java\n/**\n* 饿汉式(静态代码块)\n*/\npublic class Singleton{\n    private static Singleton singleton  = new Singleton();//饿汉式，初始化时就创建好了实例\n    \n    //代码块[使用了static代码块-->饿汉式(静态代码块)]\n    static{\n        singleton = new Singleton();\n    }\n    \n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    \n    public static Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        return singleton;\n    }\n}\n~~~\n\n>### ■ 饿汉式(静态常量) 和 饿汉式（静态代码块) 的优点、缺点：相同\n>\n>#### □ 优点：实现较为`简单`，在类加载时就完成了实例化，`避免了多线程同步问题`\n>\n>#### □ 缺点：在类加载时就完成了实例化（使类加载的情况有很多种，不一定是调用getInstance()方法使类进行加载的），`没有达到懒加载`的效果。如果程序从始至终未用到该实例，则`造成了空间浪费`\n\n\n\n<br/>\n\n\n\n### ■ 懒汉式(线程不安全/ 线程安全，同步方法 / 线程安全，同步代码块) \n\n#### □ 懒汉式(线程不安全)\n\n~~~java\npublic class Singleton{\n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    private static Singleton singleton;\n    public static Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        if(singleton == null){\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n    \n}\n\n~~~\n\n> ### ■ 懒汉式(线程不安全) 优缺点：起到懒加载的效果，但是`只适合在单线程下使用`（`开发中不推荐使用`）\n>\n> #### □ 线程不安全原因：如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式\n\n<br/>\n\n#### □ 懒汉式(线程安全，同步方法)\n\n~~~java\npublic class Singleton{\n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    private static Singleton singleton;\n    //同步方法，synchronized直接加在方法上\n    public static synchronized Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        if(singleton == null){\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n\n}\n~~~\n\n> ### ■ 懒汉式(线程安全，同步方法) 优缺点：起到懒加载的效果，线程安全，但是`调用效率低`（`开发中不推荐使用`）\n\n<br/>\n\n#### □ 懒汉式(线程安全，同步代码块)\n\n~~~java\npublic class Singleton{\n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    private static Singleton singleton;\n    public static Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        if(singleton == null){\n            //同步代码块，synchronized是单独作为代码块使用\n            synchronized (Singleton.class){\n                singleton = new Singleton();\n            }     \n        }\n        return singleton;\n    }\n}\n~~~\n\n>### ■ 懒汉式(线程安全，同步代码块) 优缺点：起到懒加载的效果，但是`只适合在单线程下使用`（`开发中不推荐使用`）\n>\n>□ 线程不安全原因：和 □ 懒汉式(线程不安全)一样。\n\n\n<br/>\n\n\n### ■ 双重检查\n\n~~~java\npublic class Singleton{\n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    private static volatile Singleton singleton;\n    public static Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        //第一层检查\n        if(singleton == null){\n            //同步代码块\n            synchronized (Singleton.class){\n                 //第二层检查\n                if(singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n\n        }\n        return singleton;\n    }\n\n}\n~~~\n\n> ### 双重检查优缺点：解决了同步代码块方式的线程安全问题。\n>\n> ##### 其实就是上面的 □ 懒汉式(线程安全，同步代码块)的优化改良版。\n\n\n<br/>\n\n\n### ■ 静态内部类\n\n~~~java\npublic class Singleton{\n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    //静态内部类,在其内部以静态常量的方式实例化对象\n    private static class SingletonInstance{\n        private static final Singleton singleton = new Singleton();//常量静态属性，实例化对象[初始化]\n    }\n    public static Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        return SingletonInstance.singleton;\n    }\n}\n~~~\n\n> ### ■ 静态内部类优缺点:(利用了jvm的两个特点，起到了懒加载、线程安全的作用)\n>\n> - 懒加载：利用了jvm**装载**的特点：当外部类加载的时候，内部静态类不会被加载，从而保证了懒加载。\n> - 线程安全：当类在进行**初始化**的时候，别的线程是无法进入的。通过类的静态属性只会在第一次加载类的时候初始化，保证了线程安全。\n>\n> ##### 1.当外部类 Singleton被装载时，静态内部类 SingletonInstance不会被立即装载，实现懒加载\n>\n> ##### 2.当外部类 Singleton调用getInstance()时，静态内部类 SingletonInstance只被装载一次，在初始化静态内部类SingletonInstance的静态常量属性 singleton，保证了线程安全。\n\n\n<br/>\n\n\n### ■ 枚举方式\n\n~~~java\nenum Singleton{\n    INSTANCE;\n    public void method(){\n//            操作方法\n    }\n\n}\n~~~\n\n> ### ■ 枚举方式优缺点: 线程安全，效率高，还可`防止反序列化重新创建新的对象`.\n\n\n\n\n\n<br/><br/>\n\n\n\n## 四、单例的使用场景\n\n需要频繁的进行创建和销毁的对象、\n\n创建对象时耗时过多或 耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等）\n\n\n<br/><br/>\n\n\n\n\n参考内容来源：《尚硅谷Java设计模式（图解+框架源码剖析）》 https://www.bilibili.com/video/BV1G4411c7N4\n\n\n<br/><br/>\n\n**如果本文对你有帮助的话记得给一乐点个赞哦，感谢！**', '<br/>\n<h1><a id=\"__4\"></a>☺ 对于单例模式，个人学习需要掌握</h1>\n<ul>\n<li>注意答案的重点标黑了。对于单例模式，掌握，我下面这几点就很棒棒。</li>\n</ul>\n<blockquote>\n<h2><a id=\"1_8\"></a>1、知道什么是单例：</h2>\n<p>答：<strong>一个类有且仅有一个实例</strong>，[<code>单例</code>]，单例模式保证了<strong>系统内存中该类只存在一个对象，节省了系统资源</strong>，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。<strong>实例化对象的时候</strong>，是通过相应的方法，而<strong>不是直接new</strong></p>\n<h2><a id=\"2_14\"></a>2、单例模式的意义：节省系统资源</h2>\n<p>答：[一个类仅仅有一个唯一的对象，并且提供一个全局的访问点]，节省系统资源。具体场景：例如公共的全局配置。</p>\n<p>公共的全局配置在系统运行时候，就需要加载一些配置和属性，这些配置和属性是一定存在了，又是公共的，同时需要在整个生命周期中都存在，所以只需要一份就行，使用单例模式实现。</p>\n<h2><a id=\"3_22\"></a>3、单例模式的使用场景</h2>\n<p>答：<strong>需要频繁的进行创建和销毁的对象</strong>、经常用到的重量级对象(创建对象时耗时很多或耗费资源很多)、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等）</p>\n<h2><a id=\"4_28\"></a>4、单例模式的方式</h2>\n<ul>\n<li>个人需要掌握：<strong>很简单的饿汉式</strong>(静态常量/静态代码块)、<strong>懒汉式(双重检查</strong>)、<strong>静态内部类</strong></li>\n<li><strong>了解开发中推荐使用的模式</strong>是<strong>饿汉式</strong>(静态常量/静态代码块)、<strong>双重检查</strong> (懒汉式的改良实用版)、 <strong>静态内部类</strong>、 <strong>枚举方式</strong></li>\n<li><strong>在掌握双重检查的时候，可以先了解一下不推荐在开发使用的懒汉式的三种情况</strong>(线程不安全、线程安全[同步方法]、线程安全[同步代码块])</li>\n<li><strong>面试写单例模式[饿汉、懒汉]<strong>的话，就写写</strong>饿汉式(静态常量/静态代码块)</strong>、<strong>懒汉式</strong>(<strong>双重检查</strong>[懒汉式的改良实用版])</li>\n</ul>\n<h2><a id=\"5jvm_37\"></a>5、单例模式利用了jvm的特点[在静态内部类的模式中]</h2>\n<h3><a id=\"_jvm_39\"></a>■ 静态内部类优缺点:(利用了jvm的两个特点，起到了懒加载、线程安全的作用)</h3>\n<ul>\n<li>懒加载：利用了jvm<strong>装载</strong>的特点：当外部类加载的时候，内部静态类不会被加载，从而保证了懒加载。</li>\n<li>线程安全：当类在进行<strong>初始化</strong>的时候，<strong>别的线程是无法进入的</strong>。通过类的静态属性只会在第一次加载类的时候初始化，<strong>保证了线程安全</strong>。</li>\n</ul>\n</blockquote>\n<p><br/><br/></p>\n<h2><a id=\"_58\"></a>一、什么是单例模式：</h2>\n<p>在java中的定义是：<strong>一个类有且仅有一个实例</strong>，[<code>单例</code>]，并且自行实例化向整个系统提供。</p>\n<blockquote>\n<p>(1) 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</p>\n<p>(2) 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</p>\n</blockquote>\n<h2><a id=\"_68\"></a>二、实现单例的步骤：</h2>\n<h3><a id=\"1font_colorredfontnew_70\"></a>1、<font color=red>构造器私有化</font>，<code>防止new，导致多个实例</code>，而是在类内部创建对象</h3>\n<h3><a id=\"2font_colorredfont__getInstance_72\"></a>2、<font color=red>向外暴露一个静态的公共方法</font>  getInstance</h3>\n<p><br/><br/></p>\n<h2><a id=\"_80\"></a>三、单例的方式</h2>\n<h3><a id=\"__82\"></a>■ 单例模式有八种方式：</h3>\n<p>饿汉式(静态常量/静态代码块)</p>\n<p>懒汉式(线程不安全/线程安全，同步方法/线程安全，同步代码块)</p>\n<p>双重检查</p>\n<p>静态内部类</p>\n<p>枚举</p>\n<br/>\n<h3><a id=\"__96\"></a>★ 饿汉式和懒汉式区别：</h3>\n<p>饿汉式：在类内部一开始初始化时就创建好实例，而懒汉式是需要用的时候才去创建实例</p>\n<p><br/><br/></p>\n<h3><a id=\"__104\"></a>■ 饿汉式(静态常量/静态代码块)</h3>\n<blockquote>\n<p><strong><code>在开发中推荐使用，尤其是该类的实例会用到，避免了造成内存的浪费</code></strong>，如果该类的实例不用，则会造成内存的浪费。</p>\n</blockquote>\n<pre><code class=\"lang-java\">/**\n* 饿汉式(静态常量)\n*/\npublic class Singleton{\n    private static final Singleton singleton  = new Singleton();//饿汉式，初始化时就创建好了实例[使用了final常量--&gt;饿汉式(静态常量)]\n    \n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    \n    public static Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        return singleton;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">/**\n* 饿汉式(静态代码块)\n*/\npublic class Singleton{\n    private static Singleton singleton  = new Singleton();//饿汉式，初始化时就创建好了实例\n    \n    //代码块[使用了static代码块--&gt;饿汉式(静态代码块)]\n    static{\n        singleton = new Singleton();\n    }\n    \n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    \n    public static Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        return singleton;\n    }\n}\n</code></pre>\n<blockquote>\n<h3><a id=\"_____143\"></a>■ 饿汉式(静态常量) 和 饿汉式（静态代码块) 的优点、缺点：相同</h3>\n<h4><a id=\"__145\"></a>□ 优点：实现较为<code>简单</code>，在类加载时就完成了实例化，<code>避免了多线程同步问题</code></h4>\n<h4><a id=\"_getInstance_147\"></a>□ 缺点：在类加载时就完成了实例化（使类加载的情况有很多种，不一定是调用getInstance()方法使类进行加载的），<code>没有达到懒加载</code>的效果。如果程序从始至终未用到该实例，则<code>造成了空间浪费</code></h4>\n</blockquote>\n<br/>\n<h3><a id=\"_____155\"></a>■ 懒汉式(线程不安全/ 线程安全，同步方法 / 线程安全，同步代码块)</h3>\n<h4><a id=\"__157\"></a>□ 懒汉式(线程不安全)</h4>\n<pre><code class=\"lang-java\">public class Singleton{\n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    private static Singleton singleton;\n    public static Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        if(singleton == null){\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n    \n}\n\n</code></pre>\n<blockquote>\n<h3><a id=\"___174\"></a>■ 懒汉式(线程不安全) 优缺点：起到懒加载的效果，但是<code>只适合在单线程下使用</code>（<code>开发中不推荐使用</code>）</h3>\n<h4><a id=\"_if_singleton__null_176\"></a>□ 线程不安全原因：如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</h4>\n</blockquote>\n<br/>\n<h4><a id=\"__180\"></a>□ 懒汉式(线程安全，同步方法)</h4>\n<pre><code class=\"lang-java\">public class Singleton{\n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    private static Singleton singleton;\n    //同步方法，synchronized直接加在方法上\n    public static synchronized Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        if(singleton == null){\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n\n}\n</code></pre>\n<blockquote>\n<h3><a id=\"___197\"></a>■ 懒汉式(线程安全，同步方法) 优缺点：起到懒加载的效果，线程安全，但是<code>调用效率低</code>（<code>开发中不推荐使用</code>）</h3>\n</blockquote>\n<br/>\n<h4><a id=\"__201\"></a>□ 懒汉式(线程安全，同步代码块)</h4>\n<pre><code class=\"lang-java\">public class Singleton{\n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    private static Singleton singleton;\n    public static Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        if(singleton == null){\n            //同步代码块，synchronized是单独作为代码块使用\n            synchronized (Singleton.class){\n                singleton = new Singleton();\n            }     \n        }\n        return singleton;\n    }\n}\n</code></pre>\n<blockquote>\n<h3><a id=\"___219\"></a>■ 懒汉式(线程安全，同步代码块) 优缺点：起到懒加载的效果，但是<code>只适合在单线程下使用</code>（<code>开发中不推荐使用</code>）</h3>\n<p>□ 线程不安全原因：和 □ 懒汉式(线程不安全)一样。</p>\n</blockquote>\n<br/>\n<h3><a id=\"__227\"></a>■ 双重检查</h3>\n<pre><code class=\"lang-java\">public class Singleton{\n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    private static volatile Singleton singleton;\n    public static Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        //第一层检查\n        if(singleton == null){\n            //同步代码块\n            synchronized (Singleton.class){\n                 //第二层检查\n                if(singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n\n        }\n        return singleton;\n    }\n\n}\n</code></pre>\n<blockquote>\n<h3><a id=\"_251\"></a>双重检查优缺点：解决了同步代码块方式的线程安全问题。</h3>\n<h5><a id=\"___253\"></a>其实就是上面的 □ 懒汉式(线程安全，同步代码块)的优化改良版。</h5>\n</blockquote>\n<br/>\n<h3><a id=\"__259\"></a>■ 静态内部类</h3>\n<pre><code class=\"lang-java\">public class Singleton{\n    private Singleton(){}//构造器私有化，防止new，导致多个实例\n    //静态内部类,在其内部以静态常量的方式实例化对象\n    private static class SingletonInstance{\n        private static final Singleton singleton = new Singleton();//常量静态属性，实例化对象[初始化]\n    }\n    public static Singleton getInstance(){//向外暴露一个静态的公共方法  getInstance\n        return SingletonInstance.singleton;\n    }\n}\n</code></pre>\n<blockquote>\n<h3><a id=\"_jvm_274\"></a>■ 静态内部类优缺点:(利用了jvm的两个特点，起到了懒加载、线程安全的作用)</h3>\n<ul>\n<li>懒加载：利用了jvm<strong>装载</strong>的特点：当外部类加载的时候，内部静态类不会被加载，从而保证了懒加载。</li>\n<li>线程安全：当类在进行<strong>初始化</strong>的时候，别的线程是无法进入的。通过类的静态属性只会在第一次加载类的时候初始化，保证了线程安全。</li>\n</ul>\n<h5><a id=\"1_Singleton_SingletonInstance_279\"></a>1.当外部类 Singleton被装载时，静态内部类 SingletonInstance不会被立即装载，实现懒加载</h5>\n<h5><a id=\"2_SingletongetInstance_SingletonInstanceSingletonInstance_singleton_281\"></a>2.当外部类 Singleton调用getInstance()时，静态内部类 SingletonInstance只被装载一次，在初始化静态内部类SingletonInstance的静态常量属性 singleton，保证了线程安全。</h5>\n</blockquote>\n<br/>\n<h3><a id=\"__287\"></a>■ 枚举方式</h3>\n<pre><code class=\"lang-java\">enum Singleton{\n    INSTANCE;\n    public void method(){\n//            操作方法\n    }\n\n}\n</code></pre>\n<blockquote>\n<h3><a id=\"___299\"></a>■ 枚举方式优缺点: 线程安全，效率高，还可<code>防止反序列化重新创建新的对象</code>.</h3>\n</blockquote>\n<p><br/><br/></p>\n<h2><a id=\"_309\"></a>四、单例的使用场景</h2>\n<p>需要频繁的进行创建和销毁的对象、</p>\n<p>创建对象时耗时过多或 耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等）</p>\n<p><br/><br/></p>\n<p>参考内容来源：《尚硅谷Java设计模式（图解+框架源码剖析）》 https://www.bilibili.com/video/BV1G4411c7N4</p>\n<p><br/><br/></p>\n<p><strong>如果本文对你有帮助的话记得给一乐点个赞哦，感谢！</strong></p>\n', 1548689573435457538);
INSERT INTO `ys_article_body` VALUES (1548691214062632963, '<br/>\n\n> **温馨提示：重点掌握的前面都标注了 ☆**\n\n<br/>\n\n## 一、Linux 是什么？\n\n### Linux 是一个操作系统。\n\n\n![](https://files.mdnice.com/user/18969/755baa70-2234-4d43-81ad-1b8b93e26485.png)\n\n\n\n<br/>\n\n\n> **我们的 Linux 主要是系统调用和内核那两层。**\n>\n> 当然直观地看，我们使用的操作系统还包含一些在其上运行的应用程序，比如文本编辑器、浏览器、电子邮件等。\n>\n> \n>\n> **Linux 本身只是操作系统的内核。**\n>\n> 内核是使其它程序能够运行的基础。它实现了多任务和硬件管理，用户或者系统管理员交互运行的所有程序实际上都运行在内核之上。\n>\n> 其中有些程序是必需的，比如说，**命令行解释器（shell），它用于用户交互和编写 shell 脚本。**\n>\n> Linux 是一套**免费使用**和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的**多用户、多任务、支持多线程和多 CPU 的操作系统。**\n>\n> Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 \n>\n> -----\n>\n> \n>\n> **Linux之父** Linus 没有自己去开发这些应用程序，而是使用已有的自由软件。这减少了搭建开发环境所需花费的工作量。实际上，他经常改写内核，使得那些程序能够更容易地在 Linux 上运行。许多重要的软件，包括 C 编译器，都来自于自由软件基金 GNU 项目。GNU 项目开始于 1984 年，目的是为了开发一个完全类似于 UNIX 的免费操作系统。为了表扬 GNU 对 Linux 的贡献，许多人把 Linux 称为 **GNU/Linux**（GNU 有自己的内核）。\n>\n> **Linux之父** 芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写linux的内核。他还独自开发了git版本控制工具。\n\n\n\n\n<br/><br/><br/><br/>\n\n\n\n\n## 二、Unix 和 Linux 的关系：\n\n#### Linux产品成功的模仿了UNIX系统和功能。Linux是免费的，Unix是收费的。\n\n- UNIX是商业操作系统，贵的吓人，一般小公司用不起的。\n\n- Linux是Linus模仿UNIX写出来的一个开源操作系统，是免费的。不过为linux开发的很多商业组件是要收费的，而且服务也是收费的。\n\n\n\n\n<br/><br/><br/><br/>\n\n\n\n\n## 三、shell（壳）和 bash 的关系：\n\n### 1、Shell 是指\"提供给使用者使用界面\"的软件（`命令解析器`），类似于 DOS 下的 command（命令行）和后来的 cmd.exe 。它之所以被称作 Shell 是因为它隐藏了操作系统底层的细节。\n\n> 有壳就有核，这里的核就是指 UNIX/Linux 内核，Shell 是指\"提供给使用者使用界面\"的软件（命令解析器)\n>\n> **`shell 既是用户交互的界面，也是控制系统的脚本语言。`**\n>\n> **Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。**Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。\n>\n> **Shell 既是一种命令语言，又是一种程序设计语言。**\n>\n> Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。\n\n<br/>\n\n#### ■ Shell 脚本(shell script):\n\n简单说，shell script是利用shell的功能所写的一个程序，这个程序是使用**纯文本文件，将一些shell的语法与指令写在里面**，然后用正规表示法，管道命令以及数据流重导向等功能，以达到我们所想要的处理目的。\n\n- 习惯叫法上，shell 脚本通常只叫shell。但是你需要明白shell和shell脚本的区别，**一个是命令解析器，一个是编写了shell指令的文本文件。**\n\n<br/>\n\n#### ■ Shell 环境:\n\n- Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。\n\n**Linux 的 Shell 种类众多，常见的有：**\n\n- **`Bourne Shell（/usr/bin/sh或/bin/sh）`**\n- Bourne Again Shell（/bin/bash）\n- C Shell（/usr/bin/csh）\n- K Shell（/usr/bin/ksh）\n- Shell for Root（/sbin/sh）\n\n\n<br/>\n\n\n### 2、bash：\n\n> Bash，也就是 Bourne Again Shell，由于**`易用和免费`**，Bash 在日常工作中被广泛使用。\n>\n> 同时，**Bash 也是大多数 Linux 系统默认的 Shell。**\n\n\n\n\n<br/><br/><br/><br/>\n\n\n\n\n## ☆ 四、Linux 目录结构介绍\n\n\n![9ab329af9f4d486ea1dab7da3d409908.png](https://niu.yilele.site/3091fd83-ec35-4e0d-bbf9-692a3a06dd81.png)\n\n\n/bin： bin是Binary的缩写, 这个目录存放着最经常使用的命令。\n\n/boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。（不 要动） \n\n/dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问 文件的方式是相同的。 \n\n**`/etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。`** [`管理配置`]\n\n**`/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。`** [`默认/home 是空的，需要自己手动创建一个目录，在/home目录下创建的目录相当于c盘Users下的目录`]\n\n/lib： 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。 （不要动） \n\n/lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（存放 突然关机的一些文件） \n\n/media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备 挂载到这个目录下。 \n\n/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上， 然后进入该目录就可以查看光驱里的内容了。（我们后面会把一些本地文件挂载在这个目录下） \n\n**`/opt：这是给主机额外安装软件所摆放的目录。`**比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 [`安装程序`]\n\n/proc： 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。（不用管） \n\n**/root：该目录为系统管理员，也称作超级权限者的用户主目录。** [`系统管理员`]\n\n**/sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。** [`超级用户管理的程序`]\n\n**/srv：该目录存放一些服务启动之后需要提取的数据。** [`服务器启动提取的数据`]\n\n**/sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。** [`文件系统`]\n\n**/tmp：这个目录是用来存放一些临时文件的。用完即丢的文件，可以放在这个目录下，安装包！** \n\n**`/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows 下的program files目录。`** [`程序目录`]\n\n**`/usr/bin： 系统用户使用的应用程序。`**  [`应用程序`]\n\n**`/usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。`**  [`高级程序、守护程序`]\n\n**/usr/src： 内核源代码默认的放置目录。** \n\n**/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。`包括各种日志文件`。**  [`修改的目录、日志`]\n\n/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被 删掉或清除。 \n\n**/www：存放服务器网站相关的资源，环境，网站的项目。**\n\n\n\n\n<br/><br/><br/><br/>\n\n\n\n\n## ☆ 五、Linux系统分为两种：\n\n### 1、**RedHat系列**：Redhat、Centos、Fedora等 \n\n### 2、**Debian系列**：Debian、Ubuntu等\n\n- **`RedHat系列的包管理工具是yum`**  \n\n- **`Debian系列的包管理工具是apt-get`**\n\n> 一般你所见到的是Linux，比如 **Ubuntu**、RedHat、**CentOS**、Debian、Fedora、SuSE、OpenSUSE、 Arch Linux、SolusOS等，**`他们都是Linux不同的发行版本。`**\n\n\n\n\n<br/><br/><br/><br/>\n\n\n\n\n## ☆ 六、查看系统版本信息\n\n1、步骤1：`cat /etc/os-release`\n\n2、步骤2：分别对于redhat、debain版本：\n\n- 查看 redhat 版本命令:\n\n  ~~~bash\n  cat /etc/redhat-release\n  ~~~\n\n- 查看 debain 版本命令：\n\n  ~~~bash\n  cat /etc/debian_version\n  ~~~\n\n\n\n\n\n<br/><br/><br/><br/>\n\n\n\n## 七、后缀是.rpm\n\n>1、**rpm 是Linux软件扩展名，是Red Hat Linux提供的一种包封装格式**。现在许多Linux发行版本都使用。\n>\n>2、后缀为.deb是Debain Linux提供的一种包封装格式。\n>\n>3、后缀为.tar.gz、tar.Z、tar.bz2或.tgz是使用Unix系统打包工具tar打包的。\n>\n>4、后缀为.bin 的一般是一些商业软件\n>\n>- 通过扩展名可以了解软件格式，进而了解软件安装。\n\n### 1、 RPM软件包管理器（红帽软件包管理器）\n\n与直接从源代码安装相比，软件包管理易于安装和卸载；易于更新已安装的软件包；易于保护配置文件；易于跟踪已安装文件。\n\n几乎所有的Linux发行版本都使用某种形式的软件包管理安装、更新和卸载软件。\n\n<br/>\n\n### 2、rpm 命令：\n\nrpm 最初是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，现在许多Linux发行版本都使用。\n\n> rpm的命令是以 rpm 开头的！\n\n□ **使用举例：**\n\n- 查询安装的yum依赖包：rpm -qa|grep yum\n- 查看epel依赖包：rpm -qa|grep epel\n\n<br/>\n\n### 3、命令语法：rpm [选项] [参数]\n\n- #### RPM 命令主要参数：\n\n  -a 查询所有套件\n\n  -q 使用询问模式，当遇到任何问题时，rpm指令会先询问用户\n\n  -l 显示套件的文件列表\n\n  -i 安装软件\n  -t 测试安装，不是真的安装\n\n  -p 显示安装进度\n  -f 忽略任何错误\n  -U 升级安装\n  -v 检测套件是否正确安装\n\n\n\n\n<br/><br/><br/><br/>\n\n\n## ☆ 八、yum 或者 apt\n\n### ☆ 1、yum 或 apt 的关系:\n\n#### RedHat系列的包管理工具是 **yum**  \n\n#### Debian系列的包管理工具是 **apt-get**\n\n<br/>\n\n### 2、yum 详细介绍：\n\n#### (1) yum 是什么？\n\nYellow dog Updater Modified的简称，起初是由yellow dog这一发行版的开发者研发，用python写成，最初叫做yup(yellow dog updater)，\n\n后来被改名为 yum。\n\n#### (2) **yum 特点**\n\n- **可以同时配置多个资源库(Repository)**\n- **`简洁的配置文件(/etc/yum.conf，/etc/yum.repos.d 下的文件)`**\n- 自动解决增加或删除rpm包时遇到的倚赖性问题\n- 使用方便\n- 保持与RPM数据库的一致性\n\n#### (3) yum 的作用\n\n- 更加方便地 **添加/删除/更新RPM包**.\n- **自动解决包的倚赖性问题**.\n- 更加方便地管理大量系统的更新问题.、\n\n\n<br/>\n\n\n### 3、 yum 的核心---仓库\n\nyum的关键之处是要有可靠的repository(软件仓库)\n\n**软件仓库**，它可以是http或ftp站点， 也可以是本地软件池，**但必须包含rpm的header**，\n\n`header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等`。\n\n正是收集了这些 header并加以分析，才能自动化地完成余下的任务。\n\n\n<br/>\n\n\n### 4、yum 配置文件介绍---yum.conf 和 CentOS-Base.repo：\n\n#### (1) yum 主配置文件 /etc/yum.conf\n\n~~~bash\n[root@iZwz9535z41cmgcpkm7i81Z etc]# cat yum.conf\n[main]\ncachedir=/var/cache/yum/$basearch/$releasever  # yum缓存的目录，yum在此存储下载的rpm包和数据库，一般是/var/cache/yum\nkeepcache=0    # 是否保存缓存，为0，让缓存一直为空\ndebuglevel=2   # debuglevel：除错级别，0-10,默认是2\nlogfile=/var/log/yum.log    # yum的日志文件，默认是/var/log/yum.log\nexactarch=1    #  准确匹配，精确匹配硬件平台，只有完全相同才更新。有两个选项1和0,代表是否只升级和你安装软件包cpu体系一致的包\nobsoletes=1	   # 当使用升级模式时，一些包没有用了，可以删除（取值1）\ngpgcheck=1     # 安装时是否检查RPM包的PGP签名\nplugins=1      # Yum插件是否可用\ninstallonly_limit=5   # 安装限制           # bugtracker_url：bug 跟踪路径\nbugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&ref=http://bugs.centos.org/bug_report_page.php?   category=yum   # 目录\ndistroverpkg=centos-release   # 定从哪里获取系统版本相关的信息\n\n\n#  This is the default, if you make this bigger yum won\'t see if the metadata\n# is newer on the remote and so you\'ll \"gain\" the bandwidth of not having to\n# download the new metadata and \"pay\" for it by yum not having correct\n# information.\n#  It is esp. important, to have correct metadata, for distributions like\n# Fedora which don\'t keep old packages around. If you don\'t like this checking\n# interupting your command line usage, it\'s much better to have something\n# manually check the metadata once an hour (yum-updatesd will do this).\n# metadata_expire=90m\n\n# PUT YOUR REPOS HERE OR IN separate files named file.repo\n# in /etc/yum.repos.d\n~~~\n\n<br/>\n\n#### (2) yum源的默认配置文件 /etc/yum.repos.d/CentOS-Base.repo\n\n- mirrorlist   镜像站点\n\n- baseurl      仓库路径(固定路径)\n\n- enabled=1    是否打开仓库，为1则是打开仓库，为0则是关闭仓库\n- gpgcheck     是否需要查阅RPM文件内数字证书，0表示不检查，1表示检查 (GPG是加密和数字签名的免费工具)\n- gpgkey       数字证书公钥文件所在位置，使用默认值\n\n\n  ~~~bash\n  [root@iZwz9535z41cmgcpkm7i81Z yum.repos.d]# cat CentOS-Base.repo\n  [base]\n  name=CentOS-$releasever - Base\n  failovermethod=priority\n  baseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/\n  gpgcheck=1\n  gpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7\n   \n  #released updates \n  [updates]\n  name=CentOS-$releasever - Updates\n  failovermethod=priority\n  baseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/updates/$basearch/\n  gpgcheck=1\n  gpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7\n   \n  #additional packages that may be useful\n  [extras]\n  name=CentOS-$releasever - Extras\n  failovermethod=priority\n  baseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/extras/$basearch/\n  gpgcheck=1\n  gpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7\n   \n  #additional packages that extend functionality of existing packages\n  [centosplus]\n  name=CentOS-$releasever - Plus\n  failovermethod=priority\n  baseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/\n  gpgcheck=1\n  enabled=0\n  gpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7\n   \n  #contrib - packages by Centos Users\n  [contrib]\n  name=CentOS-$releasever - Contrib\n  failovermethod=priority\n  baseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/contrib/$basearch/\n  gpgcheck=1\n  enabled=0\n  gpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7\n  ~~~\n\n <br/> \n\n### ☆ 5、yum 包管理工具\n\n- 作用：**添加/删除/更新RPM包**.**自动解决包的倚赖性问题**.\n- 核心是repository 仓库\n\n##### ■ `和maven、npm一样，凡是看到，涉及到自动管理包，必须考虑的是下载速度的提速。`\n\n■ 配置一下阿里云镜像加速：\n\n#### (1) 系统是 debain：\n\n- 记得先备份，可以选择创建一个文件夹，然后拷贝一份放进去\n\n  ~~~bash\n  root@f1cfb81dedfd:/etc/apt# mkdir cat sources.list.backup\n  root@f1cfb81dedfd:/etc/apt# cp sources.list ./sources.list.backup\n  root@f1cfb81dedfd:/etc/apt/sources.list.backup# cd ../\n  ~~~\n\n- 使用命令 echo 覆盖+追加方式 [若是没有vim工具，则使用bash命令]\n\n  ~~~bash\n  deb https://mirrors.aliyun.com/debian bullseye main\n  deb https://mirrors.aliyun.com/debian-security bullseye-security main\n  deb https://mirrors.aliyun.com/debian bullseye-updates main\n  ~~~\n\n- 执行一下更新命令：\n\n  ~~~bash\n   apt-get update -y\n  ~~~\n\n<br/>\n\n#### (2) 系统是 redhat：\n\n- 记得先备份，可以选择创建一个文件夹，然后拷贝一份放进去\n\n  ~~~bash\n  root@f1cfb81dedfd:/etc/yum.repos.d# mv /etc/yum.repos.d /etc/yum.repos.d.backup\n  root@f1cfb81dedfd:/etc/yum.repos.d# \n  ~~~\n\n- 在阿里云镜像官网下载文件 CentOS-Base.repo [下载对应你的系统版本的Centos-Base.repo，下载的名字不是这个，可以自己改一下哦]\n\n  - 地址：https://mirrors.aliyun.com/repo/\n\n- 使用工具xftp，删除掉原先的CentOS-Base.repo，然后将下载下来的CentOS-Base.repo，传输到/etc/yum.repos.d目录下\n\n<br/>  \n\n### ☆ 6、yum的常用命令：\n\n> 参数 -y（当安装/卸载/更新过程提示选择全部为\"yes\"）\n\n- 安装：yum install xxx\n- 删除：yum remove xxx\n- 升级: yum update xxx\n  - 升级所有软件(相当于升级系统)：yum update\n\n- 查询：yum list 列出yum服务器上面所有的软件名称\n  - yum list h* #找出以h开头的软件名称\n  - yum list installed #查找所有已安装的列表\n- 清除缓存：\n  - yum clean packages 清除缓存目录下的软件包\n  - yum clean oldheaders 清除缓存目录下旧的 headers\n  - yum clean headers 清除缓存目录下的 headers\n  - yum all = yum clean packages + yum clean oldheaders  清除缓存目录下的软件包及旧的header\n- 生成缓存：yum makecache \n\n<br/>\n\n#### ■ yum源改变了(例如修改了yum的配置文件)，需要清除下数据再重新建立缓存\n\n- yum clean all # 清除一下之前的配置等数据\n- yum makecache # 生成新的缓存\n\n\n\n\n\n<br/><br/><br/><br/>\n\n\n\n\n## ☆ 九、文本编译器 vim 常用操作：\n\n### 1、vim 介绍：一个文本编辑器\n\nvim 通过一些插件可以实现和IDE一样的功能！ Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程 序员中被广泛使用。\n\n#### ■ vim 和 vi 的关系：\n\n简单理解，vim 是 vi 的升级版。\n\n<br/>\n\n#### ■ 关于 文本编辑器需要掌握：\n\n**`查看/查找内容，编辑内容，保存内容，光标位置的移动`**\n\n> ### ● vim的常用模式有分为 命令模式(正常模式)，插入模式，底线命令模式。\n>\n> - 正常模式/命令模式：主要用来浏览文本内容。一开始打开vim都是正常模式。**按 Esc键 任何情况，都可以返回正常模式**。\n> - 底线命令模式：**在正常模式下，按冒号：即可切换到底线命令模式。**\n> - 插入编辑模式：用来向文本中添加内容的。在正常模式下，**按 Insert 键，即可进入插入编辑模式**。\n> - 注意：退出vim，如果使用vim修改任何文本后需要保存并退出，**需要在正常/命令模式下（Esc键），输入 shift+zz** \n>\n> （或者在正常模式，进入底线命令模式(输入:)后，然后在冒号后面输入wq，回车，保存并退出vim。）\n\n<br/>\n\n### 2、使用vim编辑文件：\n\n- **命令：vim 文件名** \n\n- 编辑文件，文件存在则直接编辑，不存在，则会创建文件，然后编辑文件\n\n<br/>\n\n### 3、关于 vim的模式切换：\n\n### (1) 插入编辑模式：按Insert 键\n\n- 可以输入、删除、修改内容\n\n  > 使用鼠标的右键->粘贴功能，会导致正常状态自动切换到插入状态。\n\n### (2) 正常/命令模式：按Esc 键\n\n- 在任何状态模式，只要按Esc 键，都可以退回到正常模式\n\n<br/>\n\n### 4、vim 保存内容并退出：\n\n- 在正常状态模式下，shift + zz (按住shift，点击两次z)，实现保存并退出操作\n\n- 或者在命令模式下，按w，进入命令模式，然后输入 :wq 回车，即可实现保存并退出操作\n\n> 保存并退出：若卡了，就再次切换模式为插入模式，然后再切回来正常模式，shift+zz\n\n\n<br/><br/>\n\n\n### 5、vim的光标位置的移动（在正常模式下）：\n\n#### (1) 从当前位置向下跳转多少行，直接输入行数，然后输入回车\n\n● 直接输入回车，则是往下跳转一行\n\n- 例如，输入15回车，会从当前位置往下跳转15行。\n\n#### (2) 从当前位置向右跳转多少列，直接输入列数，然后输入空格\n\n● 直接输入空格，则是往右跳转一列\n\n- 例如，输入10空格，会从当前位置往右跳转10列。\n\n### (3) 跳转到段首/段尾：\n\n● 直接跳转到段首：输入gg\n\n● 直接跳转到段尾：输入G\n\n\n<br/><br/>\n\n\n### 6、查找内容/搜索功能（在正常模式下）：\n\n#### (1) `从当前位置向下查找：/    [/关键词，然后回车]`\n\n#### (2) 从当前位置向上查找：？   [？关键词，然后回车]\n\n● **查找下一个位置：n**\n\n● **查找上一个位置：N**\n\n\n<br/>\n\n\n### 7、vim 退出高亮模式（在底线命令模式下）：\n\n● **在正常模式，输入：切换到命令模式，然后在冒号的后边，接着输入 `noh`**\n\n\n\n\n<br/><br/><br/><br/>\n\n\n\n\n## 十、防火墙\n\n### 1、防火墙是什么和分类：\n\n#### ■ 防火墙是什么？\n\n所谓\"防火墙\"是指一种**将内网和公网(公众访问网)分开的方法**，它实际上是一种建立在现代**通信网络技术和信息安全**技术基础上的应用性**安全技术，隔离技术。**\n\n<br/>\n\n#### ■ 防火墙分类？\n\n- 硬件防火墙\n- 软件防火墙\n\n\n<br/>\n\n\n### 2、防火墙的作用：\n\n**`对于公司，最重要的功能--安全：保护(局域网)、过滤、防止恶意攻击；然后还可以配置地址转换功能，让内部ip无法访问互联网，节约ip成本。`**\n\n\n<br/>\n\n\n### 3、Linux 软件防火墙iptables 或 FirewallD\n\nIptables：**是centos6自带的防火墙工具**，对服务器自身、网络通信流量进行控制，用于过滤数据包，属于网络层防火墙。\n\nFirewallD：**是centos7自带的防火墙工具**，但是也同样支持iptables。能够允许哪些服务可用，哪些端口可用，属于更高一层的防火墙。\n\n> **iptables 与 firewalld 都不是真正的防火墙， 它们都只是用来定义防火墙策略的防火墙管理工具。**\n\n\n<br/>\n\n\n### 4、centos7的FirewallD\n\n~~~bash\n● 查看防火墙的状态：systemctl status firewalld\n\n● 开启防火墙: systemctl start firewalld\n\n● 关闭防火墙：systemctl stop firewalld\n\n● 查看防火墙规则：\n# 查看默认的zone=public所有信息：firewall-cmd --list-all\n# 查看zone=public的端口的信息：firewall-cmd --list-ports --zone=public\n\n● 开启端口6379: firewall-cmd --zone=public --add-port=6379/tcp --permanent\n\n● 关闭端口6379: firewall-cmd --zone=public --remove-port=6379/tcp --permanent\n\n● 重新加载：开启端口/关闭端口，必须重新加载或重启服务器才生效，重新加载命令： firewall-cmd --reload\n\n■ 命令含义：\n--zone #作用域\n--add-port # 添加端口，格式为：端口/通讯协议\n--permanent #永久生效，没有此参数重启后会失效\n~~~\n\n\n\n<br/><br/>\n\n**如果本文对你有帮助的话记得给一乐点个赞哦，感谢！**\n', '<br/>\n<blockquote>\n<p><strong>温馨提示：重点掌握的前面都标注了 ☆</strong></p>\n</blockquote>\n<br/>\n<h2><a id=\"Linux__6\"></a>一、Linux 是什么？</h2>\n<h3><a id=\"Linux__8\"></a>Linux 是一个操作系统。</h3>\n<p><img src=\"https://files.mdnice.com/user/18969/755baa70-2234-4d43-81ad-1b8b93e26485.png\" alt=\"\" /></p>\n<br/>\n<blockquote>\n<p><strong>我们的 Linux 主要是系统调用和内核那两层。</strong></p>\n<p>当然直观地看，我们使用的操作系统还包含一些在其上运行的应用程序，比如文本编辑器、浏览器、电子邮件等。</p>\n<p><strong>Linux 本身只是操作系统的内核。</strong></p>\n<p>内核是使其它程序能够运行的基础。它实现了多任务和硬件管理，用户或者系统管理员交互运行的所有程序实际上都运行在内核之上。</p>\n<p>其中有些程序是必需的，比如说，<strong>命令行解释器（shell），它用于用户交互和编写 shell 脚本。</strong></p>\n<p>Linux 是一套<strong>免费使用</strong>和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的<strong>多用户、多任务、支持多线程和多 CPU 的操作系统。</strong></p>\n<p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>\n<hr />\n<p><strong>Linux之父</strong> Linus 没有自己去开发这些应用程序，而是使用已有的自由软件。这减少了搭建开发环境所需花费的工作量。实际上，他经常改写内核，使得那些程序能够更容易地在 Linux 上运行。许多重要的软件，包括 C 编译器，都来自于自由软件基金 GNU 项目。GNU 项目开始于 1984 年，目的是为了开发一个完全类似于 UNIX 的免费操作系统。为了表扬 GNU 对 Linux 的贡献，许多人把 Linux 称为 <strong>GNU/Linux</strong>（GNU 有自己的内核）。</p>\n<p><strong>Linux之父</strong> 芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写linux的内核。他还独自开发了git版本控制工具。</p>\n</blockquote>\n<p><br/><br/><br/><br/></p>\n<h2><a id=\"Unix__Linux__50\"></a>二、Unix 和 Linux 的关系：</h2>\n<h4><a id=\"LinuxUNIXLinuxUnix_52\"></a>Linux产品成功的模仿了UNIX系统和功能。Linux是免费的，Unix是收费的。</h4>\n<ul>\n<li>\n<p>UNIX是商业操作系统，贵的吓人，一般小公司用不起的。</p>\n</li>\n<li>\n<p>Linux是Linus模仿UNIX写出来的一个开源操作系统，是免费的。不过为linux开发的很多商业组件是要收费的，而且服务也是收费的。</p>\n</li>\n</ul>\n<p><br/><br/><br/><br/></p>\n<h2><a id=\"shell_bash__66\"></a>三、shell（壳）和 bash 的关系：</h2>\n<h3><a id=\"1Shell__DOS__command_cmdexe__Shell__68\"></a>1、Shell 是指&quot;提供给使用者使用界面&quot;的软件（<code>命令解析器</code>），类似于 DOS 下的 command（命令行）和后来的 cmd.exe 。它之所以被称作 Shell 是因为它隐藏了操作系统底层的细节。</h3>\n<blockquote>\n<p>有壳就有核，这里的核就是指 UNIX/Linux 内核，Shell 是指&quot;提供给使用者使用界面&quot;的软件（命令解析器)</p>\n<p><strong><code>shell 既是用户交互的界面，也是控制系统的脚本语言。</code></strong></p>\n<p>**Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。**Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>\n<p><strong>Shell 既是一种命令语言，又是一种程序设计语言。</strong></p>\n<p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p>\n</blockquote>\n<br/>\n<h4><a id=\"_Shell_shell_script_82\"></a>■ Shell 脚本(shell script):</h4>\n<p>简单说，shell script是利用shell的功能所写的一个程序，这个程序是使用<strong>纯文本文件，将一些shell的语法与指令写在里面</strong>，然后用正规表示法，管道命令以及数据流重导向等功能，以达到我们所想要的处理目的。</p>\n<ul>\n<li>习惯叫法上，shell 脚本通常只叫shell。但是你需要明白shell和shell脚本的区别，<strong>一个是命令解析器，一个是编写了shell指令的文本文件。</strong></li>\n</ul>\n<br/>\n<h4><a id=\"_Shell__90\"></a>■ Shell 环境:</h4>\n<ul>\n<li>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</li>\n</ul>\n<p><strong>Linux 的 Shell 种类众多，常见的有：</strong></p>\n<ul>\n<li><strong><code>Bourne Shell（/usr/bin/sh或/bin/sh）</code></strong></li>\n<li>Bourne Again Shell（/bin/bash）</li>\n<li>C Shell（/usr/bin/csh）</li>\n<li>K Shell（/usr/bin/ksh）</li>\n<li>Shell for Root（/sbin/sh）</li>\n</ul>\n<br/>\n<h3><a id=\"2bash_106\"></a>2、bash：</h3>\n<blockquote>\n<p>Bash，也就是 Bourne Again Shell，由于**<code>易用和免费</code>**，Bash 在日常工作中被广泛使用。</p>\n<p>同时，<strong>Bash 也是大多数 Linux 系统默认的 Shell。</strong></p>\n</blockquote>\n<p><br/><br/><br/><br/></p>\n<h2><a id=\"_Linux__120\"></a>☆ 四、Linux 目录结构介绍</h2>\n<p><img src=\"https://niu.yilele.site/3091fd83-ec35-4e0d-bbf9-692a3a06dd81.png\" alt=\"9ab329af9f4d486ea1dab7da3d409908.png\" /></p>\n<p>/bin： bin是Binary的缩写, 这个目录存放着最经常使用的命令。</p>\n<p>/boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。（不 要动）</p>\n<p>/dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问 文件的方式是相同的。</p>\n<p><strong><code>/etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</code></strong> [<code>管理配置</code>]</p>\n<p><strong><code>/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</code></strong> [<code>默认/home 是空的，需要自己手动创建一个目录，在/home目录下创建的目录相当于c盘Users下的目录</code>]</p>\n<p>/lib： 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。 （不要动）</p>\n<p>/lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（存放 突然关机的一些文件）</p>\n<p>/media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备 挂载到这个目录下。</p>\n<p>/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上， 然后进入该目录就可以查看光驱里的内容了。（我们后面会把一些本地文件挂载在这个目录下）</p>\n<p>**<code>/opt：这是给主机额外安装软件所摆放的目录。</code>**比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 [<code>安装程序</code>]</p>\n<p>/proc： 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。（不用管）</p>\n<p><strong>/root：该目录为系统管理员，也称作超级权限者的用户主目录。</strong> [<code>系统管理员</code>]</p>\n<p><strong>/sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</strong> [<code>超级用户管理的程序</code>]</p>\n<p><strong>/srv：该目录存放一些服务启动之后需要提取的数据。</strong> [<code>服务器启动提取的数据</code>]</p>\n<p><strong>/sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</strong> [<code>文件系统</code>]</p>\n<p><strong>/tmp：这个目录是用来存放一些临时文件的。用完即丢的文件，可以放在这个目录下，安装包！</strong></p>\n<p><strong><code>/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows 下的program files目录。</code></strong> [<code>程序目录</code>]</p>\n<p><strong><code>/usr/bin： 系统用户使用的应用程序。</code></strong>  [<code>应用程序</code>]</p>\n<p><strong><code>/usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。</code></strong>  [<code>高级程序、守护程序</code>]</p>\n<p><strong>/usr/src： 内核源代码默认的放置目录。</strong></p>\n<p><strong>/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。<code>包括各种日志文件</code>。</strong>  [<code>修改的目录、日志</code>]</p>\n<p>/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被 删掉或清除。</p>\n<p><strong>/www：存放服务器网站相关的资源，环境，网站的项目。</strong></p>\n<p><br/><br/><br/><br/></p>\n<h2><a id=\"_Linux_180\"></a>☆ 五、Linux系统分为两种：</h2>\n<h3><a id=\"1RedHatRedhatCentosFedora_182\"></a>1、<strong>RedHat系列</strong>：Redhat、Centos、Fedora等</h3>\n<h3><a id=\"2DebianDebianUbuntu_184\"></a>2、<strong>Debian系列</strong>：Debian、Ubuntu等</h3>\n<ul>\n<li>\n<p><strong><code>RedHat系列的包管理工具是yum</code></strong></p>\n</li>\n<li>\n<p><strong><code>Debian系列的包管理工具是apt-get</code></strong></p>\n</li>\n</ul>\n<blockquote>\n<p>一般你所见到的是Linux，比如 <strong>Ubuntu</strong>、RedHat、<strong>CentOS</strong>、Debian、Fedora、SuSE、OpenSUSE、 Arch Linux、SolusOS等，<strong><code>他们都是Linux不同的发行版本。</code></strong></p>\n</blockquote>\n<p><br/><br/><br/><br/></p>\n<h2><a id=\"__200\"></a>☆ 六、查看系统版本信息</h2>\n<p>1、步骤1：<code>cat /etc/os-release</code></p>\n<p>2、步骤2：分别对于redhat、debain版本：</p>\n<ul>\n<li>\n<p>查看 redhat 版本命令:</p>\n<pre><code class=\"lang-bash\">cat /etc/redhat-release\n</code></pre>\n</li>\n<li>\n<p>查看 debain 版本命令：</p>\n<pre><code class=\"lang-bash\">cat /etc/debian_version\n</code></pre>\n</li>\n</ul>\n<p><br/><br/><br/><br/></p>\n<h2><a id=\"rpm_226\"></a>七、后缀是.rpm</h2>\n<blockquote>\n<p>1、<strong>rpm 是Linux软件扩展名，是Red Hat Linux提供的一种包封装格式</strong>。现在许多Linux发行版本都使用。</p>\n<p>2、后缀为.deb是Debain Linux提供的一种包封装格式。</p>\n<p>3、后缀为.tar.gz、tar.Z、tar.bz2或.tgz是使用Unix系统打包工具tar打包的。</p>\n<p>4、后缀为.bin 的一般是一些商业软件</p>\n<ul>\n<li>通过扩展名可以了解软件格式，进而了解软件安装。</li>\n</ul>\n</blockquote>\n<h3><a id=\"1_RPM_238\"></a>1、 RPM软件包管理器（红帽软件包管理器）</h3>\n<p>与直接从源代码安装相比，软件包管理易于安装和卸载；易于更新已安装的软件包；易于保护配置文件；易于跟踪已安装文件。</p>\n<p>几乎所有的Linux发行版本都使用某种形式的软件包管理安装、更新和卸载软件。</p>\n<br/>\n<h3><a id=\"2rpm__246\"></a>2、rpm 命令：</h3>\n<p>rpm 最初是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，现在许多Linux发行版本都使用。</p>\n<blockquote>\n<p>rpm的命令是以 rpm 开头的！</p>\n</blockquote>\n<p>□ <strong>使用举例：</strong></p>\n<ul>\n<li>查询安装的yum依赖包：rpm -qa|grep yum</li>\n<li>查看epel依赖包：rpm -qa|grep epel</li>\n</ul>\n<br/>\n<h3><a id=\"3rpm___259\"></a>3、命令语法：rpm [选项] [参数]</h3>\n<ul>\n<li>\n<h4><a id=\"RPM__261\"></a>RPM 命令主要参数：</h4>\n<p>-a 查询所有套件</p>\n<p>-q 使用询问模式，当遇到任何问题时，rpm指令会先询问用户</p>\n<p>-l 显示套件的文件列表</p>\n<p>-i 安装软件<br />\n-t 测试安装，不是真的安装</p>\n<p>-p 显示安装进度<br />\n-f 忽略任何错误<br />\n-U 升级安装<br />\n-v 检测套件是否正确安装</p>\n</li>\n</ul>\n<p><br/><br/><br/><br/></p>\n<h2><a id=\"_yum__apt_283\"></a>☆ 八、yum 或者 apt</h2>\n<h3><a id=\"_1yum__apt__285\"></a>☆ 1、yum 或 apt 的关系:</h3>\n<h4><a id=\"RedHat_yum_287\"></a>RedHat系列的包管理工具是 <strong>yum</strong></h4>\n<h4><a id=\"Debian_aptget_289\"></a>Debian系列的包管理工具是 <strong>apt-get</strong></h4>\n<br/>\n<h3><a id=\"2yum__293\"></a>2、yum 详细介绍：</h3>\n<h4><a id=\"1_yum__295\"></a>(1) yum 是什么？</h4>\n<p>Yellow dog Updater Modified的简称，起初是由yellow dog这一发行版的开发者研发，用python写成，最初叫做yup(yellow dog updater)，</p>\n<p>后来被改名为 yum。</p>\n<h4><a id=\"2_yum__301\"></a>(2) <strong>yum 特点</strong></h4>\n<ul>\n<li><strong>可以同时配置多个资源库(Repository)</strong></li>\n<li><strong><code>简洁的配置文件(/etc/yum.conf，/etc/yum.repos.d 下的文件)</code></strong></li>\n<li>自动解决增加或删除rpm包时遇到的倚赖性问题</li>\n<li>使用方便</li>\n<li>保持与RPM数据库的一致性</li>\n</ul>\n<h4><a id=\"3_yum__309\"></a>(3) yum 的作用</h4>\n<ul>\n<li>更加方便地 <strong>添加/删除/更新RPM包</strong>.</li>\n<li><strong>自动解决包的倚赖性问题</strong>.</li>\n<li>更加方便地管理大量系统的更新问题.、</li>\n</ul>\n<br/>\n<h3><a id=\"3_yum__319\"></a>3、 yum 的核心—仓库</h3>\n<p>yum的关键之处是要有可靠的repository(软件仓库)</p>\n<p><strong>软件仓库</strong>，它可以是http或ftp站点， 也可以是本地软件池，<strong>但必须包含rpm的header</strong>，</p>\n<p><code>header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等</code>。</p>\n<p>正是收集了这些 header并加以分析，才能自动化地完成余下的任务。</p>\n<br/>\n<h3><a id=\"4yum_yumconf__CentOSBaserepo_333\"></a>4、yum 配置文件介绍—yum.conf 和 CentOS-Base.repo：</h3>\n<h4><a id=\"1_yum__etcyumconf_335\"></a>(1) yum 主配置文件 /etc/yum.conf</h4>\n<pre><code class=\"lang-bash\">[root@iZwz9535z41cmgcpkm7i81Z etc]# cat yum.conf\n[main]\ncachedir=/var/cache/yum/$basearch/$releasever  # yum缓存的目录，yum在此存储下载的rpm包和数据库，一般是/var/cache/yum\nkeepcache=0    # 是否保存缓存，为0，让缓存一直为空\ndebuglevel=2   # debuglevel：除错级别，0-10,默认是2\nlogfile=/var/log/yum.log    # yum的日志文件，默认是/var/log/yum.log\nexactarch=1    #  准确匹配，精确匹配硬件平台，只有完全相同才更新。有两个选项1和0,代表是否只升级和你安装软件包cpu体系一致的包\nobsoletes=1	   # 当使用升级模式时，一些包没有用了，可以删除（取值1）\ngpgcheck=1     # 安装时是否检查RPM包的PGP签名\nplugins=1      # Yum插件是否可用\ninstallonly_limit=5   # 安装限制           # bugtracker_url：bug 跟踪路径\nbugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?   category=yum   # 目录\ndistroverpkg=centos-release   # 定从哪里获取系统版本相关的信息\n\n\n#  This is the default, if you make this bigger yum won\'t see if the metadata\n# is newer on the remote and so you\'ll &quot;gain&quot; the bandwidth of not having to\n# download the new metadata and &quot;pay&quot; for it by yum not having correct\n# information.\n#  It is esp. important, to have correct metadata, for distributions like\n# Fedora which don\'t keep old packages around. If you don\'t like this checking\n# interupting your command line usage, it\'s much better to have something\n# manually check the metadata once an hour (yum-updatesd will do this).\n# metadata_expire=90m\n\n# PUT YOUR REPOS HERE OR IN separate files named file.repo\n# in /etc/yum.repos.d\n</code></pre>\n<br/>\n<h4><a id=\"2_yum_etcyumreposdCentOSBaserepo_369\"></a>(2) yum源的默认配置文件 /etc/yum.repos.d/CentOS-Base.repo</h4>\n<ul>\n<li>\n<p>mirrorlist   镜像站点</p>\n</li>\n<li>\n<p>baseurl      仓库路径(固定路径)</p>\n</li>\n<li>\n<p>enabled=1    是否打开仓库，为1则是打开仓库，为0则是关闭仓库</p>\n</li>\n<li>\n<p>gpgcheck     是否需要查阅RPM文件内数字证书，0表示不检查，1表示检查 (GPG是加密和数字签名的免费工具)</p>\n</li>\n<li>\n<p>gpgkey       数字证书公钥文件所在位置，使用默认值</p>\n<pre><code class=\"lang-bash\">[root@iZwz9535z41cmgcpkm7i81Z yum.repos.d]# cat CentOS-Base.repo\n[base]\nname=CentOS-$releasever - Base\nfailovermethod=priority\nbaseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/\ngpgcheck=1\ngpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7\n \n#released updates \n[updates]\nname=CentOS-$releasever - Updates\nfailovermethod=priority\nbaseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/updates/$basearch/\ngpgcheck=1\ngpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7\n \n#additional packages that may be useful\n[extras]\nname=CentOS-$releasever - Extras\nfailovermethod=priority\nbaseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/extras/$basearch/\ngpgcheck=1\ngpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7\n \n#additional packages that extend functionality of existing packages\n[centosplus]\nname=CentOS-$releasever - Plus\nfailovermethod=priority\nbaseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/\ngpgcheck=1\nenabled=0\ngpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7\n \n#contrib - packages by Centos Users\n[contrib]\nname=CentOS-$releasever - Contrib\nfailovermethod=priority\nbaseurl=http://mirrors.cloud.aliyuncs.com/centos/$releasever/contrib/$basearch/\ngpgcheck=1\nenabled=0\ngpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7\n</code></pre>\n</li>\n</ul>\n <br/> \n<h3><a id=\"_5yum__426\"></a>☆ 5、yum 包管理工具</h3>\n<ul>\n<li>作用：<strong>添加/删除/更新RPM包</strong>.<strong>自动解决包的倚赖性问题</strong>.</li>\n<li>核心是repository 仓库</li>\n</ul>\n<h5><a id=\"_mavennpm_431\"></a>■ <code>和maven、npm一样，凡是看到，涉及到自动管理包，必须考虑的是下载速度的提速。</code></h5>\n<p>■ 配置一下阿里云镜像加速：</p>\n<h4><a id=\"1__debain_435\"></a>(1) 系统是 debain：</h4>\n<ul>\n<li>\n<p>记得先备份，可以选择创建一个文件夹，然后拷贝一份放进去</p>\n<pre><code class=\"lang-bash\">root@f1cfb81dedfd:/etc/apt# mkdir cat sources.list.backup\nroot@f1cfb81dedfd:/etc/apt# cp sources.list ./sources.list.backup\nroot@f1cfb81dedfd:/etc/apt/sources.list.backup# cd ../\n</code></pre>\n</li>\n<li>\n<p>使用命令 echo 覆盖+追加方式 [若是没有vim工具，则使用bash命令]</p>\n<pre><code class=\"lang-bash\">deb https://mirrors.aliyun.com/debian bullseye main\ndeb https://mirrors.aliyun.com/debian-security bullseye-security main\ndeb https://mirrors.aliyun.com/debian bullseye-updates main\n</code></pre>\n</li>\n<li>\n<p>执行一下更新命令：</p>\n<pre><code class=\"lang-bash\"> apt-get update -y\n</code></pre>\n</li>\n</ul>\n<br/>\n<h4><a id=\"2__redhat_461\"></a>(2) 系统是 redhat：</h4>\n<ul>\n<li>\n<p>记得先备份，可以选择创建一个文件夹，然后拷贝一份放进去</p>\n<pre><code class=\"lang-bash\">root@f1cfb81dedfd:/etc/yum.repos.d# mv /etc/yum.repos.d /etc/yum.repos.d.backup\nroot@f1cfb81dedfd:/etc/yum.repos.d# \n</code></pre>\n</li>\n<li>\n<p>在阿里云镜像官网下载文件 CentOS-Base.repo [下载对应你的系统版本的Centos-Base.repo，下载的名字不是这个，可以自己改一下哦]</p>\n<ul>\n<li>地址：https://mirrors.aliyun.com/repo/</li>\n</ul>\n</li>\n<li>\n<p>使用工具xftp，删除掉原先的CentOS-Base.repo，然后将下载下来的CentOS-Base.repo，传输到/etc/yum.repos.d目录下</p>\n</li>\n</ul>\n<br/>  \n<h3><a id=\"_6yum_478\"></a>☆ 6、yum的常用命令：</h3>\n<blockquote>\n<p>参数 -y（当安装/卸载/更新过程提示选择全部为&quot;yes&quot;）</p>\n</blockquote>\n<ul>\n<li>\n<p>安装：yum install xxx</p>\n</li>\n<li>\n<p>删除：yum remove xxx</p>\n</li>\n<li>\n<p>升级: yum update xxx</p>\n<ul>\n<li>升级所有软件(相当于升级系统)：yum update</li>\n</ul>\n</li>\n<li>\n<p>查询：yum list 列出yum服务器上面所有的软件名称</p>\n<ul>\n<li>yum list h* #找出以h开头的软件名称</li>\n<li>yum list installed #查找所有已安装的列表</li>\n</ul>\n</li>\n<li>\n<p>清除缓存：</p>\n<ul>\n<li>yum clean packages 清除缓存目录下的软件包</li>\n<li>yum clean oldheaders 清除缓存目录下旧的 headers</li>\n<li>yum clean headers 清除缓存目录下的 headers</li>\n<li>yum all = yum clean packages + yum clean oldheaders  清除缓存目录下的软件包及旧的header</li>\n</ul>\n</li>\n<li>\n<p>生成缓存：yum makecache</p>\n</li>\n</ul>\n<br/>\n<h4><a id=\"_yumyum_499\"></a>■ yum源改变了(例如修改了yum的配置文件)，需要清除下数据再重新建立缓存</h4>\n<ul>\n<li>yum clean all # 清除一下之前的配置等数据</li>\n<li>yum makecache # 生成新的缓存</li>\n</ul>\n<p><br/><br/><br/><br/></p>\n<h2><a id=\"__vim__513\"></a>☆ 九、文本编译器 vim 常用操作：</h2>\n<h3><a id=\"1vim__515\"></a>1、vim 介绍：一个文本编辑器</h3>\n<p>vim 通过一些插件可以实现和IDE一样的功能！ Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程 序员中被广泛使用。</p>\n<h4><a id=\"_vim__vi__519\"></a>■ vim 和 vi 的关系：</h4>\n<p>简单理解，vim 是 vi 的升级版。</p>\n<br/>\n<h4><a id=\"___525\"></a>■ 关于 文本编辑器需要掌握：</h4>\n<p><strong><code>查看/查找内容，编辑内容，保存内容，光标位置的移动</code></strong></p>\n<blockquote>\n<h3><a id=\"_vim__529\"></a>● vim的常用模式有分为 命令模式(正常模式)，插入模式，底线命令模式。</h3>\n<ul>\n<li>正常模式/命令模式：主要用来浏览文本内容。一开始打开vim都是正常模式。<strong>按 Esc键 任何情况，都可以返回正常模式</strong>。</li>\n<li>底线命令模式：<strong>在正常模式下，按冒号：即可切换到底线命令模式。</strong></li>\n<li>插入编辑模式：用来向文本中添加内容的。在正常模式下，<strong>按 Insert 键，即可进入插入编辑模式</strong>。</li>\n<li>注意：退出vim，如果使用vim修改任何文本后需要保存并退出，<strong>需要在正常/命令模式下（Esc键），输入 shift+zz</strong></li>\n</ul>\n<p>（或者在正常模式，进入底线命令模式(输入:)后，然后在冒号后面输入wq，回车，保存并退出vim。）</p>\n</blockquote>\n<br/>\n<h3><a id=\"2vim_540\"></a>2、使用vim编辑文件：</h3>\n<ul>\n<li>\n<p><strong>命令：vim 文件名</strong></p>\n</li>\n<li>\n<p>编辑文件，文件存在则直接编辑，不存在，则会创建文件，然后编辑文件</p>\n</li>\n</ul>\n<br/>\n<h3><a id=\"3_vim_548\"></a>3、关于 vim的模式切换：</h3>\n<h3><a id=\"1_Insert__550\"></a>(1) 插入编辑模式：按Insert 键</h3>\n<ul>\n<li>\n<p>可以输入、删除、修改内容</p>\n<blockquote>\n<p>使用鼠标的右键-&gt;粘贴功能，会导致正常状态自动切换到插入状态。</p>\n</blockquote>\n</li>\n</ul>\n<h3><a id=\"2_Esc__556\"></a>(2) 正常/命令模式：按Esc 键</h3>\n<ul>\n<li>在任何状态模式，只要按Esc 键，都可以退回到正常模式</li>\n</ul>\n<br/>\n<h3><a id=\"4vim__562\"></a>4、vim 保存内容并退出：</h3>\n<ul>\n<li>\n<p>在正常状态模式下，shift + zz (按住shift，点击两次z)，实现保存并退出操作</p>\n</li>\n<li>\n<p>或者在命令模式下，按w，进入命令模式，然后输入 :wq 回车，即可实现保存并退出操作</p>\n</li>\n</ul>\n<blockquote>\n<p>保存并退出：若卡了，就再次切换模式为插入模式，然后再切回来正常模式，shift+zz</p>\n</blockquote>\n<p><br/><br/></p>\n<h3><a id=\"5vim_574\"></a>5、vim的光标位置的移动（在正常模式下）：</h3>\n<h4><a id=\"1__576\"></a>(1) 从当前位置向下跳转多少行，直接输入行数，然后输入回车</h4>\n<p>● 直接输入回车，则是往下跳转一行</p>\n<ul>\n<li>例如，输入15回车，会从当前位置往下跳转15行。</li>\n</ul>\n<h4><a id=\"2__582\"></a>(2) 从当前位置向右跳转多少列，直接输入列数，然后输入空格</h4>\n<p>● 直接输入空格，则是往右跳转一列</p>\n<ul>\n<li>例如，输入10空格，会从当前位置往右跳转10列。</li>\n</ul>\n<h3><a id=\"3__588\"></a>(3) 跳转到段首/段尾：</h3>\n<p>● 直接跳转到段首：输入gg</p>\n<p>● 直接跳转到段尾：输入G</p>\n<p><br/><br/></p>\n<h3><a id=\"6_598\"></a>6、查找内容/搜索功能（在正常模式下）：</h3>\n<h4><a id=\"1______600\"></a>(1) <code>从当前位置向下查找：/    [/关键词，然后回车]</code></h4>\n<h4><a id=\"2_____602\"></a>(2) 从当前位置向上查找：？   [？关键词，然后回车]</h4>\n<p>● <strong>查找下一个位置：n</strong></p>\n<p>● <strong>查找上一个位置：N</strong></p>\n<br/>\n<h3><a id=\"7vim__612\"></a>7、vim 退出高亮模式（在底线命令模式下）：</h3>\n<p>● <strong>在正常模式，输入：切换到命令模式，然后在冒号的后边，接着输入 <code>noh</code></strong></p>\n<p><br/><br/><br/><br/></p>\n<h2><a id=\"_624\"></a>十、防火墙</h2>\n<h3><a id=\"1_626\"></a>1、防火墙是什么和分类：</h3>\n<h4><a id=\"__628\"></a>■ 防火墙是什么？</h4>\n<p>所谓&quot;防火墙&quot;是指一种<strong>将内网和公网(公众访问网)分开的方法</strong>，它实际上是一种建立在现代<strong>通信网络技术和信息安全</strong>技术基础上的应用性<strong>安全技术，隔离技术。</strong></p>\n<br/>\n<h4><a id=\"__634\"></a>■ 防火墙分类？</h4>\n<ul>\n<li>硬件防火墙</li>\n<li>软件防火墙</li>\n</ul>\n<br/>\n<h3><a id=\"2_643\"></a>2、防火墙的作用：</h3>\n<p><strong><code>对于公司，最重要的功能--安全：保护(局域网)、过滤、防止恶意攻击；然后还可以配置地址转换功能，让内部ip无法访问互联网，节约ip成本。</code></strong></p>\n<br/>\n<h3><a id=\"3Linux_iptables__FirewallD_651\"></a>3、Linux 软件防火墙iptables 或 FirewallD</h3>\n<p>Iptables：<strong>是centos6自带的防火墙工具</strong>，对服务器自身、网络通信流量进行控制，用于过滤数据包，属于网络层防火墙。</p>\n<p>FirewallD：<strong>是centos7自带的防火墙工具</strong>，但是也同样支持iptables。能够允许哪些服务可用，哪些端口可用，属于更高一层的防火墙。</p>\n<blockquote>\n<p><strong>iptables 与 firewalld 都不是真正的防火墙， 它们都只是用来定义防火墙策略的防火墙管理工具。</strong></p>\n</blockquote>\n<br/>\n<h3><a id=\"4centos7FirewallD_663\"></a>4、centos7的FirewallD</h3>\n<pre><code class=\"lang-bash\">● 查看防火墙的状态：systemctl status firewalld\n\n● 开启防火墙: systemctl start firewalld\n\n● 关闭防火墙：systemctl stop firewalld\n\n● 查看防火墙规则：\n# 查看默认的zone=public所有信息：firewall-cmd --list-all\n# 查看zone=public的端口的信息：firewall-cmd --list-ports --zone=public\n\n● 开启端口6379: firewall-cmd --zone=public --add-port=6379/tcp --permanent\n\n● 关闭端口6379: firewall-cmd --zone=public --remove-port=6379/tcp --permanent\n\n● 重新加载：开启端口/关闭端口，必须重新加载或重启服务器才生效，重新加载命令： firewall-cmd --reload\n\n■ 命令含义：\n--zone #作用域\n--add-port # 添加端口，格式为：端口/通讯协议\n--permanent #永久生效，没有此参数重启后会失效\n</code></pre>\n<p><br/><br/></p>\n<p><strong>如果本文对你有帮助的话记得给一乐点个赞哦，感谢！</strong></p>\n', 1548691213995524097);
INSERT INTO `ys_article_body` VALUES (1548692795306852355, '<br/>\n\n## 一、SpringBoot微服务打包成Docker镜像\n\n### 1、构建springboot项目\n\n- 编译器内测试一下项目是否可以正常启动\n\n### 2、打包应用\n\n- 通过cmd执行java -jar命令，测试打包的jar包能否正常执行\n- 有了jar包，就需要构建成dockerfile，直接创建一个命名为Dockerfile的文件，书写命令\n  - 也可以在idea工具安装插件Docker(用得不多)\n\n### 3、编写dockerfile\n\n~~~bash\nFROM java:8\n\nCOPY *.jar /app.jar   # 把当前所有的jar包都拷贝到最后生成的应用app项目目录下\n\nCMD [\"--server.port=8080\"]\n\nEXPOSE 8080\n\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\n~~~\n\n### 4、构建镜像\n\n~~~\n[root@iZwz9535z41cmgcpkm7i81Z idea]# pwd\n/home/idea\n[root@iZwz9535z41cmgcpkm7i81Z idea]# ls\n[root@iZwz9535z41cmgcpkm7i81Z idea]# ls\nDockerfile  testdocker-1.0.0.jar\n[root@iZwz9535z41cmgcpkm7i81Z idea]# docker build -t shan666 .\n\n[root@iZwz9535z41cmgcpkm7i81Z idea]# docker images\nREPOSITORY   TAG                IMAGE ID       CREATED         SIZE\nshan666      latest             3de56aa20b0a   6 seconds ago   660MB\nnginx        latest             605c77e624dd   3 months ago    141MB\ntomcat       9.0                b8e65a4d736d   4 months ago    680MB\ncentos       latest             5d0da3dc9764   7 months ago    231MB\nredis        5.0.9-alpine3.11   3661c84ee9d0   2 years ago     29.8MB\njava         8                  d23bdf5b1b1b   5 years ago     643MB\n\n\n[root@iZwz9535z41cmgcpkm7i81Z idea]# docker run -d -P --name shan-springboot-web shan666\n84d2498a5eec5bcd3f60c915f8cf5d5fa5b8e5dfab1c179c30b3efc4ec68052e\n\n[root@iZwz9535z41cmgcpkm7i81Z idea]# docker ps\nCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                     NAMES\n84d2498a5eec   shan666   \"java -jar /app.jar …\"   5 seconds ago   Up 3 seconds   0.0.0.0:49160->8080/tcp   shan-springboot-web\n\n\n[root@iZwz9535z41cmgcpkm7i81Z idea]# curl localhost:49160/\n{\"timestamp\":\"2022-04-28T03:16:51.901+00:00\",\"status\":404,\"error\":\"Not Found\",\"message\":\"\",\"path\":\"/\"}[root@iZwz9535z41cmgcpkm7i81Z idea]# curl localhost:49160/hello\nhello,shan[root@iZwz9535z41cmgcpkm7i81Z idea]# \n~~~\n\n- 以后，我们使用了Docker 之后，给别人交付的就是一个镜像即可！\n\n\n\n### 5、发布运行\n', '<br/>\n<h2><a id=\"SpringBootDocker_2\"></a>一、SpringBoot微服务打包成Docker镜像</h2>\n<h3><a id=\"1springboot_4\"></a>1、构建springboot项目</h3>\n<ul>\n<li>编译器内测试一下项目是否可以正常启动</li>\n</ul>\n<h3><a id=\"2_8\"></a>2、打包应用</h3>\n<ul>\n<li>通过cmd执行java -jar命令，测试打包的jar包能否正常执行</li>\n<li>有了jar包，就需要构建成dockerfile，直接创建一个命名为Dockerfile的文件，书写命令\n<ul>\n<li>也可以在idea工具安装插件Docker(用得不多)</li>\n</ul>\n</li>\n</ul>\n<h3><a id=\"3dockerfile_14\"></a>3、编写dockerfile</h3>\n<pre><code class=\"lang-bash\">FROM java:8\n\nCOPY *.jar /app.jar   # 把当前所有的jar包都拷贝到最后生成的应用app项目目录下\n\nCMD [&quot;--server.port=8080&quot;]\n\nEXPOSE 8080\n\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]\n</code></pre>\n<h3><a id=\"4_28\"></a>4、构建镜像</h3>\n<pre><code class=\"lang-\">[root@iZwz9535z41cmgcpkm7i81Z idea]# pwd\n/home/idea\n[root@iZwz9535z41cmgcpkm7i81Z idea]# ls\n[root@iZwz9535z41cmgcpkm7i81Z idea]# ls\nDockerfile  testdocker-1.0.0.jar\n[root@iZwz9535z41cmgcpkm7i81Z idea]# docker build -t shan666 .\n\n[root@iZwz9535z41cmgcpkm7i81Z idea]# docker images\nREPOSITORY   TAG                IMAGE ID       CREATED         SIZE\nshan666      latest             3de56aa20b0a   6 seconds ago   660MB\nnginx        latest             605c77e624dd   3 months ago    141MB\ntomcat       9.0                b8e65a4d736d   4 months ago    680MB\ncentos       latest             5d0da3dc9764   7 months ago    231MB\nredis        5.0.9-alpine3.11   3661c84ee9d0   2 years ago     29.8MB\njava         8                  d23bdf5b1b1b   5 years ago     643MB\n\n\n[root@iZwz9535z41cmgcpkm7i81Z idea]# docker run -d -P --name shan-springboot-web shan666\n84d2498a5eec5bcd3f60c915f8cf5d5fa5b8e5dfab1c179c30b3efc4ec68052e\n\n[root@iZwz9535z41cmgcpkm7i81Z idea]# docker ps\nCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                     NAMES\n84d2498a5eec   shan666   &quot;java -jar /app.jar …&quot;   5 seconds ago   Up 3 seconds   0.0.0.0:49160-&gt;8080/tcp   shan-springboot-web\n\n\n[root@iZwz9535z41cmgcpkm7i81Z idea]# curl localhost:49160/\n{&quot;timestamp&quot;:&quot;2022-04-28T03:16:51.901+00:00&quot;,&quot;status&quot;:404,&quot;error&quot;:&quot;Not Found&quot;,&quot;message&quot;:&quot;&quot;,&quot;path&quot;:&quot;/&quot;}[root@iZwz9535z41cmgcpkm7i81Z idea]# curl localhost:49160/hello\nhello,shan[root@iZwz9535z41cmgcpkm7i81Z idea]# \n</code></pre>\n<ul>\n<li>以后，我们使用了Docker 之后，给别人交付的就是一个镜像即可！</li>\n</ul>\n<h3><a id=\"5_65\"></a>5、发布运行</h3>\n', 1548692795239743489);
INSERT INTO `ys_article_body` VALUES (1548693912602329089, '<br/>\n\n---本文就以卸载nodepad++为例子：\n\n## 一、方法一：手动关闭进程\n\n### 1、在设置找到想要卸载的应用，选中卸载掉应用：\n\n![5b1922cae1074c2db3330e662375435c.png](https://niu.yilele.site/18a0ccd2-324e-4234-bab9-98c04f229916.png)\n\n\n### 2、想要删除被卸载应用的残留文件：\n\n\n![c365c94890e54d07984ec1fde885a762.png](https://niu.yilele.site/b9f2b134-f548-4ea3-b9b7-bd19a382217f.png)\n\n\n### 3、发现：操作无法完成，因为文件已经在Windows资源管理器中打开：\n\n![557d834a27e14c36ba7969cf4d14e11f.png](https://niu.yilele.site/2440b6ab-376f-446a-90e6-2ab717d47c38.png)\n\n\n### 4、发现在任务管理器[快捷键Esc+Shift+Ctr]没有找到和Notepad++相关的进程。\n\n\n### 5、进程已打开，在资源管理器却找不到：\n\n\n![3e2d60df4386405490e82a1b0b12d3e6.png](https://niu.yilele.site/55551c92-ae29-431f-b8e1-51c8fd251d4d.png)\n\n\n### 5、出现白屏的解决：\n\n\n![5195ae0b7f5d4064985d7a799a02a55c.png](https://niu.yilele.site/81bbf6d3-38e8-47cf-93c5-7f1774359f76.png)\n\n\n- 现在就可以正常删除啦~\n\n\n<br/><br/>\n\n## 二、方法二：重启自动关闭进程：\n### 1、先重启计算机\n### 2、正常删除', '<br/>\n<p>—本文就以卸载nodepad++为例子：</p>\n<h2><a id=\"_4\"></a>一、方法一：手动关闭进程</h2>\n<h3><a id=\"1_6\"></a>1、在设置找到想要卸载的应用，选中卸载掉应用：</h3>\n<p><img src=\"https://niu.yilele.site/18a0ccd2-324e-4234-bab9-98c04f229916.png\" alt=\"5b1922cae1074c2db3330e662375435c.png\" /></p>\n<h3><a id=\"2_11\"></a>2、想要删除被卸载应用的残留文件：</h3>\n<p><img src=\"https://niu.yilele.site/b9f2b134-f548-4ea3-b9b7-bd19a382217f.png\" alt=\"c365c94890e54d07984ec1fde885a762.png\" /></p>\n<h3><a id=\"3Windows_17\"></a>3、发现：操作无法完成，因为文件已经在Windows资源管理器中打开：</h3>\n<p><img src=\"https://niu.yilele.site/2440b6ab-376f-446a-90e6-2ab717d47c38.png\" alt=\"557d834a27e14c36ba7969cf4d14e11f.png\" /></p>\n<h3><a id=\"4EscShiftCtrNotepad_22\"></a>4、发现在任务管理器[快捷键Esc+Shift+Ctr]没有找到和Notepad++相关的进程。</h3>\n<h3><a id=\"5_25\"></a>5、进程已打开，在资源管理器却找不到：</h3>\n<p><img src=\"https://niu.yilele.site/55551c92-ae29-431f-b8e1-51c8fd251d4d.png\" alt=\"3e2d60df4386405490e82a1b0b12d3e6.png\" /></p>\n<h3><a id=\"5_31\"></a>5、出现白屏的解决：</h3>\n<p><img src=\"https://niu.yilele.site/81bbf6d3-38e8-47cf-93c5-7f1774359f76.png\" alt=\"5195ae0b7f5d4064985d7a799a02a55c.png\" /></p>\n<ul>\n<li>现在就可以正常删除啦~</li>\n</ul>\n<p><br/><br/></p>\n<h2><a id=\"_42\"></a>二、方法二：重启自动关闭进程：</h2>\n<h3><a id=\"1_43\"></a>1、先重启计算机</h3>\n<h3><a id=\"2_44\"></a>2、正常删除</h3>\n', 1548693912539414529);
INSERT INTO `ys_article_body` VALUES (1548695365416960005, '\n<br/>\n\n\n**✿ 贴心提示：文章内容比较长，但都是干货，请大家耐心看完。时间不够充裕的小伙伴，建议收藏，一定要耐心看完，保证对你有后续学习java有所帮助。**\n\n\n<br/>\n\n\n# 一、推荐背景介绍\n\n## （一）我是怎么学的？\n\n### ★ 非常普通的人，因为够普通，所以能给你提供更加真实的参考价值   \n\n<br/>\n\n​     简单介绍一下我自己， **`一所普通二本学校的普通学生`**，在高考失利后，灰心地刷视频选专业的时候，刷到一个视频，讲到“你不知道选什么专业，就选计算机”。然后在我那思想还停留在玩手机会耽误学习的爸爸的完美计划里，等到大学开学我才拿到笔记本电脑，然后**从打字开始学的**。由于我的学校很普通，**课堂就如大家所想的差不多，百度一下就有的ppt**，而思维转化比较慢的我， **`经历了免费群的每日作业打卡到花钱的线上培训`** ，当时是看到有活动半价入手了某机构的课程(2K),**现在的我，长大啦**~肯定不会傻傻地花钱买质量差不多的视频课程啦~\n\n<br/>\n\n​    普通的我，大学才有电脑；普通的我，操作电脑从打字开始；普通的我，曾为免费群打卡的奖励的赢得了一本书而开心好几天；普通的我，曾花钱买免费的质量差不的课程。现在的我，依然很普通，但是我在经过了前面的弯弯绕绕的我，判断意识得到了提示，**知道捂住原本就干瘪的钱包了~** 钱要花在刀刃上~\n\n\n![228244820220315224339108780565735.png](https://niu.yilele.site/d5705514-c1bb-4ae7-9d4b-f31d3b6fa666.png)\n\n\n<br/><br/>\n\n## (二) 我的学习方式\n\n### ★ 看书or看视频？    \n\n​    我本人是主要以看视频为主的，至于为什么看视频为主，看书看博客文章为辅的理由很简单。我本人呀，对不正经的各种小说着迷，甚至梦里还在上演着小说的情节，但是一旦看正而八经的学习材料的书籍，哎呀，我饿了，累了，休息一下……所以，对于你，我想问一句：**兄弟，你是爱看书的人吗？**看书还是看视频，看你哪一个能坚持的更久就行了呗，不用纠结啦~\n\n<br/>\n\n### ★ 分享我看过的视频和找学习资料的建议：\n\n■ **`后边我会给出观看学习java的路线，以及给出每个视频的推荐理由`，`放心，我会给出我最真实的感受`**，但是，**听课的人是你，希望你能试听一下**，结合自己的感受选择是否观看【 **`你的感受才是最重要的哦~`** 】\n\n<br/> \n\n- **C语言**：`这个可以跳过，不是java主路线，如果是大一新生的话，入门学校教的是C语言的话，可以看一下C语言视频`，我本来是看小甲鱼的C语言，但是看到一半，换成了老九学堂的C语言：\n\n  ▷ 推荐：[【零基础学C语言】老九零基础学习编程系列之一 老九学堂徐嵩老师主讲](https://www.bilibili.com/video/BV1av411z75R)\n\n  ▷ **推荐理由**：小甲鱼的视频，是大一的时候，上课要学谭浩强的《C程序设计》学得懵懵懂懂的，就问了同计算机系的一个师兄，“C语言视频推荐”，后边看到一半，实在是多次觉得比课本还不好懂，就自己动手去搜“零基础学编程C语言”，然后看到播放量比较高的视频---许嵩老师的C语言，**真心讲，这个C语言是他家粉丝的加群动力，讲得非常好懂，许嵩老师讲课段子是一段一段的，还融合了编程知识，非常有趣~**\n\n <br/> \n\n- **java 视频**【`花钱了`】: 视频加密了，分享了也观看不了~\n\n  ▷ 推荐(`同价位的免费替代`)：尚硅谷的宋红康老师的java\n\n  [尚硅谷Java入门视频教程(在线答疑+Java面试真题)](https://www.bilibili.com/video/BV1Kb411W75N)\n\n  ▷ **推荐理由**：java那个视频花了2K钱，在小鹅通看的，推荐宋红康老师的java视频，是因为看完付费视频后，对比了免费的视频的章节的目录，然后试听了一下，发现为什么我C语言记得去搜一下，还可能就是在免费群打卡，获得书本，加上活动半价，贪便宜，**忘记了自己的贫穷**~\n\n\n![228244820220315224325049888885481.png](https://niu.yilele.site/5e47fe2b-cb8d-4e4e-81fe-a5248e7fda55.png)\n\n\n<br/>\n\n- **mysql视频**：看过黑马的增强改查视频，也看过那个java付费视频配套送的mysql，还看过小码哥的mysql：\n\n   ▷ 推荐：[【小码哥教育】JAVA第二季MySQL基础（适合Java 0基础，Java初学入门，程序员，IT）](https://www.bilibili.com/video/BV1oK4y1e7Wq)\n\n   ▷ **推荐理由**：经过了对比，觉得这个讲得比较细，而且老师的声音也很温柔，良心推荐\n\n<br/>\n\n- **jdbc视频**：看过那个java付费视频配套送的jdbc，还看过小码哥的jdbc：\n\n  ▷ 推荐：[【小码哥教育】JAVA第三季JDBC](https://www.bilibili.com/video/BV1hv411v7jP)\n\n  ▷ **推荐理由**：jdbc的内容也可以划分于mysql，可以看和mysql视频的同一个老师\n\n<br/>\n\n- **javaWeb视频**：看过那个java付费视频配套送的javaWeb【**别问为啥送怎么多，问就是搞周年活动鸭**】，还看过狂神的javaWeb，还看过小码哥的javaWeb\n\n  ▷ 推荐：[Java大神之路（第四季 JavaWeb）](https://www.bilibili.com/video/BV1KW411S7xR)\n\n  ▷ **推荐理由**：本想推荐狂神的javaWeb的，不过狂神的javaWeb是前面一半的视频讲得很不错，可能是javaWeb视频时长不够长，到了后边视频，就觉得有点蒙圈了，我就换成小码哥的长视频javaWeb，觉得讲得更加仔细些，当然狂神的也不错哟~\n\n<br/>\n\n- **SSM 三大框架**：对比过狂神的ssm，后边还是选择了小码哥，因为习惯了任小龙老师温柔的声音，当然狂神的SSM框架在B站也是播放量非常高的，喜欢狂神的讲课方式，看狂神的视频也是不错的~\n\n  ▷ 推荐： **`观看顺序是MyBatis-> Spring5 -> SpringMVC`** \n\n  ▷ **推荐理由**：因为MyBatis是一个orm框架，用于跟数据库打交道，而咱前面有学过mysql和jdbc，所以建议先看MyBatis，而接着是Spring，因为Spring的内容涵盖了Spring DAO 和 Spring TX，这两部分也是与咱前面学过mysql和jdbc有关的，最后再看Spring的子集SpringMVC。\n\n  ◇ [Java大神之路（第七季  MyBatis完整版）](https://www.bilibili.com/video/BV1KW41127QV)\n\n  ◇ [Java大神之路（第八季 Spring5）](https://www.bilibili.com/video/BV1KW41127B1)\n\n  ◇ [Java大神之路（第九季 SpringMVC）](https://www.bilibili.com/video/BV1KW41127aN)\n\n<br/>\n\n- **SpringBoot 框架**：对比狂神和尚硅谷，选择了尚硅谷的SpirngBoot\n\n  ▷ 推荐：[尚硅谷雷神SpringBoot2零基础入门springboot全套完整版（spring boot2）](https://www.bilibili.com/video/BV19K4y1L7MT)\n\n  ▷ **推荐理由**：个人也比较喜欢雷神的讲课方式，之前也看过尚硅谷的js视频、Ajax视频，觉得尚硅谷家的视频也是非常良心，为啥每次拿狂神老师出来晾呢？只是狂神老师讲得也很不错，才每次有他的身影，**最后没有选择只是个人喜好啦**~\n\n<br/>\n\n- **关于前端视频的推荐：**\n\n  **◇ 搞后端的,也要学前端？？？**\n\n  ◆ 对项目沟通、协作是一种助力，现在项目都是团队一起开发的，不可能你一个人关起门来造轮子鸭~需要沟通协助，搞后端的，作为新人，不一定在那个公司，你就纯粹的只做后端相关的，小公司可以是需要干全栈的活。团队一起开发同一一个项目，再说学前端的知识也能更好的和前端同事交流。\n\n  ▷ **推荐理由**：看过那个java付费视频配套送的前端视频，也看过尚硅谷的前端视频，觉得**尚硅谷的js、Ajax**讲得很不错，真心推荐;然后Vue框架是偶遇同乡会的一个师兄，他在实验室是学前端为主的，他看过**王红元的vue视频**觉得很不错，我看过也觉得很不错~\n\n  ◇ [5天揭秘js高级技术-第3天的第6讲_prototype原型必看！通俗易懂！](https://www.bilibili.com/video/BV1gE411f7Fu)\n\n  ◇ [【尚硅谷】3小时Ajax入门到精通](https://www.bilibili.com/video/BV1WC4y1b78y)\n\n  ◇ [2019年coderwhy vue-vuejs从入门到精通教程](https://www.bilibili.com/video/BV17j411f74d)\n\n\n<br/><br/>\n\n\n### ★ 我是怎么找学习视频/书籍\n\n<br/>\n\n\n#### ▷ 找视频：\n\n##### 1、自己手动搜索：关键字+\"入门\"/\"教程\"/\"零基础\"/\"高级\"\n\n##### 2、看播放量比较高的老师，`试听一下`，然后看一下评论\n\n- **试听很重要的**，有时候，视频的**音质**不好，虽然播放量比较高，但是还有其他选择呢，心疼我的耳朵，我就舍弃该视频了。还有，如果遇到老师的声音对于我个人，听起来很**催眠**，我也直接舍弃。\n- 评论**差评比较多**的情况下，我就舍弃了，少数的差评，就跟购物一样，存在也是正常的现象\n\n##### 3、对比两三个播放量比较高的视频，对比视频时长、视频时间、视频章节目录\n\n- 同一个关键词，搜索出来的视频，**我个人会挑选时长多两三个小时的视频**\n- 视频时间，这个我觉得**只要不是特别古老都可以接收**，毕竟基础知识点都是差不多的，对于老师，他没必要去重新录一个内容差不多的视频\n\n- 章节目录，这个看眼缘吧，有时候因为还没学，看不懂，就没看了\n\n##### 4、看一下有没有熟悉的老师\n\n- 在新老师和熟悉的老师之间，我会比较念旧情，**选择熟悉的老师**\n\n\n\n> #### ✿ 分享两个看视频的小技巧：\n>\n> ​    看视频比较多的我，有两个小技巧要跟小伙伴分享：**一个是看视频的倍数，可以选择1.5或者2倍速**，一开始，我不习惯是加速，选择了1.5倍速，后边看番剧多了，习惯2倍速，学习视频也变2倍速了哈哈哈。在学习过程中遇到一个知识点，听起来感觉懵懵懂懂的时候，我会选择降速重新听该知识点，减到1.25倍速，然后再听一遍，实在还是听不懂该知识点，我就正常速度听两遍。还是听不懂，我选择放弃（做人需要学会放弃，才有机会重来），后边再来。\n>\n> ​     另外一个小技巧是**一个知识点学完，就模仿敲出一个知识点的代码，不是全听完视频，也不是跟着视频的老师同时敲**，我选择等他这个知识点完全讲完，代码也敲完，我暂定一下视频，然后记记笔记，立马模仿敲出该知识点的代码。\n\n\n<br/><br/>\n\n\n\n#### ▷ 找书：\n\n##### 1、直接百度/谷歌搜一下\n\n##### 2、微信读书搜一下\n\n##### 3、在网站搜一下：\n\n- 网站推荐1：https://www.code-nav.cn/      \n\n- 网站推荐2：https://www.bookstack.cn/ \n\n##### 4、花两三块钱代找，淘宝搜代找书即可\n\n\n\n<br/><br/>\n\n\n\n# 二、作为过来人，私藏学习心得分享\n\n<br/>\n\n### 1、保持兴趣、保持好奇，多问为什么？\n\n<br/>\n\n### ★ 金钱的激励是一定的，过程需要体验到快乐，才能坚持到底\n\n<br/>\n\n​     当然，我也知道有非常多的小伙伴，是冲着高薪来到这个专业，这个行业，哪怕是计算机专业的，也有非常多的宝宝，习惯了做“乖宝宝”的小伙伴，上课就听课，考试就背题库，四年，你真的有认真学习吗？在其他专业、其他行业的社会打工人，也每天刷着短视频，了解到计算机的高薪，对眼前的薪资早已不满，想转行来计算机修仙。但是，想要长远的发展，兴趣是最好的老师，**唯有热爱，可抵挡漫漫长夜。**高薪，也不属于每个打工人，初学者，把\"月薪xx万\"作为一个吊在自己前进的诱惑，**这根诱惑你向前的胡萝卜，真的可以一直诱惑到你吗**，在这里我想反问一句，众所周知，清华北大出来的，未来一片光明，那么，高考的时候，**那片光明为啥没落到你头上呢？**\n\n<br/>\n\n   就像我为什么这么认真的写文章，我当然也会抱着一丝万一某一天写作给我带来收益的幻想，但是 **`对于写作这件事，我也是有八分热爱在里边的`**。因为我本身是话很多，但是现在大家都要么工作，要么学习，**话痨的我，总不能老没事打扰身边的人吧，**而通过写作，我可以叨叨给我的读者，**同时读者的每个赞，又鼓励到我，让我记住不能写水文，不能卖焦虑欺骗读者。**\n\n\n<br/>\n\n\n### ★ 保持好奇，多问为什么\n\n\n![228244820220315224425527293538366.png](https://niu.yilele.site/cb0427e9-a993-4f71-9db5-a941aae4f756.png)\n\n\n<br/>\n\n​	在时间的积累过程，你终会有豁然开朗的感觉。学编程，在初期，可能会有一个小伙伴跟我们一起打卡，但是就算是恋人，两个人的成长速度也是不同的，学编程，你终会体验到独自安静思考的魅力。独自一个人，更要保持扪心自问一声为什么。**为什么跳到这一步？为什么结果是这样的？为什么会出现这个bug?为什么需要这么设计？为什么使用某某技术？这个某某知识，还有其他有意思的地方吗？**\n\n#####   `通过为什么，你会不断的自行到百度或谷歌搜索,从而锻炼了自己的动手解决问题的能力，积累更多的编程经验。`\n\n\n<br/><br/>\n\n\n### 2、光看不练假把式、好记性不如烂笔头\n\n​<br/>    \n\n   初学者学编程容易懒惰，就看着视频，觉得自己都听懂了，都会了，以前高考的时候，上课你不都是听懂了，考啥样了，你还不清楚吗?反而那些小镇做题家他们依靠题海战术，也取得了不错的成绩。**看的知识，那是你的吗？那是你对面那个在厂里卷了好几年的过来人的经验分享呀。** **`你的知识，需要你从一步一步的模仿再到独立完成，最终完全吸收`**。光看不练，是不可能学会的，除非要么是学过，看视频复习一遍，要么就是天赋过人。\n\n<br/>\n\n   学编程，跟咱学一个新东西一样，**每个人的脑容量是有限的，而知识是无限的，需要你反复复习，强化记忆**。所以，笔记，给我记起来~\n\n   \n<br/><br/>\n\n\n### 3、敢于挑战、变强后敢于啃硬骨头\n\n<br/>    \n\n   **`作为初学者的时候，看不懂源码是很正常的`，**但是，你要记住这块硬骨头，你要变强后回来啃它。**初学者，在阅读源码上，至少不要做逃兵。**当你实力不够的时候，你可以先了解关于阅读源码相关的，**看某个框架的时候，整套视频涉及到源码分析的部分，不要直接跳过。**慢慢了解，不要心急，一口气是吃不成胖子的。在学习路线上，看视频的过程，涉及到源码阅读和分析的，都认真动手尝试调试阅读源码，**在调试的过程中熟练掌握了调试工具的使用；在调试的过程中，阅读源码有了自己的技巧；在调试的过程中，阅读源码知道了重点；`在阅读源码的过程中越来越自信`**......\n\n<br/>\n\n> #### ✿ 上道热菜springMVC，保姆级演示，手把手带你阅读springMVC源码：\n>\n> [【阅读SpringMVC源码】调试观察验证SpringMVC执行流程](https://www.cnblogs.com/shan333/p/15983643.html)\n\n<br/>\n\n  **`作为初学者的时候，理解不了经典的设计思想是很正常的`，**但是，**你可以手动搜索跟设计思想有关的博文，加深对该思想的理解；也可以把该思想有关的例子，动手实践多敲两遍；还可以先标记一下，等学到后边复习的时候，重新理解它**。经典的思想，一开始没理解，没想明白很正常，之所以经典，说明就不是简单的东西，正是前人苦事冥想良久才得出的伟大创造。\n\n\n<br/><br/>\n\n\n### 4、遇到bug，不要依赖别人给你解决答案，要自己动手分析解决\n\n<br/>   \n\n​    作为初学者的时候，遇到各种麻烦、各自警告、各种bug，我们会容易着急、烦躁、头疼、甚至怀疑自己，**但是请不要放弃，每个人都是这么过来的**。**在学习的路上，没有什么捷径，走捷径总有一天会被反噬。**当你的技术能力匹配不上你的薪水，靠包装，活干不出的时候，你也许会找各个老师询问解决的办法，但是老师能给你的，就剩下鸡汤。\n\n​ **`你需要做的是，不是在各个群里，小白发出求救信号，也不是向微信不不熟悉的大佬求教，而是动手，动手，动手`** 。复制你的bug的报错信息到浏览器的地址栏，以及更换一下关键词，自己动手搜索答案，同时解决bug之后，分析一下bug的产生，积累下一个bug的经验。日积月累，不断地提升解决bug的能力，不断地思考，不断地动手去尝试，“在岸边是学不会游泳的”。\n\n​    **`作为初学者，遇到bug，你要动手去解决bug，因为这是你“惹的~”。`**\n\n\n\n\n![2282448202203152244401071098137833.png](https://niu.yilele.site/46ebea69-f9bb-43d5-b97b-bf0bbe1d3afd.png)\n\n<br/><br/><br/>\n\n\n\n## 三、其他关于编程的分享\n\n\n\n> ### ✿ 诚邀你欣赏我创作的恋爱式java学习大总结，文章如下：\n>\n> [像追女神一样学好java~](https://www.cnblogs.com/shan333/p/15966444.html)\n\n\n\n### 1、不要做一个收藏党，干起来\n\n​    收藏夹真的会吃灰的哦~不要太纠结，很多东西老师就算讲得有质量高低之分，但是只要差不是太多，问题都不大的，学完的后期是一个完善和思考的过程~\n\n### 2、加群要是没有学到东西，请不要浪费时间于水群\n\n​	同是话痨的我本人，就曾水过，不知不觉中浪费了很多时间，所以分享以避坑~\n\n### 3、鉴别和阅读高质量的博文\n\n​    不断地提升辨识力吧~\n\n### 4、多做项目、多思考为什么\n\n​    实践才能出真理~\n\n### 5、不断地思考总结，总结出自己的学习方法\n\n​    做一个合格的调包侠、掌握核心的api~\n\n### 6、分享我关注的与编程有关的有趣的up主【`看个人喜好，学会鉴别`】\n\n   不高兴就喝水、CodeSheep、遇见狂神说、鲁班大叔_007、程序员鱼皮\n\n<br/><br/>\n\n\n##   写在后面的话\n\n   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     如果你觉得一乐的文章给您带来了一些收获，可以给个**三连**❤️ ，一乐会一如既往地更新有价值的博客。如果文章存在错误，也欢迎大家指出。还有，如果大家有什么好的学习技巧、学习感悟，也非常欢迎大家在评论区一起交流~\n\n**最后感谢大家的支持，谢谢~**', '<br/>\n<p><strong>✿ 贴心提示：文章内容比较长，但都是干货，请大家耐心看完。时间不够充裕的小伙伴，建议收藏，一定要耐心看完，保证对你有后续学习java有所帮助。</strong></p>\n<br/>\n<h1><a id=\"_10\"></a>一、推荐背景介绍</h1>\n<h2><a id=\"_12\"></a>（一）我是怎么学的？</h2>\n<h3><a id=\"__14\"></a>★ 非常普通的人，因为够普通，所以能给你提供更加真实的参考价值</h3>\n<br/>\n<p>​     简单介绍一下我自己， <strong><code>一所普通二本学校的普通学生</code></strong>，在高考失利后，灰心地刷视频选专业的时候，刷到一个视频，讲到“你不知道选什么专业，就选计算机”。然后在我那思想还停留在玩手机会耽误学习的爸爸的完美计划里，等到大学开学我才拿到笔记本电脑，然后<strong>从打字开始学的</strong>。由于我的学校很普通，<strong>课堂就如大家所想的差不多，百度一下就有的ppt</strong>，而思维转化比较慢的我， <strong><code>经历了免费群的每日作业打卡到花钱的线上培训</code></strong> ，当时是看到有活动半价入手了某机构的课程(2K),<strong>现在的我，长大啦</strong><sub>肯定不会傻傻地花钱买质量差不多的视频课程啦</sub></p>\n<br/>\n<p>​    普通的我，大学才有电脑；普通的我，操作电脑从打字开始；普通的我，曾为免费群打卡的奖励的赢得了一本书而开心好几天；普通的我，曾花钱买免费的质量差不的课程。现在的我，依然很普通，但是我在经过了前面的弯弯绕绕的我，判断意识得到了提示，<strong>知道捂住原本就干瘪的钱包了~</strong> 钱要花在刀刃上~</p>\n<p><img src=\"https://niu.yilele.site/d5705514-c1bb-4ae7-9d4b-f31d3b6fa666.png\" alt=\"228244820220315224339108780565735.png\" /></p>\n<p><br/><br/></p>\n<h2><a id=\"__30\"></a>(二) 我的学习方式</h2>\n<h3><a id=\"_or_32\"></a>★ 看书or看视频？</h3>\n<p>​    我本人是主要以看视频为主的，至于为什么看视频为主，看书看博客文章为辅的理由很简单。我本人呀，对不正经的各种小说着迷，甚至梦里还在上演着小说的情节，但是一旦看正而八经的学习材料的书籍，哎呀，我饿了，累了，休息一下……所以，对于你，我想问一句：**兄弟，你是爱看书的人吗？**看书还是看视频，看你哪一个能坚持的更久就行了呗，不用纠结啦~</p>\n<br/>\n<h3><a id=\"__38\"></a>★ 分享我看过的视频和找学习资料的建议：</h3>\n<p>■ <strong><code>后边我会给出观看学习java的路线，以及给出每个视频的推荐理由</code>，<code>放心，我会给出我最真实的感受</code></strong>，但是，<strong>听课的人是你，希望你能试听一下</strong>，结合自己的感受选择是否观看【 <strong><code>你的感受才是最重要的哦~</code></strong> 】</p>\n<br/> \n<ul>\n<li>\n<p><strong>C语言</strong>：<code>这个可以跳过，不是java主路线，如果是大一新生的话，入门学校教的是C语言的话，可以看一下C语言视频</code>，我本来是看小甲鱼的C语言，但是看到一半，换成了老九学堂的C语言：</p>\n<p>▷ 推荐：<a href=\"https://www.bilibili.com/video/BV1av411z75R\" target=\"_blank\">【零基础学C语言】老九零基础学习编程系列之一 老九学堂徐嵩老师主讲</a></p>\n<p>▷ <strong>推荐理由</strong>：小甲鱼的视频，是大一的时候，上课要学谭浩强的《C程序设计》学得懵懵懂懂的，就问了同计算机系的一个师兄，“C语言视频推荐”，后边看到一半，实在是多次觉得比课本还不好懂，就自己动手去搜“零基础学编程C语言”，然后看到播放量比较高的视频—许嵩老师的C语言，<strong>真心讲，这个C语言是他家粉丝的加群动力，讲得非常好懂，许嵩老师讲课段子是一段一段的，还融合了编程知识，非常有趣~</strong></p>\n</li>\n</ul>\n <br/> \n<ul>\n<li>\n<p><strong>java 视频</strong>【<code>花钱了</code>】: 视频加密了，分享了也观看不了~</p>\n<p>▷ 推荐(<code>同价位的免费替代</code>)：尚硅谷的宋红康老师的java</p>\n<p><a href=\"https://www.bilibili.com/video/BV1Kb411W75N\" target=\"_blank\">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p>\n<p>▷ <strong>推荐理由</strong>：java那个视频花了2K钱，在小鹅通看的，推荐宋红康老师的java视频，是因为看完付费视频后，对比了免费的视频的章节的目录，然后试听了一下，发现为什么我C语言记得去搜一下，还可能就是在免费群打卡，获得书本，加上活动半价，贪便宜，<strong>忘记了自己的贫穷</strong>~</p>\n</li>\n</ul>\n<p><img src=\"https://niu.yilele.site/5e47fe2b-cb8d-4e4e-81fe-a5248e7fda55.png\" alt=\"228244820220315224325049888885481.png\" /></p>\n<br/>\n<ul>\n<li>\n<p><strong>mysql视频</strong>：看过黑马的增强改查视频，也看过那个java付费视频配套送的mysql，还看过小码哥的mysql：</p>\n<p>▷ 推荐：<a href=\"https://www.bilibili.com/video/BV1oK4y1e7Wq\" target=\"_blank\">【小码哥教育】JAVA第二季MySQL基础（适合Java 0基础，Java初学入门，程序员，IT）</a></p>\n<p>▷ <strong>推荐理由</strong>：经过了对比，觉得这个讲得比较细，而且老师的声音也很温柔，良心推荐</p>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p><strong>jdbc视频</strong>：看过那个java付费视频配套送的jdbc，还看过小码哥的jdbc：</p>\n<p>▷ 推荐：<a href=\"https://www.bilibili.com/video/BV1hv411v7jP\" target=\"_blank\">【小码哥教育】JAVA第三季JDBC</a></p>\n<p>▷ <strong>推荐理由</strong>：jdbc的内容也可以划分于mysql，可以看和mysql视频的同一个老师</p>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p><strong>javaWeb视频</strong>：看过那个java付费视频配套送的javaWeb【<strong>别问为啥送怎么多，问就是搞周年活动鸭</strong>】，还看过狂神的javaWeb，还看过小码哥的javaWeb</p>\n<p>▷ 推荐：<a href=\"https://www.bilibili.com/video/BV1KW411S7xR\" target=\"_blank\">Java大神之路（第四季 JavaWeb）</a></p>\n<p>▷ <strong>推荐理由</strong>：本想推荐狂神的javaWeb的，不过狂神的javaWeb是前面一半的视频讲得很不错，可能是javaWeb视频时长不够长，到了后边视频，就觉得有点蒙圈了，我就换成小码哥的长视频javaWeb，觉得讲得更加仔细些，当然狂神的也不错哟~</p>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p><strong>SSM 三大框架</strong>：对比过狂神的ssm，后边还是选择了小码哥，因为习惯了任小龙老师温柔的声音，当然狂神的SSM框架在B站也是播放量非常高的，喜欢狂神的讲课方式，看狂神的视频也是不错的~</p>\n<p>▷ 推荐： <strong><code>观看顺序是MyBatis-&gt; Spring5 -&gt; SpringMVC</code></strong></p>\n<p>▷ <strong>推荐理由</strong>：因为MyBatis是一个orm框架，用于跟数据库打交道，而咱前面有学过mysql和jdbc，所以建议先看MyBatis，而接着是Spring，因为Spring的内容涵盖了Spring DAO 和 Spring TX，这两部分也是与咱前面学过mysql和jdbc有关的，最后再看Spring的子集SpringMVC。</p>\n<p>◇ <a href=\"https://www.bilibili.com/video/BV1KW41127QV\" target=\"_blank\">Java大神之路（第七季  MyBatis完整版）</a></p>\n<p>◇ <a href=\"https://www.bilibili.com/video/BV1KW41127B1\" target=\"_blank\">Java大神之路（第八季 Spring5）</a></p>\n<p>◇ <a href=\"https://www.bilibili.com/video/BV1KW41127aN\" target=\"_blank\">Java大神之路（第九季 SpringMVC）</a></p>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p><strong>SpringBoot 框架</strong>：对比狂神和尚硅谷，选择了尚硅谷的SpirngBoot</p>\n<p>▷ 推荐：<a href=\"https://www.bilibili.com/video/BV19K4y1L7MT\" target=\"_blank\">尚硅谷雷神SpringBoot2零基础入门springboot全套完整版（spring boot2）</a></p>\n<p>▷ <strong>推荐理由</strong>：个人也比较喜欢雷神的讲课方式，之前也看过尚硅谷的js视频、Ajax视频，觉得尚硅谷家的视频也是非常良心，为啥每次拿狂神老师出来晾呢？只是狂神老师讲得也很不错，才每次有他的身影，<strong>最后没有选择只是个人喜好啦</strong>~</p>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p><strong>关于前端视频的推荐：</strong></p>\n<p><strong>◇ 搞后端的,也要学前端？？？</strong></p>\n<p>◆ 对项目沟通、协作是一种助力，现在项目都是团队一起开发的，不可能你一个人关起门来造轮子鸭~需要沟通协助，搞后端的，作为新人，不一定在那个公司，你就纯粹的只做后端相关的，小公司可以是需要干全栈的活。团队一起开发同一一个项目，再说学前端的知识也能更好的和前端同事交流。</p>\n<p>▷ <strong>推荐理由</strong>：看过那个java付费视频配套送的前端视频，也看过尚硅谷的前端视频，觉得<strong>尚硅谷的js、Ajax</strong>讲得很不错，真心推荐;然后Vue框架是偶遇同乡会的一个师兄，他在实验室是学前端为主的，他看过<strong>王红元的vue视频</strong>觉得很不错，我看过也觉得很不错~</p>\n<p>◇ <a href=\"https://www.bilibili.com/video/BV1gE411f7Fu\" target=\"_blank\">5天揭秘js高级技术-第3天的第6讲_prototype原型必看！通俗易懂！</a></p>\n<p>◇ <a href=\"https://www.bilibili.com/video/BV1WC4y1b78y\" target=\"_blank\">【尚硅谷】3小时Ajax入门到精通</a></p>\n<p>◇ <a href=\"https://www.bilibili.com/video/BV17j411f74d\" target=\"_blank\">2019年coderwhy vue-vuejs从入门到精通教程</a></p>\n</li>\n</ul>\n<p><br/><br/></p>\n<h3><a id=\"__130\"></a>★ 我是怎么找学习视频/书籍</h3>\n<br/>\n<h4><a id=\"__135\"></a>▷ 找视频：</h4>\n<h5><a id=\"1_137\"></a>1、自己手动搜索：关键字+“入门”/“教程”/“零基础”/“高级”</h5>\n<h5><a id=\"2_139\"></a>2、看播放量比较高的老师，<code>试听一下</code>，然后看一下评论</h5>\n<ul>\n<li><strong>试听很重要的</strong>，有时候，视频的<strong>音质</strong>不好，虽然播放量比较高，但是还有其他选择呢，心疼我的耳朵，我就舍弃该视频了。还有，如果遇到老师的声音对于我个人，听起来很<strong>催眠</strong>，我也直接舍弃。</li>\n<li>评论<strong>差评比较多</strong>的情况下，我就舍弃了，少数的差评，就跟购物一样，存在也是正常的现象</li>\n</ul>\n<h5><a id=\"3_144\"></a>3、对比两三个播放量比较高的视频，对比视频时长、视频时间、视频章节目录</h5>\n<ul>\n<li>\n<p>同一个关键词，搜索出来的视频，<strong>我个人会挑选时长多两三个小时的视频</strong></p>\n</li>\n<li>\n<p>视频时间，这个我觉得<strong>只要不是特别古老都可以接收</strong>，毕竟基础知识点都是差不多的，对于老师，他没必要去重新录一个内容差不多的视频</p>\n</li>\n<li>\n<p>章节目录，这个看眼缘吧，有时候因为还没学，看不懂，就没看了</p>\n</li>\n</ul>\n<h5><a id=\"4_151\"></a>4、看一下有没有熟悉的老师</h5>\n<ul>\n<li>在新老师和熟悉的老师之间，我会比较念旧情，<strong>选择熟悉的老师</strong></li>\n</ul>\n<blockquote>\n<h4><a id=\"__157\"></a>✿ 分享两个看视频的小技巧：</h4>\n<p>​    看视频比较多的我，有两个小技巧要跟小伙伴分享：<strong>一个是看视频的倍数，可以选择1.5或者2倍速</strong>，一开始，我不习惯是加速，选择了1.5倍速，后边看番剧多了，习惯2倍速，学习视频也变2倍速了哈哈哈。在学习过程中遇到一个知识点，听起来感觉懵懵懂懂的时候，我会选择降速重新听该知识点，减到1.25倍速，然后再听一遍，实在还是听不懂该知识点，我就正常速度听两遍。还是听不懂，我选择放弃（做人需要学会放弃，才有机会重来），后边再来。</p>\n<p>​     另外一个小技巧是<strong>一个知识点学完，就模仿敲出一个知识点的代码，不是全听完视频，也不是跟着视频的老师同时敲</strong>，我选择等他这个知识点完全讲完，代码也敲完，我暂定一下视频，然后记记笔记，立马模仿敲出该知识点的代码。</p>\n</blockquote>\n<p><br/><br/></p>\n<h4><a id=\"__168\"></a>▷ 找书：</h4>\n<h5><a id=\"1_170\"></a>1、直接百度/谷歌搜一下</h5>\n<h5><a id=\"2_172\"></a>2、微信读书搜一下</h5>\n<h5><a id=\"3_174\"></a>3、在网站搜一下：</h5>\n<ul>\n<li>\n<p>网站推荐1：https://www.code-nav.cn/</p>\n</li>\n<li>\n<p>网站推荐2：https://www.bookstack.cn/</p>\n</li>\n</ul>\n<h5><a id=\"4_180\"></a>4、花两三块钱代找，淘宝搜代找书即可</h5>\n<p><br/><br/></p>\n<h1><a id=\"_188\"></a>二、作为过来人，私藏学习心得分享</h1>\n<br/>\n<h3><a id=\"1_192\"></a>1、保持兴趣、保持好奇，多问为什么？</h3>\n<br/>\n<h3><a id=\"__196\"></a>★ 金钱的激励是一定的，过程需要体验到快乐，才能坚持到底</h3>\n<br/>\n<p>​     当然，我也知道有非常多的小伙伴，是冲着高薪来到这个专业，这个行业，哪怕是计算机专业的，也有非常多的宝宝，习惯了做“乖宝宝”的小伙伴，上课就听课，考试就背题库，四年，你真的有认真学习吗？在其他专业、其他行业的社会打工人，也每天刷着短视频，了解到计算机的高薪，对眼前的薪资早已不满，想转行来计算机修仙。但是，想要长远的发展，兴趣是最好的老师，**唯有热爱，可抵挡漫漫长夜。**高薪，也不属于每个打工人，初学者，把&quot;月薪xx万&quot;作为一个吊在自己前进的诱惑，<strong>这根诱惑你向前的胡萝卜，真的可以一直诱惑到你吗</strong>，在这里我想反问一句，众所周知，清华北大出来的，未来一片光明，那么，高考的时候，<strong>那片光明为啥没落到你头上呢？</strong></p>\n<br/>\n<p>就像我为什么这么认真的写文章，我当然也会抱着一丝万一某一天写作给我带来收益的幻想，但是 <strong><code>对于写作这件事，我也是有八分热爱在里边的</code></strong>。因为我本身是话很多，但是现在大家都要么工作，要么学习，**话痨的我，总不能老没事打扰身边的人吧，**而通过写作，我可以叨叨给我的读者，<strong>同时读者的每个赞，又鼓励到我，让我记住不能写水文，不能卖焦虑欺骗读者。</strong></p>\n<br/>\n<h3><a id=\"__210\"></a>★ 保持好奇，多问为什么</h3>\n<p><img src=\"https://niu.yilele.site/cb0427e9-a993-4f71-9db5-a941aae4f756.png\" alt=\"228244820220315224425527293538366.png\" /></p>\n<br/>\n<p>​	在时间的积累过程，你终会有豁然开朗的感觉。学编程，在初期，可能会有一个小伙伴跟我们一起打卡，但是就算是恋人，两个人的成长速度也是不同的，学编程，你终会体验到独自安静思考的魅力。独自一个人，更要保持扪心自问一声为什么。<strong>为什么跳到这一步？为什么结果是这样的？为什么会出现这个bug?为什么需要这么设计？为什么使用某某技术？这个某某知识，还有其他有意思的地方吗？</strong></p>\n<h5><a id=\"_220\"></a><code>通过为什么，你会不断的自行到百度或谷歌搜索,从而锻炼了自己的动手解决问题的能力，积累更多的编程经验。</code></h5>\n<p><br/><br/></p>\n<h3><a id=\"2_226\"></a>2、光看不练假把式、好记性不如烂笔头</h3>\n<p>​<br/></p>\n<p>初学者学编程容易懒惰，就看着视频，觉得自己都听懂了，都会了，以前高考的时候，上课你不都是听懂了，考啥样了，你还不清楚吗?反而那些小镇做题家他们依靠题海战术，也取得了不错的成绩。<strong>看的知识，那是你的吗？那是你对面那个在厂里卷了好几年的过来人的经验分享呀。</strong> <strong><code>你的知识，需要你从一步一步的模仿再到独立完成，最终完全吸收</code></strong>。光看不练，是不可能学会的，除非要么是学过，看视频复习一遍，要么就是天赋过人。</p>\n<br/>\n<p>学编程，跟咱学一个新东西一样，<strong>每个人的脑容量是有限的，而知识是无限的，需要你反复复习，强化记忆</strong>。所以，笔记，给我记起来~</p>\n<p><br/><br/></p>\n<h3><a id=\"3_240\"></a>3、敢于挑战、变强后敢于啃硬骨头</h3>\n<br/>    \n<p>**<code>作为初学者的时候，看不懂源码是很正常的</code>，**但是，你要记住这块硬骨头，你要变强后回来啃它。**初学者，在阅读源码上，至少不要做逃兵。**当你实力不够的时候，你可以先了解关于阅读源码相关的，**看某个框架的时候，整套视频涉及到源码分析的部分，不要直接跳过。**慢慢了解，不要心急，一口气是吃不成胖子的。在学习路线上，看视频的过程，涉及到源码阅读和分析的，都认真动手尝试调试阅读源码，<strong>在调试的过程中熟练掌握了调试工具的使用；在调试的过程中，阅读源码有了自己的技巧；在调试的过程中，阅读源码知道了重点；<code>在阅读源码的过程中越来越自信</code></strong>…</p>\n<br/>\n<blockquote>\n<h4><a id=\"_springMVCspringMVC_248\"></a>✿ 上道热菜springMVC，保姆级演示，手把手带你阅读springMVC源码：</h4>\n<p><a href=\"https://www.cnblogs.com/shan333/p/15983643.html\" target=\"_blank\">【阅读SpringMVC源码】调试观察验证SpringMVC执行流程</a></p>\n</blockquote>\n<br/>\n<p>**<code>作为初学者的时候，理解不了经典的设计思想是很正常的</code>，**但是，<strong>你可以手动搜索跟设计思想有关的博文，加深对该思想的理解；也可以把该思想有关的例子，动手实践多敲两遍；还可以先标记一下，等学到后边复习的时候，重新理解它</strong>。经典的思想，一开始没理解，没想明白很正常，之所以经典，说明就不是简单的东西，正是前人苦事冥想良久才得出的伟大创造。</p>\n<p><br/><br/></p>\n<h3><a id=\"4bug_260\"></a>4、遇到bug，不要依赖别人给你解决答案，要自己动手分析解决</h3>\n<br/>   \n<p>​    作为初学者的时候，遇到各种麻烦、各自警告、各种bug，我们会容易着急、烦躁、头疼、甚至怀疑自己，<strong>但是请不要放弃，每个人都是这么过来的</strong>。**在学习的路上，没有什么捷径，走捷径总有一天会被反噬。**当你的技术能力匹配不上你的薪水，靠包装，活干不出的时候，你也许会找各个老师询问解决的办法，但是老师能给你的，就剩下鸡汤。</p>\n<p>​ <strong><code>你需要做的是，不是在各个群里，小白发出求救信号，也不是向微信不不熟悉的大佬求教，而是动手，动手，动手</code></strong> 。复制你的bug的报错信息到浏览器的地址栏，以及更换一下关键词，自己动手搜索答案，同时解决bug之后，分析一下bug的产生，积累下一个bug的经验。日积月累，不断地提升解决bug的能力，不断地思考，不断地动手去尝试，“在岸边是学不会游泳的”。</p>\n<p>​    <strong><code>作为初学者，遇到bug，你要动手去解决bug，因为这是你“惹的~”。</code></strong></p>\n<p><img src=\"https://niu.yilele.site/46ebea69-f9bb-43d5-b97b-bf0bbe1d3afd.png\" alt=\"2282448202203152244401071098137833.png\" /></p>\n<p><br/><br/><br/></p>\n<h2><a id=\"_279\"></a>三、其他关于编程的分享</h2>\n<blockquote>\n<h3><a id=\"_java_283\"></a>✿ 诚邀你欣赏我创作的恋爱式java学习大总结，文章如下：</h3>\n<p><a href=\"https://www.cnblogs.com/shan333/p/15966444.html\" target=\"_blank\">像追女神一样学好java~</a></p>\n</blockquote>\n<h3><a id=\"1_289\"></a>1、不要做一个收藏党，干起来</h3>\n<p>​    收藏夹真的会吃灰的哦<sub>不要太纠结，很多东西老师就算讲得有质量高低之分，但是只要差不是太多，问题都不大的，学完的后期是一个完善和思考的过程</sub></p>\n<h3><a id=\"2_293\"></a>2、加群要是没有学到东西，请不要浪费时间于水群</h3>\n<p>​	同是话痨的我本人，就曾水过，不知不觉中浪费了很多时间，所以分享以避坑~</p>\n<h3><a id=\"3_297\"></a>3、鉴别和阅读高质量的博文</h3>\n<p>​    不断地提升辨识力吧~</p>\n<h3><a id=\"4_301\"></a>4、多做项目、多思考为什么</h3>\n<p>​    实践才能出真理~</p>\n<h3><a id=\"5_305\"></a>5、不断地思考总结，总结出自己的学习方法</h3>\n<p>​    做一个合格的调包侠、掌握核心的api~</p>\n<h3><a id=\"6up_309\"></a>6、分享我关注的与编程有关的有趣的up主【<code>看个人喜好，学会鉴别</code>】</h3>\n<p>不高兴就喝水、CodeSheep、遇见狂神说、鲁班大叔_007、程序员鱼皮</p>\n<p><br/><br/></p>\n<h2><a id=\"_316\"></a>写在后面的话</h2>\n<p>           如果你觉得一乐的文章给您带来了一些收获，可以给个<strong>三连</strong>❤️ ，一乐会一如既往地更新有价值的博客。如果文章存在错误，也欢迎大家指出。还有，如果大家有什么好的学习技巧、学习感悟，也非常欢迎大家在评论区一起交流~</p>\n<p><strong>最后感谢大家的支持，谢谢~</strong></p>\n', 1548695365349851138);
INSERT INTO `ys_article_body` VALUES (1548698806667231234, '<br/>\n\n\n\n## 学习态度-个人建议\n\n### **☺ 不必完美主义**\n\n- 说得不好听点，叫钻牛角尖，鸡蛋里挑骨头。\n\n■ **举2个例子：**\n\n#### □ `对于实践和书中的描述不一致`\n\n   不要钻牛角尖，原地打转，卡在那里很久，从而可能出现一些不太好的负面情绪，眼见为实，否认书里的作者的不专业。\n\n   **对于初学者，很可能会因为知识不深厚，经验不足，例如你忽视了实践中的版本问题，从而出现书里描述不一致的；还有一种可能，技术的迭代，作者写该书的时候，情况如他所见，后边技术迭代，底层的实现进行了更换等原因**\n\n<br/>\n\n\n![ebece97f7629471582de914bdf820ab8.png](https://niu.yilele.site/72e1b1eb-f830-425f-bf4c-decd117a9292.png)\n\n\n\n#### □ `学习理论概念时，不用强迫精准归类划分`\n\n​    例如，对于一些比较模糊的概念或者交叉概念，不用强迫精准归类划分。比如学习内存的时候，你会了解到内存包括随机存储器、只读存储器、高速缓存(cache); 又了解到缓存分为一级缓存(cpu 缓存)、二级缓存、三级缓存。从而去了解cpu缓存，了解到\"cpu缓存的出现主要是为了解决cpu运算速度与内存读写速度不匹配的问题\"、\"缓存大小是cpu的重要指标之一\"、\"cpu 缓存是位于cpu和内存之间的临时存储器\"等\n\n这时候，你应该会疑问，这个cpu缓存[高速缓存] 还应该归类于内存吗？\n\n​    **不必纠结这个归类问题，因为没有人会考你哈哈哈。思考角度：应该从问题切入\"pu运算速度与内存读写速度不匹配\"--->出现了高速缓存[本质是寄存器]，而寄存器分内存和外存[内存之外的辅存目的是扩大容量]，高速缓存应该属于内存范畴。**\n\n还是不必纠结于精准归类划分，因为站在不同的标准的角度，划分的情况又会不同。而且也会存在一些交叉概念，了解知道它是一个什么东西，重点放在它为什么会出现上，使用它的目的。\n\n\n<br/><br/><br/>\n\n\n\n\n### ☺ 带着目的去学习了解一个新事物\n\n- 兴趣是最好的老师，但是对一个东西热爱保有兴趣也许有点难，但是好奇一个东西是什么，并不难。\n\n#### `学习态度应该是放在这个东西的使用目的上`\n\n- **它存在的目的是为了解决什么问题**\n- **它具备什么特性从而解决了什么问题**\n- **它是由什么组成的，才具备上某些特性**\n- **它具备什么特性，常常在哪些场合下使用**\n\n\n\n<br/><br/><br/>\n\n\n\n### ☺ 保持学习的效率，保持高效率\n\n- **保持高效，需要不在意无关紧要的细节，例如花里胡哨的背景、花里胡哨的字体等这种无关细节**\n- **保持高效，需要不在意不影响结果的警告等低级日志信息，有时候警告并不会影响结果，可以暂时不管它，直到排除其他问题，依然没解决，可以考虑一下是否是警告导致**\n- **保持高效，需要不在意使用率很低的工具是否够\"智能、顺手\"，浪费时间给它安装一些插件之类的**\n\n\n\n<br/><br/><br/>\n\n\n\n### ☺ 保持好奇，多问为什么\n\n**`通过为什么，你会不断的自行到百度或谷歌搜索,从而锻炼了自己的动手解决问题的能力，积累更多的编程经验。`**\n\n\n![db33dc5437524e1fb3fb96ec5c1860ff.png](https://niu.yilele.site/10f2c519-3bac-4cdd-98b7-dc7cbaf29a02.png)\n\n\n- 这个功能是靠什么快捷键、怎么实现的？\n\n- 为什么结果是这样的？\n\n- 为什么会出现这个bug?\n\n- 为什么需要这么设计？\n\n- 为什么使用某某技术？\n\n- 这个技术点，还有其他有应用的地方吗？\n\n\n<br/><br/><br/>\n\n\n\n\n### ☺ 遇到bug，不要依赖别人给你解决答案，要自己动手分析解决\n\n   **不同场景，即使问题相同，解决方式也会因为版本问题而不同，当百度或谷歌搜索不到解决途径时，重新思考一下，更换一下关键词再次搜索，搜索的解决方法都无效的时候，请静下来......**\n\n**`学会自我分析问题，思考发生问题前执行了什么操作，查看一下日志记录的信息，思考一下是不是跟版本有关，代码问题还可以自己动手debug.......`**\n\n> 作为初学者的时候，遇到各种麻烦、各自警告、各种bug，我们会容易着急、烦躁、头疼、甚至怀疑自己，**但是请不要放弃，每个人都是这么过来的**。**在学习的路上，没有什么捷径**。\n>\n> 日积月累，不断地思考，不断地动手去尝试，不断地提升解决bug的能力，经验越多，你越值钱~\n\n\n\n\n<br/><br/><br/>\n\n\n### ☺ 学会放弃，变强再回来啃硬骨头\n\n- **`离开是为了更好的归来`**\n\n​    **作为初学者的时候，看不懂源码是很正常的，**但是，你要记住这块硬骨头，你要变强后回来啃它。**初学者，在阅读源码上，至少不要做逃兵。**当你实力不够的时候，你可以先了解关于阅读源码相关的，**看某个框架的时候，整套视频涉及到源码分析的部分，不要直接跳过。**慢慢了解，不要心急，一口气是吃不成胖子的。在学习路线上，看视频的过程，涉及到源码阅读和分析的，都认真动手尝试调试阅读源码，**在调试的过程中熟练掌握了调试工具的使用；在调试的过程中，阅读源码有了自己的技巧；在调试的过程中，阅读源码知道了重点；在阅读源码的过程中越来越自信**......\n\n​    **同样，当你感知到某块知识暂时超出你的理解能力的时候，可以先放手，日后再来.......**\n\n\n![23b90985ccae4153b06b9edc71fbe75b.png](https://niu.yilele.site/44641a39-57cd-48ac-82b1-784e8be51988.png)\n\n\n\n\n\n\n<br/><br/><br/><br/>\n\n\n\n\n## 学习习惯-个人建议\n\n### ☺ 学习资料的整理存放要规范\n\n> 建议：对应学习资料，按名称建立好目录，存在在固定某个盘的某个学习目录下\n>\n> - ppt笔记、.md笔记、word笔记、execl笔记，还有源码等都要整理好存放到一个方便找的目录下，目录的命名要看到就知道是什么东西。\n> - 学习过的视频，也建议分门别类建立好目录，方便后续复习视频某个知识点的，快速查找。\n\n\n\n<br/><br/><br/>\n\n\n\n### ☺ **开发环境的安装**：\n\n#### （1）以java 开发为例：\n\n- ##### 刚入门java，会接触到jdk 和 集成工具 eclipse 或 IntelliJ IDEA：\n\n  > **`jdk`**：Java Development Kit，**`java 开发工具，开发java程序时必须要安装jdk`**。\n  >\n  > 理由：Windows 系统默认是没有java环境的，在Window 系统下无法使用有关java编译运行的一些命令。\n  >\n  > 例如我们使用eclipse 或 记事本编写了一个java 程序[最简单的helloworld程序]，需要进行编译运行，才能看到结果。而编译命令 javac 和 运行命令 java，Window 系统默认是没有这两个命令的，需要通过安装jdk，在 Window 的系统环境变量进行添加，然后在 Window 系统下才可以进行使用 javac 和 java命令。\n  >\n  > \n  >\n  > **`eclipse 或 IntelliJ IDEA`**: **集成的java开发环境的开发工具**，它也是配置依赖jdk的，具备编写java代码智能提示。\n\n<br/>\n\n\n![6786b98e49984d94a977f329bea962bb.png](https://niu.yilele.site/58b99b46-d2ec-48f9-84c9-27dab36e23f3.png)\n\n\n- ##### 编译器、编辑器和集成开发环境：\n\n  >▪ **编译器**：\n  >\n  >简单讲，编译器就是将**\"高级语言翻译为低级语言**\"的程序。编译器将**高级语言（**c++,java,等**）**写的文件翻译成系统**可执行文件**（如Windows下 **.exe**文件）的程序。\n  >\n  >▷ 常用的编译器：**gcc、clang、msbuild、javac**\n  >\n  >▪ **编辑器**：\n  >\n  >常见的编辑器有文本编辑器、网页编辑器、源程序编辑器、图像编辑器，声音编辑器和视频编辑器等。重点讲的是**代码编辑器**，**用来编写代码，查看源文件和文档**等。\n  >\n  >▷ 常用的编辑器：**NodePad++、Vim、EditPlus**\n  >\n  >▪ **集成开发环境**：\n  >\n  >用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面工具。**集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务。**\n  >\n  >▷ 常用的集成开发环境：**Visual Studio、Eclipse、IntelliJ IDEA**\n\n  \n<br/><br/>\n\n\n\n\n#### （2）软件的安装分类：\n\n#####  ① `软件的安装包有在windows下有2种形式`：\n\n- .msi的安装 [**安装版**] \n\n- .zip的安装 [**绿色的解压版**]\n\n<br/>  \n\n#####  ② 总结**安装版**.msi和 **绿色的解压版**.zip 区别：\n\n- msi 安装包：安装过程是图形界面操作、自动配置，安装操作相对简单，发生错误的解决操作简单，会生成桌面图标，可以通过图形界面设置开机自动启动等。\n\n- zip 压缩包：有解压即可用的【例如tomcat、redis】，也有需要通过手动配置，并命令行进行安装的【例如mysql、node】\n\n> **安装版**.msi和 **绿色的解压版**.zip 都可以设置电脑开启后自动启动的，只是 .msi 图形界面操作一下，而 .zip 通过命令安装一下即可\n\n<br/>\n\n#####  ③ 举例：tomcat或mysql一样 [**解压版的安装方式**]，**想实现每次电脑开启自动启动Tomcat的话，把Tomcat作为服务器安装到Windows的服务列表中：**\n\n  也是cmd切换进入tomcat根目录下bin下，其实就是为了使用 Tomcat安装目录/bin/service.bat (只不过这个脚本既有删除又有安装服务的作用)：\n\n  □ 安装服务命令：**service install**\n\n  □ 卸载服务命令：**service remove**\n\n<br/>\n\n#####  ④ `补充可执行程序.exe 和 安装包 .msi 区别`：\n\n  .exe:是可执行文件，是一个安装引导程序。**.exe文件是不依靠其他软件而单独运行的文件**，因为.exe就是软件。\n\n  .msi:msi文件是Windows Installer的数据包，包含安装一种产品所需要的信息和**在很多安装情形下安装（和卸载）程序所需的指令和数据**。\n\n\n<br/><br/>\n\n\n### （3）开发过程的环境，建议存放要规范\n\n**● 建议：建立一个文件夹 environment 统一管理一下这些环境配置文件，然后什么环境依次取名后加Environment**\n\n例如：java的环境的安装路径：E:\\environment\\javaEnvironment (如果是安装 jdk 的话，需要在 javaEnvironment建立 一个叫jdk 的目录)\n\n- 这是我的情况：\n\n\n![b0f5c2ffee6c4dc0842d94223c0d80c2.png](https://niu.yilele.site/f9cbd14c-7483-426c-ad1c-d8bb8203b93d.png)\n\n\n\n\n\n\n\n<br/><br/><br/>\n\n\n\n\n\n### ☺ 保存、备份的好习惯\n\n![8b5fbdf90c664b7d9967d22b5fb52007.jpg](https://niu.yilele.site/409ede60-601f-4678-8a9e-d1c415cb0b52.jpg)\n\n#### (1) 保存：\n\n当你写着笔记、写着平时作业，抑或是期末论文乃至是毕业论文，为了查阅资料，打开越来越多的网站，为了得到具体测试数据结果，打开多个编译器窗口，然后\n\n**`卡了!!!`，这时候，请一定把笔记、平时作业等等按一下快捷键`Ctr+s`！！！然后再去处理卡了的情况，当然也有可能是笔记记着记着卡了，这时候，听天由命，按Ctr+s，能保存多少算多少！**\n\n<br/>\n\n#### (2) 备份：\n\n##### 修改文件，记得备份！尤其是配置文件。\n\n##### 数据库备份也非常重要！！！\n\n\n\n<br/><br/><br/><br/>\n\n\n\n\n\n## 学习方法-个人建议\n\n\n### ☺ 学习新技术方面:\n\n学习一个新技术，拿看视频的方式学习Java这门语言举例，分享如果是我，在学习java这门语言，我的做法:\n\n**首先，挑选一个合适的视频，通过对比，选一个视频跟着学。**\n\n> **我个人在挑选视频做法是:**\n>\n> **`若是比较熟悉的老师，可能我个人是会带有滤镜的选择的哈哈哈。`**\n>\n>  若是非要三选一的话，我会:\n>\n> ▪ **听声音**: 若是音质嘈杂的或老师的声音是否踩到催眠雷区的，都不要。\n>\n> ▪ **看时长**: 一般时长比较长的讲得更加详细更深入，但是，不一定有那么多时间跟着学习下来，也不一定需要掌握得那么深入，这个需要根据自己的时间安排选择。\n>\n> ▪ **看章节目录**: 我个人更喜欢小结多的，在讲几个小知识点后，然后用一个小Demo串起来的。\n>\n> ▪ **老师的讲课方式**: 可以通过涉及解决某个问题的章节等方式。\n\n<br/>\n\n#### ● 在看章节目录的时候，为什么我个人更喜欢小结多的?\n\n   在讲几个小知识点后，然后用一个小Demo串起来的。这样就可以根据自己的时间安排，时间赶的话，就只动手练习后面这个串起来的Demo。时间不赶，就跟着视频把常用的语法，api都手动敲一遍。\n\n​    **不过，我觉得看个人的编程能力到哪一步叭，完全零基础，建议你还是老老实实每个语法，每个api跟着，然后串起前面几个小知识的小Demo，第一遍跟着敲，第二遍自己敲，不会再看一下视频，第三遍，自己敲，不会再看。已经有基础的话，就没必要每个语法，每个api都手动跟着，可以等到小Demo的时候，敲一两遍小Demo即可**。\n\n\n\n<br/><br/><br/>\n\n\n\n### ☺ 建议动手实践：\n\n**`对于练习，不应该是机械重复，而是有效练习。`**\n\n![e4d4c36752d5400a92d18cd635430577.png](https://niu.yilele.site/82258d29-554d-4209-bc9e-c5bed8195c9a.png)\n\n\n\n\n#### 建议你动手的场景:\n\n- **动手测试观察**：例如好奇前端的某个样式，你想不起来它的效果是什么，眼见为实，你建一个小Demo，总比你去各大平台苦苦等待别人的回答好\n\n- **动手解决bug**：搜索的方法都没能解决，若是代码问题，你动手调试一下呀，不要害怕调试能力差，这不是就给你机会练习了吗？\n\n  还有记得查看日志记录，再搜索一下问题。\n  还不行，静下来分析出错前干了什么，回退到正常情况，验证一下是不是某一步骤的影响导致错误或警告……\n\n  \n\n<br/><br/><br/>\n\n\n\n### ☺ 解决问题思路方面：\n\n#### ● 搜索解决：\n\n- 首先我也是**直接百度**，百度不行，\n\n- 百度出来的大多是某个网站重复的无效解决方案，我会**使用搜索技巧**的减号，减掉这个网站名，排除这个网站内容的干扰。\n  发现直接百度+排除干扰选项后，还是找不到解决方案。\n\n- **更换搜索引擎为谷歌或者更改搜索的关键词**。（自行搜索解决怎么访问谷歌哈哈哈）\n\n- 还是不行，我会在**国外最大的程序员问答网站进行搜索**，StackOver是偏应用方面的问答，Stack Exchange 是偏向理论方面的问答。\n\n  > stackoverflow网址：https://stackoverflow.com/\n  >\n  > stackexchange网址：https://stackexchange.com/\n  >\n  > - 懒得注册账号之类的，也可以通过搜索技巧的inurl，访问到这两个网址\n\n<br/>\n\n\n\n\n#### ● 自己分析解决：\n\n搜索无果，静下心来，自己分析解决。首先，**`回忆出现错误前，干了什么，回退到正常情况，验证一下是不是某一步骤的影响导致错误或警告`**……\n\n还是不行，自己**`手动调试或者查看日志记录`**，**实在想不明白的时候，请不要忘记考虑版本问题，是不是版本兼容问题，版本的迭代底层实现的更换等等**\n\n\n\n\n![2b1870d8e8fc4a5585c8cb59fcaad7d5.jpg](https://niu.yilele.site/faecc421-8ca1-4dc9-b62e-3761abc0f5ab.jpg)\n\n\n\n\n\n\n\n\n\n<br/><br/>\n\n**如果本文对你有帮助的话记得给一乐点个赞哦，感谢！**\n', '<br/>\n<h2><a id=\"_4\"></a>学习态度-个人建议</h2>\n<h3><a id=\"__6\"></a><strong>☺ 不必完美主义</strong></h3>\n<ul>\n<li>说得不好听点，叫钻牛角尖，鸡蛋里挑骨头。</li>\n</ul>\n<p>■ <strong>举2个例子：</strong></p>\n<h4><a id=\"__12\"></a>□ <code>对于实践和书中的描述不一致</code></h4>\n<p>不要钻牛角尖，原地打转，卡在那里很久，从而可能出现一些不太好的负面情绪，眼见为实，否认书里的作者的不专业。</p>\n<p><strong>对于初学者，很可能会因为知识不深厚，经验不足，例如你忽视了实践中的版本问题，从而出现书里描述不一致的；还有一种可能，技术的迭代，作者写该书的时候，情况如他所见，后边技术迭代，底层的实现进行了更换等原因</strong></p>\n<br/>\n<p><img src=\"https://niu.yilele.site/72e1b1eb-f830-425f-bf4c-decd117a9292.png\" alt=\"ebece97f7629471582de914bdf820ab8.png\" /></p>\n<h4><a id=\"__25\"></a>□ <code>学习理论概念时，不用强迫精准归类划分</code></h4>\n<p>​    例如，对于一些比较模糊的概念或者交叉概念，不用强迫精准归类划分。比如学习内存的时候，你会了解到内存包括随机存储器、只读存储器、高速缓存(cache); 又了解到缓存分为一级缓存(cpu 缓存)、二级缓存、三级缓存。从而去了解cpu缓存，了解到&quot;cpu缓存的出现主要是为了解决cpu运算速度与内存读写速度不匹配的问题&quot;、“缓存大小是cpu的重要指标之一”、&quot;cpu 缓存是位于cpu和内存之间的临时存储器&quot;等</p>\n<p>这时候，你应该会疑问，这个cpu缓存[高速缓存] 还应该归类于内存吗？</p>\n<p>​    <strong>不必纠结这个归类问题，因为没有人会考你哈哈哈。思考角度：应该从问题切入&quot;pu运算速度与内存读写速度不匹配&quot;—&gt;出现了高速缓存[本质是寄存器]，而寄存器分内存和外存[内存之外的辅存目的是扩大容量]，高速缓存应该属于内存范畴。</strong></p>\n<p>还是不必纠结于精准归类划分，因为站在不同的标准的角度，划分的情况又会不同。而且也会存在一些交叉概念，了解知道它是一个什么东西，重点放在它为什么会出现上，使用它的目的。</p>\n<p><br/><br/><br/></p>\n<h3><a id=\"__41\"></a>☺ 带着目的去学习了解一个新事物</h3>\n<ul>\n<li>兴趣是最好的老师，但是对一个东西热爱保有兴趣也许有点难，但是好奇一个东西是什么，并不难。</li>\n</ul>\n<h4><a id=\"_45\"></a><code>学习态度应该是放在这个东西的使用目的上</code></h4>\n<ul>\n<li><strong>它存在的目的是为了解决什么问题</strong></li>\n<li><strong>它具备什么特性从而解决了什么问题</strong></li>\n<li><strong>它是由什么组成的，才具备上某些特性</strong></li>\n<li><strong>它具备什么特性，常常在哪些场合下使用</strong></li>\n</ul>\n<p><br/><br/><br/></p>\n<h3><a id=\"__58\"></a>☺ 保持学习的效率，保持高效率</h3>\n<ul>\n<li><strong>保持高效，需要不在意无关紧要的细节，例如花里胡哨的背景、花里胡哨的字体等这种无关细节</strong></li>\n<li><strong>保持高效，需要不在意不影响结果的警告等低级日志信息，有时候警告并不会影响结果，可以暂时不管它，直到排除其他问题，依然没解决，可以考虑一下是否是警告导致</strong></li>\n<li><strong>保持高效，需要不在意使用率很低的工具是否够&quot;智能、顺手&quot;，浪费时间给它安装一些插件之类的</strong></li>\n</ul>\n<p><br/><br/><br/></p>\n<h3><a id=\"__70\"></a>☺ 保持好奇，多问为什么</h3>\n<p><strong><code>通过为什么，你会不断的自行到百度或谷歌搜索,从而锻炼了自己的动手解决问题的能力，积累更多的编程经验。</code></strong></p>\n<p><img src=\"https://niu.yilele.site/10f2c519-3bac-4cdd-98b7-dc7cbaf29a02.png\" alt=\"db33dc5437524e1fb3fb96ec5c1860ff.png\" /></p>\n<ul>\n<li>\n<p>这个功能是靠什么快捷键、怎么实现的？</p>\n</li>\n<li>\n<p>为什么结果是这样的？</p>\n</li>\n<li>\n<p>为什么会出现这个bug?</p>\n</li>\n<li>\n<p>为什么需要这么设计？</p>\n</li>\n<li>\n<p>为什么使用某某技术？</p>\n</li>\n<li>\n<p>这个技术点，还有其他有应用的地方吗？</p>\n</li>\n</ul>\n<p><br/><br/><br/></p>\n<h3><a id=\"_bug_96\"></a>☺ 遇到bug，不要依赖别人给你解决答案，要自己动手分析解决</h3>\n<p><strong>不同场景，即使问题相同，解决方式也会因为版本问题而不同，当百度或谷歌搜索不到解决途径时，重新思考一下，更换一下关键词再次搜索，搜索的解决方法都无效的时候，请静下来…</strong></p>\n<p><strong><code>学会自我分析问题，思考发生问题前执行了什么操作，查看一下日志记录的信息，思考一下是不是跟版本有关，代码问题还可以自己动手debug.......</code></strong></p>\n<blockquote>\n<p>作为初学者的时候，遇到各种麻烦、各自警告、各种bug，我们会容易着急、烦躁、头疼、甚至怀疑自己，<strong>但是请不要放弃，每个人都是这么过来的</strong>。<strong>在学习的路上，没有什么捷径</strong>。</p>\n<p>日积月累，不断地思考，不断地动手去尝试，不断地提升解决bug的能力，经验越多，你越值钱~</p>\n</blockquote>\n<p><br/><br/><br/></p>\n<h3><a id=\"__112\"></a>☺ 学会放弃，变强再回来啃硬骨头</h3>\n<ul>\n<li><strong><code>离开是为了更好的归来</code></strong></li>\n</ul>\n<p>​    **作为初学者的时候，看不懂源码是很正常的，**但是，你要记住这块硬骨头，你要变强后回来啃它。**初学者，在阅读源码上，至少不要做逃兵。**当你实力不够的时候，你可以先了解关于阅读源码相关的，**看某个框架的时候，整套视频涉及到源码分析的部分，不要直接跳过。**慢慢了解，不要心急，一口气是吃不成胖子的。在学习路线上，看视频的过程，涉及到源码阅读和分析的，都认真动手尝试调试阅读源码，<strong>在调试的过程中熟练掌握了调试工具的使用；在调试的过程中，阅读源码有了自己的技巧；在调试的过程中，阅读源码知道了重点；在阅读源码的过程中越来越自信</strong>…</p>\n<p>​    <strong>同样，当你感知到某块知识暂时超出你的理解能力的时候，可以先放手，日后再来…</strong></p>\n<p><img src=\"https://niu.yilele.site/44641a39-57cd-48ac-82b1-784e8be51988.png\" alt=\"23b90985ccae4153b06b9edc71fbe75b.png\" /></p>\n<p><br/><br/><br/><br/></p>\n<h2><a id=\"_133\"></a>学习习惯-个人建议</h2>\n<h3><a id=\"__135\"></a>☺ 学习资料的整理存放要规范</h3>\n<blockquote>\n<p>建议：对应学习资料，按名称建立好目录，存在在固定某个盘的某个学习目录下</p>\n<ul>\n<li>ppt笔记、.md笔记、word笔记、execl笔记，还有源码等都要整理好存放到一个方便找的目录下，目录的命名要看到就知道是什么东西。</li>\n<li>学习过的视频，也建议分门别类建立好目录，方便后续复习视频某个知识点的，快速查找。</li>\n</ul>\n</blockquote>\n<p><br/><br/><br/></p>\n<h3><a id=\"__148\"></a>☺ <strong>开发环境的安装</strong>：</h3>\n<h4><a id=\"1java__150\"></a>（1）以java 开发为例：</h4>\n<ul>\n<li>\n<h5><a id=\"javajdk___eclipse__IntelliJ_IDEA_152\"></a>刚入门java，会接触到jdk 和 集成工具 eclipse 或 IntelliJ IDEA：</h5>\n<blockquote>\n<p><strong><code>jdk</code></strong>：Java Development Kit，<strong><code>java 开发工具，开发java程序时必须要安装jdk</code></strong>。</p>\n<p>理由：Windows 系统默认是没有java环境的，在Window 系统下无法使用有关java编译运行的一些命令。</p>\n<p>例如我们使用eclipse 或 记事本编写了一个java 程序[最简单的helloworld程序]，需要进行编译运行，才能看到结果。而编译命令 javac 和 运行命令 java，Window 系统默认是没有这两个命令的，需要通过安装jdk，在 Window 的系统环境变量进行添加，然后在 Window 系统下才可以进行使用 javac 和 java命令。</p>\n<p><strong><code>eclipse 或 IntelliJ IDEA</code></strong>: <strong>集成的java开发环境的开发工具</strong>，它也是配置依赖jdk的，具备编写java代码智能提示。</p>\n</blockquote>\n</li>\n</ul>\n<br/>\n<p><img src=\"https://niu.yilele.site/58b99b46-d2ec-48f9-84c9-27dab36e23f3.png\" alt=\"6786b98e49984d94a977f329bea962bb.png\" /></p>\n<ul>\n<li>\n<h5><a id=\"_170\"></a>编译器、编辑器和集成开发环境：</h5>\n<blockquote>\n<p>▪ <strong>编译器</strong>：</p>\n<p>简单讲，编译器就是将**&quot;高级语言翻译为低级语言**&quot;的程序。编译器将<strong>高级语言（<strong>c++,java,等</strong>）<strong>写的文件翻译成系统</strong>可执行文件</strong>（如Windows下 <strong>.exe</strong>文件）的程序。</p>\n<p>▷ 常用的编译器：<strong>gcc、clang、msbuild、javac</strong></p>\n<p>▪ <strong>编辑器</strong>：</p>\n<p>常见的编辑器有文本编辑器、网页编辑器、源程序编辑器、图像编辑器，声音编辑器和视频编辑器等。重点讲的是<strong>代码编辑器</strong>，<strong>用来编写代码，查看源文件和文档</strong>等。</p>\n<p>▷ 常用的编辑器：<strong>NodePad++、Vim、EditPlus</strong></p>\n<p>▪ <strong>集成开发环境</strong>：</p>\n<p>用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面工具。<strong>集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务。</strong></p>\n<p>▷ 常用的集成开发环境：<strong>Visual Studio、Eclipse、IntelliJ IDEA</strong></p>\n</blockquote>\n</li>\n</ul>\n<p><br/><br/></p>\n<h4><a id=\"2_196\"></a>（2）软件的安装分类：</h4>\n<h5><a id=\"_windows2_198\"></a>① <code>软件的安装包有在windows下有2种形式</code>：</h5>\n<ul>\n<li>\n<p>.msi的安装 [<strong>安装版</strong>]</p>\n</li>\n<li>\n<p>.zip的安装 [<strong>绿色的解压版</strong>]</p>\n</li>\n</ul>\n<br/>  \n<h5><a id=\"_msi_zip__206\"></a>② 总结<strong>安装版</strong>.msi和 <strong>绿色的解压版</strong>.zip 区别：</h5>\n<ul>\n<li>\n<p>msi 安装包：安装过程是图形界面操作、自动配置，安装操作相对简单，发生错误的解决操作简单，会生成桌面图标，可以通过图形界面设置开机自动启动等。</p>\n</li>\n<li>\n<p>zip 压缩包：有解压即可用的【例如tomcat、redis】，也有需要通过手动配置，并命令行进行安装的【例如mysql、node】</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>安装版</strong>.msi和 <strong>绿色的解压版</strong>.zip 都可以设置电脑开启后自动启动的，只是 .msi 图形界面操作一下，而 .zip 通过命令安装一下即可</p>\n</blockquote>\n<br/>\n<h5><a id=\"_tomcatmysql_TomcatTomcatWindows_216\"></a>③ 举例：tomcat或mysql一样 [<strong>解压版的安装方式</strong>]，<strong>想实现每次电脑开启自动启动Tomcat的话，把Tomcat作为服务器安装到Windows的服务列表中：</strong></h5>\n<p>也是cmd切换进入tomcat根目录下bin下，其实就是为了使用 Tomcat安装目录/bin/service.bat (只不过这个脚本既有删除又有安装服务的作用)：</p>\n<p>□ 安装服务命令：<strong>service install</strong></p>\n<p>□ 卸载服务命令：<strong>service remove</strong></p>\n<br/>\n<h5><a id=\"_exe___msi__226\"></a>④ <code>补充可执行程序.exe 和 安装包 .msi 区别</code>：</h5>\n<p>.exe:是可执行文件，是一个安装引导程序。<strong>.exe文件是不依靠其他软件而单独运行的文件</strong>，因为.exe就是软件。</p>\n<p>.msi:msi文件是Windows Installer的数据包，包含安装一种产品所需要的信息和<strong>在很多安装情形下安装（和卸载）程序所需的指令和数据</strong>。</p>\n<p><br/><br/></p>\n<h3><a id=\"3_236\"></a>（3）开发过程的环境，建议存放要规范</h3>\n<p><strong>● 建议：建立一个文件夹 environment 统一管理一下这些环境配置文件，然后什么环境依次取名后加Environment</strong></p>\n<p>例如：java的环境的安装路径：E:\\environment\\javaEnvironment (如果是安装 jdk 的话，需要在 javaEnvironment建立 一个叫jdk 的目录)</p>\n<ul>\n<li>这是我的情况：</li>\n</ul>\n<p><img src=\"https://niu.yilele.site/f9cbd14c-7483-426c-ad1c-d8bb8203b93d.png\" alt=\"b0f5c2ffee6c4dc0842d94223c0d80c2.png\" /></p>\n<p><br/><br/><br/></p>\n<h3><a id=\"__259\"></a>☺ 保存、备份的好习惯</h3>\n<p><img src=\"https://niu.yilele.site/409ede60-601f-4678-8a9e-d1c415cb0b52.jpg\" alt=\"8b5fbdf90c664b7d9967d22b5fb52007.jpg\" /></p>\n<h4><a id=\"1__263\"></a>(1) 保存：</h4>\n<p>当你写着笔记、写着平时作业，抑或是期末论文乃至是毕业论文，为了查阅资料，打开越来越多的网站，为了得到具体测试数据结果，打开多个编译器窗口，然后</p>\n<p><strong><code>卡了!!!</code>，这时候，请一定把笔记、平时作业等等按一下快捷键<code>Ctr+s</code>！！！然后再去处理卡了的情况，当然也有可能是笔记记着记着卡了，这时候，听天由命，按Ctr+s，能保存多少算多少！</strong></p>\n<br/>\n<h4><a id=\"2__271\"></a>(2) 备份：</h4>\n<h5><a id=\"_273\"></a>修改文件，记得备份！尤其是配置文件。</h5>\n<h5><a id=\"_275\"></a>数据库备份也非常重要！！！</h5>\n<p><br/><br/><br/><br/></p>\n<h2><a id=\"_285\"></a>学习方法-个人建议</h2>\n<h3><a id=\"__288\"></a>☺ 学习新技术方面:</h3>\n<p>学习一个新技术，拿看视频的方式学习Java这门语言举例，分享如果是我，在学习java这门语言，我的做法:</p>\n<p><strong>首先，挑选一个合适的视频，通过对比，选一个视频跟着学。</strong></p>\n<blockquote>\n<p><strong>我个人在挑选视频做法是:</strong></p>\n<p><strong><code>若是比较熟悉的老师，可能我个人是会带有滤镜的选择的哈哈哈。</code></strong></p>\n<p>若是非要三选一的话，我会:</p>\n<p>▪ <strong>听声音</strong>: 若是音质嘈杂的或老师的声音是否踩到催眠雷区的，都不要。</p>\n<p>▪ <strong>看时长</strong>: 一般时长比较长的讲得更加详细更深入，但是，不一定有那么多时间跟着学习下来，也不一定需要掌握得那么深入，这个需要根据自己的时间安排选择。</p>\n<p>▪ <strong>看章节目录</strong>: 我个人更喜欢小结多的，在讲几个小知识点后，然后用一个小Demo串起来的。</p>\n<p>▪ <strong>老师的讲课方式</strong>: 可以通过涉及解决某个问题的章节等方式。</p>\n</blockquote>\n<br/>\n<h4><a id=\"__310\"></a>● 在看章节目录的时候，为什么我个人更喜欢小结多的?</h4>\n<p>在讲几个小知识点后，然后用一个小Demo串起来的。这样就可以根据自己的时间安排，时间赶的话，就只动手练习后面这个串起来的Demo。时间不赶，就跟着视频把常用的语法，api都手动敲一遍。</p>\n<p>​    <strong>不过，我觉得看个人的编程能力到哪一步叭，完全零基础，建议你还是老老实实每个语法，每个api跟着，然后串起前面几个小知识的小Demo，第一遍跟着敲，第二遍自己敲，不会再看一下视频，第三遍，自己敲，不会再看。已经有基础的话，就没必要每个语法，每个api都手动跟着，可以等到小Demo的时候，敲一两遍小Demo即可</strong>。</p>\n<p><br/><br/><br/></p>\n<h3><a id=\"__322\"></a>☺ 建议动手实践：</h3>\n<p><strong><code>对于练习，不应该是机械重复，而是有效练习。</code></strong></p>\n<p><img src=\"https://niu.yilele.site/82258d29-554d-4209-bc9e-c5bed8195c9a.png\" alt=\"e4d4c36752d5400a92d18cd635430577.png\" /></p>\n<h4><a id=\"_331\"></a>建议你动手的场景:</h4>\n<ul>\n<li>\n<p><strong>动手测试观察</strong>：例如好奇前端的某个样式，你想不起来它的效果是什么，眼见为实，你建一个小Demo，总比你去各大平台苦苦等待别人的回答好</p>\n</li>\n<li>\n<p><strong>动手解决bug</strong>：搜索的方法都没能解决，若是代码问题，你动手调试一下呀，不要害怕调试能力差，这不是就给你机会练习了吗？</p>\n<p>还有记得查看日志记录，再搜索一下问题。<br />\n还不行，静下来分析出错前干了什么，回退到正常情况，验证一下是不是某一步骤的影响导致错误或警告……</p>\n</li>\n</ul>\n<p><br/><br/><br/></p>\n<h3><a id=\"__346\"></a>☺ 解决问题思路方面：</h3>\n<h4><a id=\"__348\"></a>● 搜索解决：</h4>\n<ul>\n<li>\n<p>首先我也是<strong>直接百度</strong>，百度不行，</p>\n</li>\n<li>\n<p>百度出来的大多是某个网站重复的无效解决方案，我会<strong>使用搜索技巧</strong>的减号，减掉这个网站名，排除这个网站内容的干扰。<br />\n发现直接百度+排除干扰选项后，还是找不到解决方案。</p>\n</li>\n<li>\n<p><strong>更换搜索引擎为谷歌或者更改搜索的关键词</strong>。（自行搜索解决怎么访问谷歌哈哈哈）</p>\n</li>\n<li>\n<p>还是不行，我会在<strong>国外最大的程序员问答网站进行搜索</strong>，StackOver是偏应用方面的问答，Stack Exchange 是偏向理论方面的问答。</p>\n<blockquote>\n<p>stackoverflow网址：https://stackoverflow.com/</p>\n<p>stackexchange网址：https://stackexchange.com/</p>\n<ul>\n<li>懒得注册账号之类的，也可以通过搜索技巧的inurl，访问到这两个网址</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<br/>\n<h4><a id=\"__370\"></a>● 自己分析解决：</h4>\n<p>搜索无果，静下心来，自己分析解决。首先，<strong><code>回忆出现错误前，干了什么，回退到正常情况，验证一下是不是某一步骤的影响导致错误或警告</code></strong>……</p>\n<p>还是不行，自己**<code>手动调试或者查看日志记录</code>**，<strong>实在想不明白的时候，请不要忘记考虑版本问题，是不是版本兼容问题，版本的迭代底层实现的更换等等</strong></p>\n<p><img src=\"https://niu.yilele.site/faecc421-8ca1-4dc9-b62e-3761abc0f5ab.jpg\" alt=\"2b1870d8e8fc4a5585c8cb59fcaad7d5.jpg\" /></p>\n<p><br/><br/></p>\n<p><strong>如果本文对你有帮助的话记得给一乐点个赞哦，感谢！</strong></p>\n', 1548698806591733762);

-- ----------------------------
-- Table structure for ys_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `ys_article_tag`;
CREATE TABLE `ys_article_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(20) NOT NULL,
  `tag_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE,
  INDEX `tag_id`(`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1548946029393051650 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ys_article_tag
-- ----------------------------
INSERT INTO `ys_article_tag` VALUES (1548665638107004929, 1548665638056673281, 2);
INSERT INTO `ys_article_tag` VALUES (1548666154572627970, 1548666154505519106, 1);
INSERT INTO `ys_article_tag` VALUES (1548666437348409347, 1548666437348409346, 12);
INSERT INTO `ys_article_tag` VALUES (1548667513564872706, 1548667513564872705, 12);
INSERT INTO `ys_article_tag` VALUES (1548673409732886531, 1548673409732886530, 11);
INSERT INTO `ys_article_tag` VALUES (1548674022520700929, 1548674022449397761, 1);
INSERT INTO `ys_article_tag` VALUES (1548676806338985986, 1548676806338985985, 13);
INSERT INTO `ys_article_tag` VALUES (1548683933157736451, 1548683933157736450, 1);
INSERT INTO `ys_article_tag` VALUES (1548688984169299970, 1548688984169299969, 13);
INSERT INTO `ys_article_tag` VALUES (1548689573435457539, 1548689573435457538, 1);
INSERT INTO `ys_article_tag` VALUES (1548691214062632962, 1548691213995524097, 13);
INSERT INTO `ys_article_tag` VALUES (1548692795239743490, 1548692795239743489, 1);
INSERT INTO `ys_article_tag` VALUES (1548692795306852354, 1548692795239743489, 8);
INSERT INTO `ys_article_tag` VALUES (1548693912539414530, 1548693912539414529, 13);
INSERT INTO `ys_article_tag` VALUES (1548695365416960002, 1548695365349851138, 13);
INSERT INTO `ys_article_tag` VALUES (1548695365416960003, 1548695365349851138, 1);
INSERT INTO `ys_article_tag` VALUES (1548695365416960004, 1548695365349851138, 8);
INSERT INTO `ys_article_tag` VALUES (1548852591578378242, 1548852591532240897, 13);
INSERT INTO `ys_article_tag` VALUES (1548855094114054145, 1548855094072111106, 13);
INSERT INTO `ys_article_tag` VALUES (1548855224426885121, 1548855224359776258, 13);
INSERT INTO `ys_article_tag` VALUES (1548856721176850434, 1548856721176850433, 13);

-- ----------------------------
-- Table structure for ys_category
-- ----------------------------
DROP TABLE IF EXISTS `ys_category`;
CREATE TABLE `ys_category`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `category_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ys_category
-- ----------------------------
INSERT INTO `ys_category` VALUES (1, '/static/category/front.png', '前端', '前端是什么，大前端');
INSERT INTO `ys_category` VALUES (2, '/static/category/back.png', '后端', '后端最牛叉');
INSERT INTO `ys_category` VALUES (3, '/static/category/suanfa.jpeg', '算法', '数据结构与算法');
INSERT INTO `ys_category` VALUES (4, '/static/category/database.png', '数据库', '没数据库，啥也不管用');
INSERT INTO `ys_category` VALUES (5, '/static/category/language.png', '编程语言', '好多语言，该学哪个？');
INSERT INTO `ys_category` VALUES (6, '/static/category/fuwuqi.jpeg', '服务器', '服务器到底是个什么东西');
INSERT INTO `ys_category` VALUES (7, '/static/category/qita.jpeg', '其他', '各种技术点滴');
INSERT INTO `ys_category` VALUES (8, '/static/category/lift.jpg', '生活', '生活趣事');

-- ----------------------------
-- Table structure for ys_comment
-- ----------------------------
DROP TABLE IF EXISTS `ys_comment`;
CREATE TABLE `ys_comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `create_date` bigint(20) NOT NULL,
  `article_id` bigint(11) NOT NULL,
  `author_id` bigint(20) NOT NULL,
  `parent_id` bigint(20) NOT NULL,
  `to_uid` bigint(20) NOT NULL,
  `level` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1548979609015996418 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ys_comment
-- ----------------------------
INSERT INTO `ys_comment` VALUES (1548822332682317826, '学习学习', 1658102994493, 1548698806591733762, 1, 0, 0, '1');
INSERT INTO `ys_comment` VALUES (1548822423975538689, '加油', 1658103016270, 1548698806591733762, 1, 1548822332682317826, 1, '2');
INSERT INTO `ys_comment` VALUES (1548822704943575041, '不错不错', 1658103083257, 1548695365349851138, 1, 0, 0, '1');
INSERT INTO `ys_comment` VALUES (1548979541651279874, '评论', 1658140476032, 1548946029380468738, 1, 0, 0, '1');
INSERT INTO `ys_comment` VALUES (1548979609015996417, '好评', 1658140492098, 1548946029380468738, 1, 1548979541651279874, 1, '2');

-- ----------------------------
-- Table structure for ys_sys_user
-- ----------------------------
DROP TABLE IF EXISTS `ys_sys_user`;
CREATE TABLE `ys_sys_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `account` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '账号',
  `admin` bit(1) NULL DEFAULT NULL COMMENT '是否管理员',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `create_date` bigint(20) NULL DEFAULT NULL COMMENT '注册时间',
  `deleted` bit(1) NULL DEFAULT NULL COMMENT '是否删除',
  `email` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `last_login` bigint(20) NULL DEFAULT NULL COMMENT '最后登录时间',
  `mobile_phone_number` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码',
  `salt` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '加密盐',
  `status` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '状态',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1533750864684544002 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ys_sys_user
-- ----------------------------
INSERT INTO `ys_sys_user` VALUES (1, 'admin', b'1', 'https://niu.yilele.site/head.jpg', 20210622223122, b'0', '123456@163.com', 20210630223130, '12345678910', '一乐', 'fde24e1934c57869fb00288271443838', '12', '1');
INSERT INTO `ys_sys_user` VALUES (2, 'zhaoliying', b'1', 'https://niu.yilele.site/zhaoliying.jpeg', 1623681025218, b'0', '123456@163.com', 1623681025218, '12345678910', '赵丽颖', '1d01d52c40f4ff57ad3f93a06daf21d5', '12', '1');
INSERT INTO `ys_sys_user` VALUES (3, 'huge', b'1', 'https://niu.yilele.site/huge.jpeg', 1623681581855, b'0', '123456@163.com', 1623681581855, '12345678910', '胡歌', '8628d1f407f72e10ac947a032fe5ad29', '12', '1');
INSERT INTO `ys_sys_user` VALUES (4, 'pengyuyan', b'1', 'https://niu.yilele.site/pengyuyan.jpeg', 1654509564141, b'0', '123456@163.com', 1654509564141, '12345678910', '彭于晏', '4fd6be5688e296d287fad8b158ef62ca', '12', '1');
INSERT INTO `ys_sys_user` VALUES (5, 'bingbing', b'1', 'https://niu.yilele.site/wangbingbing.jpeg', 1654509676511, b'0', '123456@163.com', 1654509676511, '12345678910', '冰冰', '4fd6be5688e296d287fad8b158ef62ca', '12', '1');

-- ----------------------------
-- Table structure for ys_tag
-- ----------------------------
DROP TABLE IF EXISTS `ys_tag`;
CREATE TABLE `ys_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 15 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ys_tag
-- ----------------------------
INSERT INTO `ys_tag` VALUES (1, '/static/tag/java.png', '后端');
INSERT INTO `ys_tag` VALUES (2, '/static/tag/html.png', '前端');
INSERT INTO `ys_tag` VALUES (3, '/static/tag/zineng.jpeg', '人工智能');
INSERT INTO `ys_tag` VALUES (4, '/static/tag/yidong.jpg', '移动端开发');
INSERT INTO `ys_tag` VALUES (5, '/static/tag/shuxue.jpeg', '数学');
INSERT INTO `ys_tag` VALUES (6, '/static/tag/sheji.jpeg', '设计');
INSERT INTO `ys_tag` VALUES (7, '/static/tag/biancheng.jpeg', '编程语言');
INSERT INTO `ys_tag` VALUES (8, '/static/tag/java.png', 'java');
INSERT INTO `ys_tag` VALUES (9, '/static/tag/dashuju.jpeg', '大数据');
INSERT INTO `ys_tag` VALUES (10, '/static/tag/suanfa.jpeg', '算法');
INSERT INTO `ys_tag` VALUES (11, '/static/tag/yunwei.jpeg', '运维');
INSERT INTO `ys_tag` VALUES (12, '/static/tag/fuwuqi.jpeg', '服务器');
INSERT INTO `ys_tag` VALUES (13, '/static/tag/qita.jpeg', '其他');
INSERT INTO `ys_tag` VALUES (14, '/static/tag/shenghuo.jpeg', '生活');

SET FOREIGN_KEY_CHECKS = 1;
